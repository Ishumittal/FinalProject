import { Directionality } from '@angular/cdk/bidi';
import { NumberInput } from '@angular/cdk/coercion';
import { Overlay, ScrollStrategy, ViewportRuler } from '@angular/cdk/overlay';
import { AutofillMonitor } from '@angular/cdk/text-field';
import { AfterViewInit, ChangeDetectorRef, ElementRef, InjectionToken, NgZone, OnChanges, OnDestroy, OnInit, ViewContainerRef } from '@angular/core';
import { ControlValueAccessor } from '@angular/forms';
import { NxFormfieldComponent } from '@aposin/ng-aquila/formfield';
import { NxWordComponent } from '@aposin/ng-aquila/natural-language-form';
import { Observable } from 'rxjs';
import { NxAutocompleteComponent } from './autocomplete.component';
import { NxAutocompleteOptionComponent, NxAutocompleteOptionSelected } from './autocomplete-option.component';
import * as i0 from "@angular/core";
/**
 * Provider that allows the autocomplete to register as a ControlValueAccessor.
 * @docs-private
 */
export declare const NX_AUTOCOMPLETE_VALUE_ACCESSOR: any;
/** Injection token that determines the scroll handling while an autocomplete is open. */
export declare const NX_AUTOCOMPLETE_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;
/** @docs-private */
export declare function NX_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => ScrollStrategy;
/** @docs-private */
export declare const NX_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    useFactory: typeof NX_AUTOCOMPLETE_SCROLL_STRATEGY_PROVIDER_FACTORY;
    deps: (typeof Overlay)[];
};
/**
 * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.
 */
export declare function getNxAutocompleteMissingPanelError(): Error;
export declare class NxAutocompleteTriggerDirective implements ControlValueAccessor, OnDestroy, OnChanges, AfterViewInit, OnInit {
    private _element;
    private _overlay;
    private _viewContainerRef;
    private _zone;
    private _cdr;
    private _dir;
    private _autofillMonitor;
    private _nxFormField;
    private _nxWordField;
    private _document;
    private _defaultScrollStrategyFactory;
    private _viewportRuler?;
    private _overlayRef;
    private _portal;
    private _componentDestroyed;
    private _isAutofill;
    /** Old value of the native input. Used to work around issues with the `input` event on IE. */
    private _previousValue;
    /** Strategy that is used to position the panel. */
    private _positionStrategy;
    /** Whether or not the label state is being overridden. */
    private _manuallyFloatingLabel;
    /** The subscription for closing actions (some are bound to document). */
    private _closingActionsSubscription;
    /** Subscription to viewport size changes. */
    private _viewportSubscription;
    /** Subscription to control value changes */
    private _controlValueChangesSubscription;
    /** Subscription to items observable */
    private _itemsSubscription;
    /**
     * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,
     * closed autocomplete from being reopened if the user switches to another browser tab and then
     * comes back.
     */
    private _canOpenOnNextFocus;
    /** Stream of keyboard events that can close the panel. */
    private readonly _closeKeyEventStream;
    /** Value changes */
    private readonly _valueChanges;
    /** Strategy factory that will be used to handle scrolling while the autocomplete panel is open. */
    private _scrollStrategyFactory;
    /** The autocomplete panel to be attached to this trigger. */
    autocomplete: NxAutocompleteComponent;
    /** The items callback. Called with input value, must return Observable of Array of strings */
    set itemsCb(val: (val: string) => Observable<string[]>);
    get itemsCb(): (val: string) => Observable<string[]>;
    private _itemsCb;
    /** Debounce in ms before items callback is triggered. Defaults to 400 */
    set debounce(val: NumberInput);
    private _debounce;
    /** Whether autocomplete functionality is disabled. */
    set autocompleteDisabled(val: boolean);
    get autocompleteDisabled(): boolean;
    private _autocompleteDisabled;
    /** Whether or not the autocomplete panel is open. */
    get panelOpen(): boolean;
    private _overlayAttached;
    /** Stream of autocomplete option selections. */
    readonly optionSelections: Observable<NxAutocompleteOptionSelected>;
    /** The currently active option, coerced to NxAutocompleteOptionComponent type. */
    get activeOption(): NxAutocompleteOptionComponent | null;
    /** Stream of clicks outside of the autocomplete panel. */
    private get _outsideClickStream();
    private readonly _destroyed;
    /**
     * Event handler for when the window is blurred. Needs to be an
     * arrow function in order to preserve the context.
     */
    private _windowBlurHandler;
    /** `View -> model callback called when value changes` */
    _onChange: (value: any) => void;
    /** `View -> model callback called when autocomplete has been touched` */
    _onTouched: () => void;
    private get _formField();
    constructor(_element: ElementRef, _overlay: Overlay, _viewContainerRef: ViewContainerRef, _zone: NgZone, _cdr: ChangeDetectorRef, _dir: Directionality, _autofillMonitor: AutofillMonitor, _nxFormField: NxFormfieldComponent | null, _nxWordField: NxWordComponent | null, _document: Document | null, _defaultScrollStrategyFactory: () => ScrollStrategy, _viewportRuler?: ViewportRuler | undefined);
    ngOnInit(): void;
    ngOnDestroy(): void;
    ngOnChanges(): void;
    ngAfterViewInit(): void;
    /**
     * Binds or rebinds the autocomplete items. Prerequisites:
     * - items callback has to be defined
     * - autocomplete panel has to be bound
     */
    private _bindAutocompleteItems;
    /** Opens the autocomplete suggestion panel. */
    openPanel(): void;
    /** Closes the autocomplete suggestion panel. */
    closePanel(): void;
    /**
     * A stream of actions that should close the autocomplete panel, including
     * when an option is selected, on blur, and when TAB is pressed.
     */
    get panelClosingActions(): Observable<NxAutocompleteOptionSelected>;
    writeValue(value: any): void;
    registerOnChange(fn: (value: any) => void): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    _handleKeydown(event: KeyboardEvent): void;
    _handleInput(event: KeyboardEvent): void;
    private _rootElement;
    _handleFocus(): void;
    /**
     * In "auto" mode, the label will animate down as soon as focus is lost.
     * This causes the value to jump when selecting an option with the mouse.
     * This method manually floats the label until the panel can be closed.
     * @param shouldAnimate Whether the label should be animated when it is floated.
     */
    private _floatLabel;
    /** If the label has been manually elevated, return it to its normal state. */
    private _resetLabel;
    /**
     * Given that we are not actually focusing active options, we must manually adjust scroll
     * to reveal options below the fold. First, we find the offset of the option from the top
     * of the panel. If that offset is below the fold, the new scrollTop will be the offset -
     * the panel height + the option height, so the active option will be just visible at the
     * bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop
     * will become the offset. If that offset is visible within the panel already, the scrollTop is
     * not adjusted.
     */
    private _scrollToOption;
    /**
     * This method listens to a stream of panel closing actions and resets the
     * stream every time the option list changes.
     */
    private _subscribeToClosingActions;
    /** Destroys the autocomplete suggestion panel. */
    private _destroyPanel;
    private _setTriggerValue;
    /**
     * This method closes the panel, and if a value is specified, also sets the associated
     * control to that value. It will also mark the control as dirty if this interaction
     * stemmed from the user.
     */
    private _setValueAndClose;
    /**
     * Clear any previous selected option and emit a selection change event for this option
     */
    private _clearPreviousSelectedOption;
    private _attachOverlay;
    private _getOverlayConfig;
    private _getOverlayPosition;
    private _getConnectedElement;
    /** Returns the width of the input element, so the panel min-width can match it. */
    private _getHostWidth;
    /**
     * Resets the active item to -1 so arrow events will activate the
     * correct options, or to 0 if the consumer opted into it.
     */
    private _resetActiveItem;
    /** Determines whether the panel can be opened. */
    private _isFieldEnabled;
    private _flipDirection;
    static ɵfac: i0.ɵɵFactoryDeclaration<NxAutocompleteTriggerDirective, [null, null, null, null, null, null, null, { optional: true; host: true; }, { optional: true; host: true; }, { optional: true; }, null, null]>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NxAutocompleteTriggerDirective, "input[nxAutocomplete], textarea[nxAutocomplete]", ["nxAutocompleteTrigger"], { "autocomplete": "nxAutocomplete"; "itemsCb": "nxAutocompleteItems"; "debounce": "nxAutocompleteDebounce"; "autocompleteDisabled": "nxAutocompleteDisabled"; }, {}, never>;
}
