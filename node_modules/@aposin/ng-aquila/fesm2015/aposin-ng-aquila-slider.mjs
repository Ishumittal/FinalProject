import { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';
import { LEFT_ARROW, RIGHT_ARROW, UP_ARROW, DOWN_ARROW } from '@angular/cdk/keycodes';
import * as i0 from '@angular/core';
import { EventEmitter, forwardRef, Component, ChangeDetectionStrategy, Optional, Input, ViewChild, Output, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { clamp } from '@aposin/ng-aquila/utils';
import { Decimal } from 'decimal.js';
import { fromEvent } from 'rxjs';
import * as i1 from '@angular/cdk/bidi';
import * as i2 from '@angular/cdk/a11y';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';

let nextId = 0;
const DEFAULT_MIN = 0;
const DEFAULT_MAX = 100;
const DEFAULT_STEP = 1;
const DEFAULT_LABEL_POSITION = '-50%';
const VALUE_MARGIN = 4;
class NxSliderComponent {
    constructor(elementRef, _cdr, _ngZone, _dir, _focusMonitor) {
        this.elementRef = elementRef;
        this._cdr = _cdr;
        this._ngZone = _ngZone;
        this._dir = _dir;
        this._focusMonitor = _focusMonitor;
        this._dragSubscriptions = [];
        this._value = 0;
        this._decimalPlaces = 0;
        this._step = DEFAULT_STEP;
        this._id = `nx-slider-${nextId++}`;
        this._tabIndex = 0;
        this._min = DEFAULT_MIN;
        this._max = DEFAULT_MAX;
        this._label = '';
        this._inverted = false;
        this._thumbLabel = true;
        this._negative = false;
        this._hideLabels = false;
        this._disabled = false;
        this._tickInterval = 0;
        this.ticks = [];
        this._labelPosition = DEFAULT_LABEL_POSITION;
        this._longTicks = [0];
        /** An event is dispatched on each value change. */
        this.valueChange = new EventEmitter();
        /** Sets the customization function for the value which is displayed above the slider handle (Default:(value) => value). ). */
        this.valueFormatter = (value) => value;
        /** Sets the customization function for the label on the min-side of the slider (Default:(value) => value). */
        this.labelMinFormatter = (value) => value;
        /** Sets the customization function for the label on the max-side of the slider (Default:(value) => value). */
        this.labelMaxFormatter = (value) => value;
        this._onChange = () => { };
        this._onTouched = () => { };
    }
    /**
     * How often to show ticks. Relative to the step so that a tick always appears on a step.
     * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).
     */
    set tickInterval(value) {
        this._tickInterval = coerceNumberProperty(value);
        this.ticks = this.getTicks(this.min, this.max, this.step, this._tickInterval, this.longTicks);
        this._cdr.markForCheck();
    }
    get tickInterval() {
        return this._tickInterval;
    }
    /** Sets the id of the slider. */
    set id(value) {
        if (this._id !== value) {
            this._id = value;
            this._cdr.markForCheck();
        }
    }
    get id() {
        return this._id;
    }
    /** Sets the tabindex of the slider. */
    set tabindex(value) {
        this._tabIndex = coerceNumberProperty(value);
        this._cdr.markForCheck();
    }
    get tabindex() {
        return this._disabled ? -1 : this._tabIndex;
    }
    /** Sets the minimum value (Default: 0). */
    set min(value) {
        this._min = coerceNumberProperty(value);
        this.ticks = this.getTicks(this._min, this.max, this.step, this.tickInterval, this.longTicks);
        this._cdr.markForCheck();
    }
    get min() {
        return this._min;
    }
    /** Sets the maximum value (Default: 100). */
    set max(value) {
        this._max = coerceNumberProperty(value);
        this.ticks = this.getTicks(this.min, this._max, this.step, this.tickInterval, this.longTicks);
        this._cdr.markForCheck();
    }
    get max() {
        return this._max;
    }
    /** Sets the step size by which the value of the slider can be increased or decreased (Default: 1). */
    get step() {
        return this._step;
    }
    set step(value) {
        this._step = coerceNumberProperty(value, this._step);
        this.ticks = this.getTicks(this.min, this.max, this._step, this._tickInterval, this.longTicks);
        if (this._step % 1 !== 0) {
            this._decimalPlaces = this._step.toString().split('.').pop().length;
        }
        this._cdr.markForCheck();
    }
    /** Sets the label which is displayed on top of the slider. */
    set label(value) {
        if (this._label !== value) {
            this._label = value;
            this._cdr.markForCheck();
        }
    }
    get label() {
        return this._label;
    }
    /** Whether the input to the control of the slider should be disabled. */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get disabled() {
        return this._disabled;
    }
    /** Whether the max value is to the right (false) or left (true).*/
    set inverted(value) {
        this._inverted = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get inverted() {
        return this._inverted;
    }
    /** Whether to display the thumb label on top of the slider.*/
    set thumbLabel(value) {
        this._thumbLabel = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get thumbLabel() {
        return this._thumbLabel;
    }
    /** Whether the negative set of styles is applied (Default: 'false').*/
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get negative() {
        return this._negative;
    }
    /** Hides the min/max labels (Default: 'false'). */
    set hideLabels(value) {
        this._hideLabels = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get hideLabels() {
        return this._hideLabels;
    }
    /** Sets the array of value which will render as long tick (Default: Middle value if present). */
    set longTicks(value) {
        if (this._longTicks !== value) {
            this._longTicks = value;
            this.ticks = this.getTicks(this.min, this.max, this.step, this.tickInterval, this._longTicks);
            this._cdr.markForCheck();
        }
    }
    get longTicks() {
        return this._longTicks;
    }
    ngAfterViewInit() {
        this._focusMonitor.monitor(this._handleElement);
        setTimeout(() => {
            this._updateLabelPosition();
        });
    }
    /** Sets the current value of the slider. */
    set value(value) {
        this.writeValue(Number(value));
        // wait for rerender to calculate latest label position
        setTimeout(() => {
            this._updateLabelPosition();
        });
    }
    get value() {
        return this._value;
    }
    ngOnDestroy() {
        this._reset();
        this._focusMonitor.stopMonitoring(this._handleElement);
    }
    writeValue(value) {
        if (value !== this._value) {
            this._value = value;
            this.valueChange.emit(value);
            this._cdr.markForCheck();
        }
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    setDisabledState(disabled) {
        this.disabled = disabled;
    }
    _isMinimum() {
        return this._value === this.min;
    }
    /**
     * Checks if the value is in the boundaries of min/max and if it is a multiple of `step.
     */
    _isValidStep() {
        const safeValue = new Decimal(this._value).minus(this.min);
        const modulo = safeValue.mod(this.step);
        return this._isMinimum() || modulo.cmp(0) === 0;
    }
    /**
     * We have to look at two cases:
     * - current value is a valid multitude of the step size
     *   then we can safely add or subtract the step
     * - the value is not a valid multitude. this could be the max value or the value bound
     *   via nxValue
     *   then we look for the next closest value upwards or downwards
     *   decimal.js provides a nice utility function for this.
     */
    _changeValue(valueDiff) {
        let newValue = new Decimal(this._value);
        if (this._isValidStep()) {
            newValue = newValue.plus(valueDiff);
        }
        else {
            // subtract the minimum to find the closest multitude then add the minimum again to get the valid slider step
            const minAdjustedValue = new Decimal(this._value).minus(this.min);
            newValue = valueDiff < 0 ? minAdjustedValue.toNearest(this.step, Decimal.ROUND_DOWN) : minAdjustedValue.toNearest(this.step, Decimal.ROUND_UP);
            newValue = newValue.plus(this.min);
        }
        // cast the Decimal object to a JS number before it gets returned
        let toNumber = newValue.toNumber();
        toNumber = clamp(toNumber, this.min, this.max);
        if (this.value !== toNumber) {
            this._onChange(toNumber);
            this.valueChange.emit(toNumber);
            this.value = toNumber;
        }
    }
    get _percentageValue() {
        let percentageValue = (((this.value || 0) - this.min) / (this.max - this.min)) * 100;
        if (this.inverted) {
            percentageValue = 100 - percentageValue;
        }
        return clamp(percentageValue, 0, 100);
    }
    _sliderClick(event) {
        if (this.disabled) {
            return;
        }
        this._focusHandleElement();
        event.stopPropagation();
        const position = this._getPositionFromEvent(event);
        const newValue = this._getValueFromPosition(position);
        if (this.value !== newValue) {
            this.value = newValue;
            this._onChange(this.value);
        }
    }
    _focus() {
        // if (this.disabled) {}
        this._focusHandleElement();
    }
    /**
     * Prevent text selection when dragging the handle.
     */
    _selectStart() {
        return false;
    }
    _handleKeypress(event) {
        if (this.disabled) {
            return;
        }
        // TODO return statement should not substitute break keyword
        switch (event.keyCode) {
            case DOWN_ARROW:
            case this.inverted ? RIGHT_ARROW : LEFT_ARROW:
                return this._changeValue(-this.step);
            case UP_ARROW:
            case this.inverted ? LEFT_ARROW : RIGHT_ARROW:
                return this._changeValue(this.step);
        }
    }
    /**
     * This is called on mousedown or touchstart
     */
    _dragStart() {
        if (this.disabled) {
            return;
        }
        this._ngZone.runOutsideAngular(() => {
            this._dragSubscriptions.push(fromEvent(document, 'touchmove').subscribe(this._handleDragMove.bind(this)));
            this._dragSubscriptions.push(fromEvent(document, 'mousemove').subscribe(this._handleDragMove.bind(this)));
        });
        this._dragSubscriptions.push(fromEvent(document, 'touchcancel').subscribe(this._handleDragStop.bind(this)));
        this._dragSubscriptions.push(fromEvent(document, 'mouseup').subscribe(this._handleDragStop.bind(this)));
        this._dragSubscriptions.push(fromEvent(document, 'touchend').subscribe(this._handleDragStop.bind(this)));
    }
    _formatValue(value) {
        return this.valueFormatter(value);
    }
    _formatLabelLeft() {
        return this.inverted ? this._formatLabelMax() : this._formatLabelMin();
    }
    _formatLabelRight() {
        return this.inverted ? this._formatLabelMin() : this._formatLabelMax();
    }
    _formatLabelMin() {
        return this.labelMinFormatter(this.min);
    }
    _formatLabelMax() {
        return this.labelMaxFormatter(this.max);
    }
    _focusHandleElement() {
        this._handleElement.nativeElement.focus();
    }
    _updateLabelPosition() {
        const label = this._handleElement.nativeElement.querySelector('.nx-slider__value');
        if (!label) {
            return;
        }
        const handleRect = this._handleElement.nativeElement.getBoundingClientRect();
        const valueRect = label.getBoundingClientRect(label);
        const handleCenter = handleRect.left + handleRect.width / 2;
        const labelLeft = handleCenter - valueRect.width / 2;
        const labelRight = handleCenter + valueRect.width / 2;
        const bodyWidth = document.body.offsetWidth;
        let position = DEFAULT_LABEL_POSITION;
        if (labelLeft < 0) {
            position = -handleCenter + VALUE_MARGIN + 'px';
        }
        else if (labelRight > bodyWidth) {
            position = -valueRect.width + bodyWidth - handleCenter - VALUE_MARGIN + 'px';
        }
        this._labelPosition = `translateX(${position})`;
        this._cdr.markForCheck();
    }
    _getValueFromPosition(position) {
        var _a;
        const isRTL = ((_a = this._dir) === null || _a === void 0 ? void 0 : _a.value) === 'rtl';
        const rect = this.elementRef.nativeElement.getBoundingClientRect();
        const x = Math.max(rect.left, Math.min(rect.right, position));
        // position of slider relative to slider width
        let percent = (x - rect.left) / rect.width;
        if (this.inverted) {
            percent = 1 - percent;
        }
        if (isRTL) {
            percent = 1 - percent;
        }
        // edge case handling because of float precision errors you couldn't reach the maximum
        let closestValue;
        if (percent === 1) {
            closestValue = this.max;
        }
        else if (percent === 0) {
            closestValue = this.min;
        }
        else {
            const exactValue = this.min + percent * (this.max - this.min);
            closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;
        }
        if (this._decimalPlaces) {
            closestValue = this._roundToDecimal(closestValue);
        }
        return clamp(closestValue, this.min, this.max);
    }
    _roundToDecimal(value) {
        return parseFloat(value.toFixed(this._decimalPlaces));
    }
    _handleDragMove(event) {
        event.preventDefault();
        const position = this._getPositionFromEvent(event);
        const newValue = this._getValueFromPosition(position);
        if (this.value !== newValue) {
            // run change detection to update value and position of handle
            this._ngZone.run(() => {
                this.value = newValue;
                this._onChange(this.value);
                this._cdr.markForCheck();
            });
        }
    }
    _handleDragStop(event) {
        this._reset();
        const position = this._getPositionFromEvent(event);
        const newValue = this._getValueFromPosition(position);
        if (this.value !== newValue) {
            this.value = newValue;
            this._onChange(this.value);
        }
    }
    _reset() {
        for (const subscription of this._dragSubscriptions) {
            subscription.unsubscribe();
        }
        this._dragSubscriptions = [];
    }
    _getPositionFromEvent(event) {
        const cursor = event.type.includes('touch') ? event.touches.item(0) : event;
        return cursor.clientX;
    }
    getTicks(min, max, step, interval, longTick = []) {
        if (!interval) {
            return [];
        }
        const range = max - min;
        const stepProduct = step * interval;
        const gapSize = (stepProduct / range) * 100; // %
        const numberOfTicks = Math.floor(100 / gapSize);
        const spaceLeft = 100 - gapSize * numberOfTicks; // %
        const hiddenThreshold = 3; // %
        if (!longTick.length) {
            const middleValue = range / 2;
            longTick.push(middleValue);
        }
        return Array.from({ length: numberOfTicks }, (_, i) => {
            const index = i + 1;
            const value = index * stepProduct;
            return {
                gapSize,
                hideTick: index === numberOfTicks && spaceLeft <= hiddenThreshold,
                isLongTick: longTick.includes(value),
            };
        });
    }
}
NxSliderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxSliderComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.Directionality, optional: true }, { token: i2.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxSliderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxSliderComponent, selector: "nx-slider", inputs: { tickInterval: "tickInterval", id: "id", tabindex: "tabindex", min: ["nxMin", "min"], max: ["nxMax", "max"], step: ["nxStep", "step"], label: ["nxLabel", "label"], disabled: "disabled", inverted: ["nxInverted", "inverted"], thumbLabel: "thumbLabel", negative: "negative", hideLabels: "hideLabels", longTicks: "longTicks", valueFormatter: ["nxValueFormatter", "valueFormatter"], labelMinFormatter: ["nxLabelMinFormatter", "labelMinFormatter"], labelMaxFormatter: ["nxLabelMaxFormatter", "labelMaxFormatter"], value: ["nxValue", "value"] }, outputs: { valueChange: "nxValueChange" }, host: { listeners: { "keydown": "_handleKeypress($event)" }, properties: { "attr.aria-disabled": "disabled ? true : null", "class.nx-slider--disabled": "disabled", "class.nx-slider--negative": "negative" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => NxSliderComponent),
            multi: true,
        },
    ], viewQueries: [{ propertyName: "_handleElement", first: true, predicate: ["handle"], descendants: true, static: true }], ngImport: i0, template: "<label class=\"nx-slider__label\" [id]=\"id + '-label'\" [attr.for]=\"id + '-handle'\" (click)=\"_focusHandleElement()\">{{ label }}</label>\n\n<div class=\"nx-slider__wrapper\" (click)=\"_sliderClick($event)\" [class.nx-slider__has-ticks]=\"!tickInterval\">\n    <span class=\"nx-slider__background\">\n        <span class=\"nx-slider__filler\" [style.width.%]=\"_percentageValue\">\n            <div\n                class=\"nx-slider__handle\"\n                [id]=\"id + '-handle'\"\n                [attr.tabindex]=\"tabindex\"\n                [attr.aria-labelledby]=\"id + '-label'\"\n                role=\"slider\"\n                [attr.aria-valuemin]=\"_formatLabelMin()\"\n                [attr.aria-valuemax]=\"_formatLabelMax()\"\n                [attr.aria-valuetext]=\"_formatValue(value)\"\n                [attr.aria-valuenow]=\"_formatValue(value)\"\n                (mousedown)=\"_dragStart()\"\n                (touchstart)=\"_dragStart()\"\n                (selectstart)=\"_selectStart()\"\n                #handle\n            >\n                <ng-container *ngIf=\"thumbLabel\">\n                    <span [style.transform]=\"_labelPosition\" class=\"nx-slider__value\">{{ _formatValue(value) }} </span>\n                    <div class=\"nx-slider__arrow\"> </div>\n                </ng-container>\n            </div>\n        </span>\n    </span>\n    <div *ngIf=\"tickInterval\" class=\"nx-slider__tick-container\">\n        <div\n            *ngFor=\"let t of ticks\"\n            class=\"nx-slider__tick\"\n            [class.nx-slider__tick-primary]=\"t.isLongTick\"\n            [class.nx-slider__tick-hidden]=\"t.hideTick\"\n            [ngStyle]=\"{ width: t.gapSize + '%' }\"\n        ></div>\n    </div>\n</div>\n\n<div *ngIf=\"!hideLabels\" class=\"nx-slider__label-container\">\n    <span class=\"nx-slider__value-label\">{{ _formatLabelLeft() }}</span>\n    <span class=\"nx-slider__value-label\">{{ _formatLabelRight() }}</span>\n</div>\n", styles: [":host{display:block}.nx-slider__label{font-size:var(--slider-label-font-size);line-height:var(--slider-label-line-height);font-weight:var(--slider-label-font-weight);letter-spacing:var(--slider-label-letter-spacing);color:var(--slider-label-color)}.nx-slider__wrapper{width:100%;padding-top:66px;padding-left:0;padding-right:0}.nx-slider__wrapper.nx-slider__has-ticks{padding-bottom:18px}.nx-slider__background{position:relative;background-color:var(--slider-background-color);display:block;height:4px;border-radius:2px;white-space:nowrap;cursor:pointer}.nx-slider__tick-container{margin-top:9px;display:flex;border-left:1px solid var(--slider-tick-color);border-right:1px solid var(--slider-tick-color);height:9px;align-items:center;overflow:hidden}.nx-slider__tick{height:5px;display:flex;border-right:1px solid var(--slider-tick-color)}.nx-slider__tick.nx-slider__tick-primary{height:9px}.nx-slider__tick.nx-slider__tick-hidden{border:none}.nx-slider__filler{display:inline-block;height:4px;border-radius:2px;background-color:var(--slider-indicator-color);float:left;position:relative}:host-context([dir=rtl]) .nx-slider__filler{float:right}.nx-slider__handle{position:absolute;width:24px;height:24px;right:0;transform:translate(50%);border-radius:50%;box-shadow:var(--shadow-small);border-style:solid;border-width:1px;border-color:var(--slider-handle-border-color);background:var(--slider-handle-background-color);box-sizing:border-box;top:-10px;z-index:2;cursor:grab}:host-context([dir=rtl]) .nx-slider__handle{left:0;right:auto;transform:translate(-50%)}.nx-slider__handle:focus{outline:none;border-color:var(--slider-handle-focus-border-color)}.nx-slider__handle:active{box-shadow:var(--shadow-small),inset 0 0 0 4px var(--slider-handle-background-color),inset 0 0 0 24px var(--slider-handle-active-inset-color);cursor:grabbing}.nx-slider__handle.cdk-keyboard-focused{border-color:var(--slider-handle-focus-border-color);box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-slider__handle.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}.nx-slider__value{display:block;position:absolute;font-size:var(--slider-handle-value-font-size);line-height:var(--slider-handle-value-line-height);font-weight:var(--slider-handle-value-font-weight);letter-spacing:var(--slider-handle-value-letter-spacing);color:var(--slider-handle-value-color);border:1px solid;border-color:var(--slider-handle-border-color);border-radius:4px;box-shadow:var(--shadow-small);cursor:grab;height:24px;min-width:48px;text-align:center;padding:3px 8px;top:-40px;background:var(--slider-value-background-color);left:12px;transform:translate(-50%)}.nx-slider__value:active{cursor:grabbing}.nx-slider__arrow{width:6px;height:6px;border-right:1px solid;border-bottom:1px solid;left:50%;top:-22px;transform:translate(-50%,3px) rotate(45deg);position:absolute;box-shadow:-2px -2px 1px 1px var(--slider-value-background-color),2px 2px 4px var(--shadow-small-color);background:var(--slider-value-background-color);border-color:var(--slider-handle-border-color)}.nx-slider__label-container{display:flex;width:100%;justify-content:space-between;font-size:var(--slider-value-label-font-size);line-height:var(--slider-value-label-line-height);font-weight:var(--slider-value-label-font-weight);letter-spacing:var(--slider-value-label-letter-spacing);color:var(--slider-value-label-color)}.nx-slider__max-value-label{text-align:right}:host(.nx-slider--disabled){cursor:not-allowed}:host(.nx-slider--disabled) .nx-slider__filler,:host(.nx-slider--disabled) .nx-slider__value,:host(.nx-slider--disabled) .nx-slider__value-label,:host(.nx-slider--disabled) .nx-slider__handle,:host(.nx-slider--disabled) .nx-slider__background{pointer-events:none;cursor:not-allowed}:host(.nx-slider--disabled) .nx-slider__value,:host(.nx-slider--disabled) .nx-slider__handle{background-color:var(--slider-value-disabled-background-color)}:host(.nx-slider--disabled) .nx-slider__filler{background-color:var(--slider-indicator-disabled-color)}:host(.nx-slider--disabled) .nx-slider__value{color:var(--slider-handle-value-disabled-color)}:host(.nx-slider--disabled) .nx-slider__label-container{color:var(--slider-value-label-disabled-color)}:host(.nx-slider--disabled) .nx-slider__arrow{background:var(--slider-value-disabled-background-color);box-shadow:-2px -2px 1px 1px var(--slider-value-disabled-background-color),2px 2px 4px #41414180}:host(.nx-slider--disabled) .nx-slider__background{background:var(--slider-disabled-background-color)}:host(.nx-slider--negative) .nx-slider__label,:host(.nx-slider--negative) .nx-slider__value-label{color:var(--negative)}:host(.nx-slider--negative) .nx-slider__filler{background-color:var(--negative)}:host(.nx-slider--negative) .nx-slider__background{background-color:var(--slider-negative-background-color)}:host(.nx-slider--negative.nx-slider--disabled) .nx-slider__label,:host(.nx-slider--negative.nx-slider--disabled) .nx-slider__value-label{color:var(--negative-01)}:host(.nx-slider--negative.nx-slider--disabled) .nx-slider__filler{background-color:var(--negative-01)}@media screen and (-ms-high-contrast: active){.nx-slider__background{background-color:buttonFace;border:1px solid buttonText}.nx-slider__filler{background-color:highlight}.nx-slider__handle{background-color:buttonFace;border-color:buttonText}.nx-slider__handle:hover,.nx-slider__handle:focus{background-color:highlight}.nx-slider__handle:active{background-color:buttonText}.nx-slider__value{border-color:buttonText;color:buttonText}:host(.nx-slider--disabled) .nx-slider__background{background-color:Canvas;border:1px solid GrayText}:host(.nx-slider--disabled) .nx-slider__filler{background-color:GrayText}:host(.nx-slider--disabled) .nx-slider__handle{background-color:GrayText}:host(.nx-slider--disabled) .nx-slider__value{border-color:GrayText;color:GrayText}:host(.nx-slider--disabled) .nx-slider__arrow{border-color:GrayText}:host.nx-slider--negative.nx-slider--disabled .nx-slider__filler{background-color:GrayText}}\n"], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxSliderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-slider', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NxSliderComponent),
                            multi: true,
                        },
                    ], host: {
                        '[attr.aria-disabled]': 'disabled ? true : null',
                        '(keydown)': '_handleKeypress($event)',
                        '[class.nx-slider--disabled]': 'disabled',
                        '[class.nx-slider--negative]': 'negative',
                    }, template: "<label class=\"nx-slider__label\" [id]=\"id + '-label'\" [attr.for]=\"id + '-handle'\" (click)=\"_focusHandleElement()\">{{ label }}</label>\n\n<div class=\"nx-slider__wrapper\" (click)=\"_sliderClick($event)\" [class.nx-slider__has-ticks]=\"!tickInterval\">\n    <span class=\"nx-slider__background\">\n        <span class=\"nx-slider__filler\" [style.width.%]=\"_percentageValue\">\n            <div\n                class=\"nx-slider__handle\"\n                [id]=\"id + '-handle'\"\n                [attr.tabindex]=\"tabindex\"\n                [attr.aria-labelledby]=\"id + '-label'\"\n                role=\"slider\"\n                [attr.aria-valuemin]=\"_formatLabelMin()\"\n                [attr.aria-valuemax]=\"_formatLabelMax()\"\n                [attr.aria-valuetext]=\"_formatValue(value)\"\n                [attr.aria-valuenow]=\"_formatValue(value)\"\n                (mousedown)=\"_dragStart()\"\n                (touchstart)=\"_dragStart()\"\n                (selectstart)=\"_selectStart()\"\n                #handle\n            >\n                <ng-container *ngIf=\"thumbLabel\">\n                    <span [style.transform]=\"_labelPosition\" class=\"nx-slider__value\">{{ _formatValue(value) }} </span>\n                    <div class=\"nx-slider__arrow\"> </div>\n                </ng-container>\n            </div>\n        </span>\n    </span>\n    <div *ngIf=\"tickInterval\" class=\"nx-slider__tick-container\">\n        <div\n            *ngFor=\"let t of ticks\"\n            class=\"nx-slider__tick\"\n            [class.nx-slider__tick-primary]=\"t.isLongTick\"\n            [class.nx-slider__tick-hidden]=\"t.hideTick\"\n            [ngStyle]=\"{ width: t.gapSize + '%' }\"\n        ></div>\n    </div>\n</div>\n\n<div *ngIf=\"!hideLabels\" class=\"nx-slider__label-container\">\n    <span class=\"nx-slider__value-label\">{{ _formatLabelLeft() }}</span>\n    <span class=\"nx-slider__value-label\">{{ _formatLabelRight() }}</span>\n</div>\n", styles: [":host{display:block}.nx-slider__label{font-size:var(--slider-label-font-size);line-height:var(--slider-label-line-height);font-weight:var(--slider-label-font-weight);letter-spacing:var(--slider-label-letter-spacing);color:var(--slider-label-color)}.nx-slider__wrapper{width:100%;padding-top:66px;padding-left:0;padding-right:0}.nx-slider__wrapper.nx-slider__has-ticks{padding-bottom:18px}.nx-slider__background{position:relative;background-color:var(--slider-background-color);display:block;height:4px;border-radius:2px;white-space:nowrap;cursor:pointer}.nx-slider__tick-container{margin-top:9px;display:flex;border-left:1px solid var(--slider-tick-color);border-right:1px solid var(--slider-tick-color);height:9px;align-items:center;overflow:hidden}.nx-slider__tick{height:5px;display:flex;border-right:1px solid var(--slider-tick-color)}.nx-slider__tick.nx-slider__tick-primary{height:9px}.nx-slider__tick.nx-slider__tick-hidden{border:none}.nx-slider__filler{display:inline-block;height:4px;border-radius:2px;background-color:var(--slider-indicator-color);float:left;position:relative}:host-context([dir=rtl]) .nx-slider__filler{float:right}.nx-slider__handle{position:absolute;width:24px;height:24px;right:0;transform:translate(50%);border-radius:50%;box-shadow:var(--shadow-small);border-style:solid;border-width:1px;border-color:var(--slider-handle-border-color);background:var(--slider-handle-background-color);box-sizing:border-box;top:-10px;z-index:2;cursor:grab}:host-context([dir=rtl]) .nx-slider__handle{left:0;right:auto;transform:translate(-50%)}.nx-slider__handle:focus{outline:none;border-color:var(--slider-handle-focus-border-color)}.nx-slider__handle:active{box-shadow:var(--shadow-small),inset 0 0 0 4px var(--slider-handle-background-color),inset 0 0 0 24px var(--slider-handle-active-inset-color);cursor:grabbing}.nx-slider__handle.cdk-keyboard-focused{border-color:var(--slider-handle-focus-border-color);box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-slider__handle.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}.nx-slider__value{display:block;position:absolute;font-size:var(--slider-handle-value-font-size);line-height:var(--slider-handle-value-line-height);font-weight:var(--slider-handle-value-font-weight);letter-spacing:var(--slider-handle-value-letter-spacing);color:var(--slider-handle-value-color);border:1px solid;border-color:var(--slider-handle-border-color);border-radius:4px;box-shadow:var(--shadow-small);cursor:grab;height:24px;min-width:48px;text-align:center;padding:3px 8px;top:-40px;background:var(--slider-value-background-color);left:12px;transform:translate(-50%)}.nx-slider__value:active{cursor:grabbing}.nx-slider__arrow{width:6px;height:6px;border-right:1px solid;border-bottom:1px solid;left:50%;top:-22px;transform:translate(-50%,3px) rotate(45deg);position:absolute;box-shadow:-2px -2px 1px 1px var(--slider-value-background-color),2px 2px 4px var(--shadow-small-color);background:var(--slider-value-background-color);border-color:var(--slider-handle-border-color)}.nx-slider__label-container{display:flex;width:100%;justify-content:space-between;font-size:var(--slider-value-label-font-size);line-height:var(--slider-value-label-line-height);font-weight:var(--slider-value-label-font-weight);letter-spacing:var(--slider-value-label-letter-spacing);color:var(--slider-value-label-color)}.nx-slider__max-value-label{text-align:right}:host(.nx-slider--disabled){cursor:not-allowed}:host(.nx-slider--disabled) .nx-slider__filler,:host(.nx-slider--disabled) .nx-slider__value,:host(.nx-slider--disabled) .nx-slider__value-label,:host(.nx-slider--disabled) .nx-slider__handle,:host(.nx-slider--disabled) .nx-slider__background{pointer-events:none;cursor:not-allowed}:host(.nx-slider--disabled) .nx-slider__value,:host(.nx-slider--disabled) .nx-slider__handle{background-color:var(--slider-value-disabled-background-color)}:host(.nx-slider--disabled) .nx-slider__filler{background-color:var(--slider-indicator-disabled-color)}:host(.nx-slider--disabled) .nx-slider__value{color:var(--slider-handle-value-disabled-color)}:host(.nx-slider--disabled) .nx-slider__label-container{color:var(--slider-value-label-disabled-color)}:host(.nx-slider--disabled) .nx-slider__arrow{background:var(--slider-value-disabled-background-color);box-shadow:-2px -2px 1px 1px var(--slider-value-disabled-background-color),2px 2px 4px #41414180}:host(.nx-slider--disabled) .nx-slider__background{background:var(--slider-disabled-background-color)}:host(.nx-slider--negative) .nx-slider__label,:host(.nx-slider--negative) .nx-slider__value-label{color:var(--negative)}:host(.nx-slider--negative) .nx-slider__filler{background-color:var(--negative)}:host(.nx-slider--negative) .nx-slider__background{background-color:var(--slider-negative-background-color)}:host(.nx-slider--negative.nx-slider--disabled) .nx-slider__label,:host(.nx-slider--negative.nx-slider--disabled) .nx-slider__value-label{color:var(--negative-01)}:host(.nx-slider--negative.nx-slider--disabled) .nx-slider__filler{background-color:var(--negative-01)}@media screen and (-ms-high-contrast: active){.nx-slider__background{background-color:buttonFace;border:1px solid buttonText}.nx-slider__filler{background-color:highlight}.nx-slider__handle{background-color:buttonFace;border-color:buttonText}.nx-slider__handle:hover,.nx-slider__handle:focus{background-color:highlight}.nx-slider__handle:active{background-color:buttonText}.nx-slider__value{border-color:buttonText;color:buttonText}:host(.nx-slider--disabled) .nx-slider__background{background-color:Canvas;border:1px solid GrayText}:host(.nx-slider--disabled) .nx-slider__filler{background-color:GrayText}:host(.nx-slider--disabled) .nx-slider__handle{background-color:GrayText}:host(.nx-slider--disabled) .nx-slider__value{border-color:GrayText;color:GrayText}:host(.nx-slider--disabled) .nx-slider__arrow{border-color:GrayText}:host.nx-slider--negative.nx-slider--disabled .nx-slider__filler{background-color:GrayText}}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: i2.FocusMonitor }];
    }, propDecorators: { tickInterval: [{
                type: Input,
                args: ['tickInterval']
            }], _handleElement: [{
                type: ViewChild,
                args: ['handle', { static: true }]
            }], id: [{
                type: Input,
                args: ['id']
            }], tabindex: [{
                type: Input
            }], min: [{
                type: Input,
                args: ['nxMin']
            }], max: [{
                type: Input,
                args: ['nxMax']
            }], step: [{
                type: Input,
                args: ['nxStep']
            }], label: [{
                type: Input,
                args: ['nxLabel']
            }], disabled: [{
                type: Input
            }], inverted: [{
                type: Input,
                args: ['nxInverted']
            }], thumbLabel: [{
                type: Input
            }], negative: [{
                type: Input,
                args: ['negative']
            }], hideLabels: [{
                type: Input,
                args: ['hideLabels']
            }], longTicks: [{
                type: Input,
                args: ['longTicks']
            }], valueChange: [{
                type: Output,
                args: ['nxValueChange']
            }], valueFormatter: [{
                type: Input,
                args: ['nxValueFormatter']
            }], labelMinFormatter: [{
                type: Input,
                args: ['nxLabelMinFormatter']
            }], labelMaxFormatter: [{
                type: Input,
                args: ['nxLabelMaxFormatter']
            }], value: [{
                type: Input,
                args: ['nxValue']
            }] } });

class NxSliderModule {
}
NxSliderModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxSliderModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxSliderModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxSliderModule, declarations: [NxSliderComponent], imports: [CommonModule], exports: [NxSliderComponent] });
NxSliderModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxSliderModule, imports: [[CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxSliderModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule],
                    declarations: [NxSliderComponent],
                    exports: [NxSliderComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NxSliderComponent, NxSliderModule };
//# sourceMappingURL=aposin-ng-aquila-slider.mjs.map
