import * as i0 from '@angular/core';
import { Directive, Component, ContentChild, Input, Optional, ViewEncapsulation, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';
import { __rest } from 'tslib';
import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, merge, Subject } from 'rxjs';
import { take, map, takeUntil } from 'rxjs/operators';
import * as i1 from '@angular/cdk/tree';
import { FlatTreeControl, CdkTreeNode, CdkTreeNodeDef, CdkTreeNodeToggle, CdkTree, CdkTreeModule } from '@angular/cdk/tree';
import * as i2 from '@angular/cdk/a11y';
import { coerceNumberProperty, coerceBooleanProperty } from '@angular/cdk/coercion';
import * as i2$1 from '@angular/cdk/bidi';
import { NUMPAD_MULTIPLY, RIGHT_ARROW, LEFT_ARROW, DOWN_ARROW, UP_ARROW, END, HOME } from '@angular/cdk/keycodes';
import { CommonModule } from '@angular/common';

class NxTreeNodeActionItem {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
    }
    focus() {
        this._elementRef.nativeElement.focus();
    }
}
NxTreeNodeActionItem.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeActionItem, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NxTreeNodeActionItem.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTreeNodeActionItem, selector: "[nxTreeNodeActionItem]", host: { properties: { "attr.tabindex": "-1" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeActionItem, decorators: [{
            type: Directive,
            args: [{ selector: '[nxTreeNodeActionItem]', host: { '[attr.tabindex]': '-1' } }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; } });

/**
 * Tree flattener to convert a normal type of node to node with children & level information.
 * Transform nested nodes of type `T extends NxTreeNode` to flattened nodes of type `F extends NxFlatTreeNode`.
 *
 * For example, the input data of type `T` is nested, and contains its children data:
 *   SomeNode: {
 *     key: 'Fruits',
 *     children: [
 *       NodeOne: {
 *         key: 'Apple',
 *       },
 *       NodeTwo: {
 *        key: 'Pear',
 *      }
 *    ]
 *  }
 *  After flattener flatten the tree, the structure will become
 *  SomeNode: {
 *    key: 'Fruits',
 *    expandable: true,
 *    level: 1
 *  },
 *  NodeOne: {
 *    key: 'Apple',
 *    expandable: false,
 *    level: 2
 *  },
 *  NodeTwo: {
 *   key: 'Pear',
 *   expandable: false,
 *   level: 2
 * }
 * and the output flattened type is `F extends NxFlatTreeNode` with additional information.
 */
class NxTreeFlattener {
    transformFunction(node, level) {
        const { children } = node, rest = __rest(node, ["children"]);
        return Object.assign(Object.assign({}, rest), { level, expandable: Array.isArray(children) && children.length > 0 });
    }
    getLevel(node) {
        return node.level;
    }
    isExpandable(node) {
        return node.expandable;
    }
    getChildren(node) {
        return node.children;
    }
    _flattenNode(node, level, resultNodes, parentMap) {
        const flatNode = this.transformFunction(node, level);
        resultNodes.push(flatNode);
        if (this.isExpandable(flatNode)) {
            const childrenNodes = this.getChildren(node);
            if (Array.isArray(childrenNodes)) {
                this._flattenChildren(childrenNodes, level, resultNodes, parentMap);
            }
            else {
                childrenNodes.pipe(take(1)).subscribe(children => {
                    this._flattenChildren(children, level, resultNodes, parentMap);
                });
            }
        }
        return resultNodes;
    }
    _flattenChildren(children, level, resultNodes, parentMap) {
        children.forEach((child, index) => {
            const childParentMap = parentMap.slice();
            childParentMap.push(index !== children.length - 1);
            this._flattenNode(child, level + 1, resultNodes, childParentMap);
        });
    }
    /**
     * Flatten a list of node type T to flattened version of node F.
     * Please note that type T may be nested, and the length of `structuredData` may be different
     * from that of returned list `F[]`.
     */
    flattenNodes(structuredData) {
        const resultNodes = [];
        structuredData.forEach(node => this._flattenNode(node, 0, resultNodes, []));
        return resultNodes;
    }
    /**
     * Expand flattened node with current expansion status.
     * The returned list may have different length.
     */
    expandFlattenedNodes(nodes, treeControl) {
        const results = [];
        const currentExpand = [];
        currentExpand[0] = true;
        nodes.forEach(node => {
            let expand = true;
            for (let i = 0; i <= this.getLevel(node); i++) {
                expand = expand && currentExpand[i];
            }
            if (expand) {
                results.push(node);
            }
            if (this.isExpandable(node)) {
                currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);
            }
        });
        return results;
    }
}
/**
 * Data source for flat tree.
 * The data source need to handle expansion/collapsion of the tree node and change the data feed
 * to `NxTree`.
 * The nested tree nodes of type `T extends NxTreeNode` are flattened through `NxTreeFlattener`, and converted
 * to type `F extends NxFlatTreeNode` for `NxTree` to consume.
 */
class NxTreeFlatDataSource extends DataSource {
    constructor(treeControl, initialData = []) {
        super();
        this.treeControl = treeControl;
        this._flattenedData = new BehaviorSubject([]);
        this._expandedData = new BehaviorSubject([]);
        this._data = new BehaviorSubject([]);
        this._treeFlattener = new NxTreeFlattener();
        this.data = initialData;
    }
    get data() {
        return this._data.value;
    }
    set data(value) {
        this._data.next(value);
        this._flattenedData.next(this._treeFlattener.flattenNodes(this.data));
        this.treeControl.dataNodes = this._flattenedData.value;
    }
    connect(collectionViewer) {
        const changes = [collectionViewer.viewChange, this.treeControl.expansionModel.changed, this._flattenedData];
        return merge(...changes).pipe(map(() => {
            this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this.treeControl));
            return this._expandedData.value;
        }));
    }
    disconnect() {
        // no op
    }
}

/** Flat tree control.
  Able to expand/collapse a subtree recursively for flattened tree.
*/
class NxFlatTreeControl extends FlatTreeControl {
    constructor() {
        super(node => node.level, node => node.expandable);
    }
}

/**
 * Wrapper for the CdkTree node with custom design styles.
 */
class NxTreeNodeComponent extends CdkTreeNode {
    constructor(_elementRef, _tree, _focusMonitor) {
        super(_elementRef, _tree);
        this._elementRef = _elementRef;
        this._tree = _tree;
        this._focusMonitor = _focusMonitor;
        this._focusMonitor.monitor(this._elementRef.nativeElement);
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef.nativeElement);
        super.ngOnDestroy();
    }
    /** Update the focused data in tree keyboard interaction */
    _focus() {
        this._tree.updateFocusedData(this._data);
    }
    focus() {
        var _a, _b;
        if (this.actionItem) {
            (_b = (_a = this.actionItem).focus) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        else {
            this._elementRef.nativeElement.focus();
        }
    }
}
NxTreeNodeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeComponent, deps: [{ token: i0.ElementRef }, { token: i1.CdkTree }, { token: i2.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxTreeNodeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTreeNodeComponent, selector: "nx-tree-node", inputs: { disabled: "disabled", tabIndex: "tabIndex" }, host: { properties: { "attr.aria-expanded": "isExpanded", "attr.aria-level": "role === \"treeitem\" ? level : null", "attr.role": "role", "class.is-expanded": "isExpanded", "attr.tabindex": "-1" }, classAttribute: "nx-tree__node" }, providers: [{ provide: CdkTreeNode, useExisting: NxTreeNodeComponent }], queries: [{ propertyName: "actionItem", first: true, predicate: NxTreeNodeActionItem, descendants: true }], exportAs: ["nxTreeNode"], usesInheritance: true, ngImport: i0, template: "<div class=\"nx-tree__node-box\">\n    <ng-content></ng-content>\n</div>\n" });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tree-node', exportAs: 'nxTreeNode', inputs: ['disabled', 'tabIndex'], host: {
                        '[attr.aria-expanded]': 'isExpanded',
                        '[attr.aria-level]': 'role === "treeitem" ? level : null',
                        '[attr.role]': 'role',
                        class: 'nx-tree__node',
                        '[class.is-expanded]': 'isExpanded',
                        '[attr.tabindex]': '-1',
                    }, providers: [{ provide: CdkTreeNode, useExisting: NxTreeNodeComponent }], template: "<div class=\"nx-tree__node-box\">\n    <ng-content></ng-content>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.CdkTree }, { type: i2.FocusMonitor }]; }, propDecorators: { actionItem: [{
                type: ContentChild,
                args: [NxTreeNodeActionItem]
            }] } });
/**
 * Wrapper for the CdkTree node definition with custom design styles.
 */
class NxTreeNodeDefDirective extends CdkTreeNodeDef {
}
NxTreeNodeDefDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeDefDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NxTreeNodeDefDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTreeNodeDefDirective, selector: "[nxTreeNodeDef]", inputs: { when: ["nxTreeNodeDefWhen", "when"], data: ["nxTreeNode", "data"] }, providers: [{ provide: CdkTreeNodeDef, useExisting: NxTreeNodeDefDirective }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeDefDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxTreeNodeDef]',
                    inputs: ['when: nxTreeNodeDefWhen'],
                    providers: [{ provide: CdkTreeNodeDef, useExisting: NxTreeNodeDefDirective }],
                }]
        }], propDecorators: { data: [{
                type: Input,
                args: ['nxTreeNode']
            }] } });

/**
 * Outlet for nested CdkNode. Put `[nxTreeNodeOutlet]` on a tag to place children dataNodes
 * inside the outlet.
 */
class NxTreeNodeOutletDirective {
    constructor(viewContainer) {
        this.viewContainer = viewContainer;
    }
}
NxTreeNodeOutletDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeOutletDirective, deps: [{ token: i0.ViewContainerRef }], target: i0.ɵɵFactoryTarget.Directive });
NxTreeNodeOutletDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTreeNodeOutletDirective, selector: "[nxTreeNodeOutlet]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeOutletDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxTreeNodeOutlet]',
                }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }]; } });

/** Regex used to split a string on its CSS units. */
const cssUnitPattern = /([%A-Za-z]+)$/;
/**
 * Indent for the children tree dataNodes.
 * This directive will add left-padding to the node to show hierarchy.
 */
class NxTreeNodePaddingDirective {
    constructor(_treeNode, _tree, _renderer, _element, _dir) {
        this._treeNode = _treeNode;
        this._tree = _tree;
        this._renderer = _renderer;
        this._element = _element;
        this._dir = _dir;
        /** CSS units used for the indentation value. */
        this.indentUnits = 'px';
        this._offset = 0;
        this._indent = 24;
        this._destroyed = new Subject();
        this._setPadding();
        if (this._dir) {
            this._dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding(true));
        }
        // In Ivy the indentation binding might be set before the tree node's data has been added,
        // which means that we'll miss the first render. We have to subscribe to changes in the
        // data to ensure that everything is up to date.
        _treeNode._dataChanges.pipe(takeUntil(this._destroyed)).subscribe(() => this._setPadding());
    }
    /** The level of depth of the tree node. The padding will be `level * indent` pixels. */
    get level() {
        return this._level;
    }
    set level(value) {
        this._level = coerceNumberProperty(value);
        this._setPadding();
    }
    /** The offset is added once on top of each indent. Default number is 0. */
    get offset() {
        return this._offset;
    }
    set offset(value) {
        this._offset = coerceNumberProperty(value);
        this._setPadding();
    }
    /**
     * The indent for each level. Can be a number or a CSS string.
     * Default number 24px from material design menu sub-menu spec.
     */
    get indent() {
        return this._indent;
    }
    set indent(indent) {
        let value = indent;
        let units = 'px';
        if (typeof indent === 'string') {
            const parts = indent.split(cssUnitPattern);
            value = parts[0];
            units = parts[1] || units;
        }
        this.indentUnits = units;
        this._indent = coerceNumberProperty(value);
        this._setPadding();
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /** The padding indent value for the tree node. Returns a string with px numbers if not null. */
    _paddingIndent() {
        const nodeLevel = this._treeNode.data && this._tree.treeControl.getLevel ? this._tree.treeControl.getLevel(this._treeNode.data) : null;
        const level = this._level || nodeLevel;
        return level ? `${level * this._indent + this._offset}${this.indentUnits}` : null;
    }
    _setPadding(forceChange = false) {
        const padding = this._paddingIndent();
        if (padding !== this._currentPadding || forceChange) {
            const element = this._element.nativeElement;
            const paddingProp = this._dir && this._dir.value === 'rtl' ? 'paddingRight' : 'paddingLeft';
            const resetProp = paddingProp === 'paddingLeft' ? 'paddingRight' : 'paddingLeft';
            this._renderer.setStyle(element, paddingProp, padding);
            this._renderer.setStyle(element, resetProp, null);
            this._currentPadding = padding;
        }
    }
}
NxTreeNodePaddingDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodePaddingDirective, deps: [{ token: i1.CdkTreeNode }, { token: i1.CdkTree }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i2$1.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Directive });
NxTreeNodePaddingDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTreeNodePaddingDirective, selector: "[nxTreeNodePadding]", inputs: { level: ["nxTreeNodePadding", "level"], offset: ["nxTreeNodePaddingOffset", "offset"], indent: ["nxTreeNodePaddingIndent", "indent"] }, host: { properties: { "class.nx-tree-node--with-padding": "true" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodePaddingDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxTreeNodePadding]',
                    host: {
                        '[class.nx-tree-node--with-padding]': 'true',
                    },
                }]
        }], ctorParameters: function () {
        return [{ type: i1.CdkTreeNode }, { type: i1.CdkTree }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i2$1.Directionality, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { level: [{
                type: Input,
                args: ['nxTreeNodePadding']
            }], offset: [{
                type: Input,
                args: ['nxTreeNodePaddingOffset']
            }], indent: [{
                type: Input,
                args: ['nxTreeNodePaddingIndent']
            }] } });

/**
 * Wrapper for the CdkTree's toggle with custom design styles.
 */
class NxTreeNodeToggleDirective extends CdkTreeNodeToggle {
    set recursive(value) {
        this._recursive = coerceBooleanProperty(value);
    }
    get recursive() {
        return this._recursive;
    }
}
NxTreeNodeToggleDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeToggleDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NxTreeNodeToggleDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTreeNodeToggleDirective, selector: "[nxTreeNodeToggle]", inputs: { recursive: ["nxTreeNodeToggleRecursive", "recursive"] }, providers: [{ provide: CdkTreeNodeToggle, useExisting: NxTreeNodeToggleDirective }], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeNodeToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxTreeNodeToggle]',
                    providers: [{ provide: CdkTreeNodeToggle, useExisting: NxTreeNodeToggleDirective }],
                }]
        }], propDecorators: { recursive: [{
                type: Input,
                args: ['nxTreeNodeToggleRecursive']
            }] } });

/**
 * Wrapper for the CdkTree with custom design styles and keyboard nav mechanics.
 */
class NxTreeComponent extends CdkTree {
    constructor(_wrapperDiffers, _cdr, dir, _elementRef, _focusMonitor) {
        super(_wrapperDiffers, _cdr);
        this._wrapperDiffers = _wrapperDiffers;
        this._cdr = _cdr;
        this.dir = dir;
        this._elementRef = _elementRef;
        this._focusMonitor = _focusMonitor;
        /** The node map map data nodes to CdkTreeNodes */
        this.nodeMap = new Map();
        /** A map from parent node to a list of children. */
        this.childrenMap = new Map();
        /** A map from node data to its parent node data. */
        this.parentMap = new Map();
        /** Tab index for the tree. */
        this._tabIndex = 0;
        /**
         * User defined tab index.
         * When it is not null, use user defined tab index. Otherwise use _tabIndex
         */
        this._userTabIndex = null;
        /** Subject that emits when the component has been destroyed. */
        this._wrapperOnDestroy = new Subject();
    }
    set tabIndex(value) {
        this._userTabIndex = value;
    }
    ngOnInit() {
        super.ngOnInit();
        this._monitorTreeFocus();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._wrapperOnDestroy.next();
        this._wrapperOnDestroy.complete();
    }
    /** Get current focused data */
    get focusedData() {
        return this._focusedData;
    }
    /** Add tree node to data list based on owner of parent view container. */
    insertToA11yNodeTracking(index, data, node, parentData) {
        this.nodeMap.set(data, node);
        if (parentData) {
            this.parentMap.set(data, parentData);
        }
        this._getChildrenList(parentData).splice(index, 0, data);
    }
    /** Remove a node data from node list based on the owner of view container. */
    removeFromA11yNodeTracking(index, parentData) {
        const nodeList = this._getChildrenList(parentData);
        const removed = nodeList.splice(index, 1)[0];
        if (removed && removed === this._focusedData) {
            this._changeFocusedData(this._getNextVisibleNode());
        }
        this.nodeMap.delete(removed);
        this.parentMap.delete(removed);
        this.childrenMap.delete(removed);
    }
    /** Update node's index information based on the owner of view container. */
    moveInA11yNodeTracking(previousIndex, currentIndex, parentData) {
        const nodeList = this._getChildrenList(parentData);
        const target = nodeList.splice(previousIndex, 1);
        nodeList.splice(currentIndex, 0, target[0]);
    }
    /** When a tree node is focused, update the current focused data. */
    updateFocusedData(newFocusedData) {
        this._focusedData = newFocusedData;
    }
    /** Focus first node when the tree is focused */
    focus() {
        this._focusedData ? this._changeFocusedData(this._focusedData) : this.focusFirstVisibleNode();
    }
    /** Change focus to first visible node in the tree. */
    focusFirstVisibleNode() {
        this._changeFocusedData(this._getFirstVisibleNode());
    }
    /** Change focus to last visible node in the tree. */
    focusLastVisibleNode() {
        this._changeFocusedData(this._getLastVisibleNode());
    }
    /** Change focus to previous visible node. */
    focusPreviousVisibleNode() {
        if (!this._focusedData) {
            return this.focusLastVisibleNode();
        }
        this._changeFocusedData(this._getPreviousVisibleNode());
    }
    /** Change focus to next visible node. */
    focusNextVisibleNode() {
        if (!this._focusedData) {
            return this.focusFirstVisibleNode();
        }
        this._changeFocusedData(this._getNextVisibleNode());
    }
    /** Collapse the current node if it's expanded. Otherwise move to parent. */
    collapseCurrentFocusedNode() {
        if (this._focusedData && this.treeControl) {
            if (this.treeControl.isExpanded(this._focusedData)) {
                this.treeControl.collapse(this._focusedData);
            }
            else {
                this._changeFocusedData(this._getParentNode());
            }
        }
    }
    /** Expand the current node if it's not expanded. Otherwise move to its first child. */
    expandCurrentFocusedNode() {
        if (this._focusedData && this.treeControl) {
            if (this.treeControl.isExpanded(this._focusedData)) {
                this._changeFocusedData(this._getNextVisibleNode());
            }
            else {
                this.treeControl.expand(this._focusedData);
            }
        }
    }
    /** Expand all the nodes in the tree */
    expandAllNodes() {
        if (this.treeControl) {
            this.treeControl.expandAll();
        }
    }
    /** Expand the current node if it's not expanded. Otherwise move to its first child. */
    toggleCurrentFocusedNode() {
        if (this._focusedData && this.treeControl) {
            this.treeControl.toggle(this._focusedData);
        }
    }
    _isRtl() {
        return this.dir && this.dir.value === 'rtl';
    }
    /**
     * Pass events to the keyboard manager. Available here for tests.
     */
    _handleKeydown(event) {
        switch (event.keyCode) {
            case HOME:
                this.focusFirstVisibleNode();
                event.preventDefault();
                break;
            case END:
                this.focusLastVisibleNode();
                event.preventDefault();
                break;
            case UP_ARROW:
                this.focusPreviousVisibleNode();
                event.preventDefault();
                break;
            case DOWN_ARROW:
                this.focusNextVisibleNode();
                event.preventDefault();
                break;
            case LEFT_ARROW:
                this._isRtl() ? this.expandCurrentFocusedNode() : this.collapseCurrentFocusedNode();
                event.preventDefault();
                break;
            case RIGHT_ARROW:
                this._isRtl() ? this.collapseCurrentFocusedNode() : this.expandCurrentFocusedNode();
                event.preventDefault();
                break;
            case NUMPAD_MULTIPLY:
                this.expandAllNodes();
                event.preventDefault();
                break;
            default:
        }
    }
    /** Focus the tree node component with new focused data. */
    _changeFocusedData(newFocused) {
        if (newFocused) {
            this._focusedData = newFocused;
            if (this.nodeMap.has(this._focusedData)) {
                this.nodeMap.get(this._focusedData).focus();
            }
        }
    }
    /** Returns the data of the first visible tree node in the tree. */
    _getFirstVisibleNode() {
        const nodeList = this._getChildrenList();
        return nodeList[0];
    }
    /** Returns the data of the last visible tree node in the tree. */
    _getLastVisibleNode() {
        const nodeList = this._getChildrenList();
        return this._getLastChild(nodeList[nodeList.length - 1]);
    }
    /** Returns the previous visible tree node of current focused data. */
    _getPreviousVisibleNode() {
        if (!this._focusedData) {
            return;
        }
        const parent = this.parentMap.get(this._focusedData);
        const nodeList = this.childrenMap.get(parent);
        const index = nodeList.indexOf(this._focusedData);
        if (index === 0) {
            return parent;
        }
        else if (index > 0) {
            return this._getLastChild(nodeList[index - 1]);
        }
        return undefined;
    }
    /** Returns the next visible tree node data of current focused data. */
    _getNextVisibleNode() {
        if (!this._focusedData) {
            return;
        }
        // Always return first child if the node is expanded
        if (this.childrenMap.has(this._focusedData) && this.treeControl && this.treeControl.isExpanded(this._focusedData)) {
            const childNodeList = this._getChildrenList(this._focusedData);
            if (childNodeList.length) {
                return childNodeList[0];
            }
        }
        // Or return next sibling / parent's next child if any
        let currentData = this._focusedData;
        while (currentData) {
            const parent = this.parentMap.get(currentData);
            const nodeList = this.childrenMap.get(parent);
            const index = nodeList.indexOf(currentData);
            if (index === nodeList.length - 1) {
                currentData = parent;
            }
            else if (index > -1) {
                return nodeList[index + 1];
            }
        }
        return undefined;
    }
    /** Returns the parent of current focused node. */
    _getParentNode() {
        if (this.parentMap.has(this._focusedData)) {
            // For nested tree
            this._changeFocusedData(this.parentMap.get(this._focusedData));
        }
        else if (this.treeControl.getLevel) {
            // For flat tree
            const nodeList = this._getChildrenList();
            const index = nodeList.indexOf(this._focusedData);
            const level = this.treeControl.getLevel(this._focusedData) - 1;
            if (index <= 0) {
                return;
            }
            for (let i = index - 1; i >= 0; i--) {
                if (this.treeControl.getLevel(nodeList[i]) === level) {
                    return nodeList[i];
                }
            }
        }
        return undefined;
    }
    /**
     * Returns the data of list of children in the current `parentData` node's view container.
     * If there's no parent, return the tree nodes in the tree's view container.
     */
    _getChildrenList(parentData) {
        if (!this.childrenMap.has(parentData)) {
            this.childrenMap.set(parentData, []);
        }
        return this.childrenMap.get(parentData);
    }
    /**
     * Returns the data of last visible elements in the sub-tree rooted at `targetNode`.
     */
    _getLastChild(targetNode) {
        let currentData = targetNode;
        while (currentData && this.childrenMap.has(currentData) && this.treeControl && this.treeControl.isExpanded(currentData)) {
            const childNodeList = this._getChildrenList(currentData);
            if (childNodeList.length) {
                currentData = childNodeList[childNodeList.length - 1];
            }
            else {
                break;
            }
        }
        return currentData;
    }
    /**
     * Extended CdkTree method to track new nodes for a11y.
     */
    insertNode(nodeData, index, viewContainer, parentData) {
        super.insertNode(nodeData, index, viewContainer, parentData);
        if (CdkTreeNode.mostRecentTreeNode) {
            this.insertToA11yNodeTracking(index, nodeData, CdkTreeNode.mostRecentTreeNode, parentData);
            CdkTreeNode.mostRecentTreeNode.focus();
        }
    }
    /**
     * ⚠️  Here we override the method from cdk tree ⚠️
     * Adds some extra method calls to update the a11y node tracking.
     */
    renderNodeChanges(data, dataDiffer = this['_dataDiffer'], viewContainer = this._nodeOutlet.viewContainer, parentData) {
        super.renderNodeChanges(data, dataDiffer, viewContainer, parentData);
        const changes = dataDiffer.diff(data);
        if (!changes) {
            return;
        }
        changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
            if (currentIndex == null) {
                this.removeFromA11yNodeTracking(adjustedPreviousIndex, parentData);
            }
            else if (item.previousIndex !== null) {
                this.moveInA11yNodeTracking(adjustedPreviousIndex, currentIndex, parentData);
            }
        });
    }
    /**
     * Monitor focus of the tree. When the tree is focused, change the tab index to -1 so TAB
     * can move the focus out of the tree. When the tree is blurred, change back the tab index.
     */
    _monitorTreeFocus() {
        this._focusMonitor
            .monitor(this._elementRef.nativeElement, true)
            .pipe(takeUntil(this._wrapperOnDestroy))
            .subscribe(origin => {
            const newTabIndex = origin ? -1 : this._userTabIndex || 0;
            if (this._tabIndex !== newTabIndex) {
                this._tabIndex = newTabIndex;
                this._cdr.markForCheck();
            }
        });
    }
}
NxTreeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeComponent, deps: [{ token: i0.IterableDiffers }, { token: i0.ChangeDetectorRef }, { token: i2$1.Directionality, optional: true }, { token: i0.ElementRef }, { token: i2.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxTreeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTreeComponent, selector: "nx-tree", inputs: { tabIndex: "tabIndex" }, host: { attributes: { "role": "application" }, listeners: { "keydown": "_handleKeydown($event)", "focus": "focus()" }, properties: { "attr.tabindex": "_tabIndex" }, classAttribute: "nx-tree cdk-tree" }, providers: [{ provide: CdkTree, useExisting: NxTreeComponent }], viewQueries: [{ propertyName: "_nodeOutlet", first: true, predicate: NxTreeNodeOutletDirective, descendants: true, static: true }], exportAs: ["nxTree"], usesInheritance: true, ngImport: i0, template: `<ng-container nxTreeNodeOutlet></ng-container>`, isInline: true, styles: [":host.nx-tree{display:block}.nx-tree__node{display:block;overflow:hidden}.nx-tree__node.cdk-keyboard-focused{box-shadow:var(--focus-inset-box-shadow);border-radius:8px}@media screen and (-ms-high-contrast: active){.nx-tree__node.cdk-keyboard-focused{box-shadow:inset 0 0 0 4px windowText,inset 0 0 0 6px background;border:4px solid CanvasText}}\n"], directives: [{ type: NxTreeNodeOutletDirective, selector: "[nxTreeNodeOutlet]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tree', exportAs: 'nxTree', template: `<ng-container nxTreeNodeOutlet></ng-container>`, host: {
                        // The 'cdk-tree' class needs to be included here because classes set in the host in the
                        // parent class are not inherited with View Engine. The 'cdk-tree' class in CdkTreeNode has
                        // to be set in the host because:
                        // if it is set as a @HostBinding it is not set by the time the tree nodes try to read the
                        // class from it.
                        // the ElementRef is not available in the constructor so the class can't be applied directly
                        // without a breaking constructor change.
                        class: 'nx-tree cdk-tree',
                        role: 'application',
                        '[attr.tabindex]': '_tabIndex',
                        '(keydown)': '_handleKeydown($event)',
                        '(focus)': 'focus()',
                    }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, providers: [{ provide: CdkTree, useExisting: NxTreeComponent }], styles: [":host.nx-tree{display:block}.nx-tree__node{display:block;overflow:hidden}.nx-tree__node.cdk-keyboard-focused{box-shadow:var(--focus-inset-box-shadow);border-radius:8px}@media screen and (-ms-high-contrast: active){.nx-tree__node.cdk-keyboard-focused{box-shadow:inset 0 0 0 4px windowText,inset 0 0 0 6px background;border:4px solid CanvasText}}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }, { type: i2$1.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: i0.ElementRef }, { type: i2.FocusMonitor }];
    }, propDecorators: { _nodeOutlet: [{
                type: ViewChild,
                args: [NxTreeNodeOutletDirective, { static: true }]
            }], tabIndex: [{
                type: Input
            }] } });

class NxTreeModule {
}
NxTreeModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxTreeModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeModule, declarations: [NxTreeComponent,
        NxTreeNodeComponent,
        NxTreeNodeDefDirective,
        NxTreeNodePaddingDirective,
        NxTreeNodeToggleDirective,
        NxTreeNodeOutletDirective,
        NxTreeNodeActionItem], imports: [CdkTreeModule, CommonModule], exports: [NxTreeComponent,
        NxTreeNodeComponent,
        NxTreeNodeDefDirective,
        NxTreeNodePaddingDirective,
        NxTreeNodeToggleDirective,
        NxTreeNodeOutletDirective,
        NxTreeNodeActionItem] });
NxTreeModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeModule, imports: [[CdkTreeModule, CommonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CdkTreeModule, CommonModule],
                    declarations: [
                        NxTreeComponent,
                        NxTreeNodeComponent,
                        NxTreeNodeDefDirective,
                        NxTreeNodePaddingDirective,
                        NxTreeNodeToggleDirective,
                        NxTreeNodeOutletDirective,
                        NxTreeNodeActionItem,
                    ],
                    exports: [
                        NxTreeComponent,
                        NxTreeNodeComponent,
                        NxTreeNodeDefDirective,
                        NxTreeNodePaddingDirective,
                        NxTreeNodeToggleDirective,
                        NxTreeNodeOutletDirective,
                        NxTreeNodeActionItem,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NxFlatTreeControl, NxTreeComponent, NxTreeFlatDataSource, NxTreeModule, NxTreeNodeActionItem, NxTreeNodeComponent, NxTreeNodeDefDirective, NxTreeNodeOutletDirective, NxTreeNodePaddingDirective, NxTreeNodeToggleDirective };
//# sourceMappingURL=aposin-ng-aquila-tree.mjs.map
