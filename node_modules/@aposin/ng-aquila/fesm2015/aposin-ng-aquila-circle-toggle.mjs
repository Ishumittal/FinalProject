import * as i2 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, Input, InjectionToken, EventEmitter, Optional, Inject, Self, HostBinding, ContentChildren, Output, forwardRef, ViewChild, HostListener, NgModule } from '@angular/core';
import * as i1 from '@aposin/ng-aquila/icon';
import { NxIconModule } from '@aposin/ng-aquila/icon';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { __awaiter } from 'tslib';
import { Subject, merge } from 'rxjs';
import { startWith, filter, tap, takeUntil } from 'rxjs/operators';
import * as i1$1 from '@aposin/ng-aquila/utils';
import * as i2$1 from '@angular/forms';
import * as i2$2 from '@angular/cdk/collections';
import * as i3 from '@angular/cdk/a11y';

/** @docs-private */
class NxMobileToggleButtonComponent {
    constructor(_cdr) {
        this._cdr = _cdr;
        this.checked = false;
        this.negative = false;
        this.disabled = false;
        this.hint = '';
        this.label = '';
        this.circleText = '';
        /** @docs-private */
        this.isFirst = false;
        /** @docs-private */
        this.isLast = false;
    }
    /** @docs-private */
    setFirstButton() {
        this.isFirst = true;
        this._cdr.markForCheck();
    }
    /** @docs-private */
    setLastButton() {
        this.isLast = true;
        this._cdr.markForCheck();
    }
    /** @docs-private */
    resetClasses() {
        this.isFirst = false;
        this.isLast = false;
        this._cdr.markForCheck();
    }
}
NxMobileToggleButtonComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMobileToggleButtonComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
NxMobileToggleButtonComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxMobileToggleButtonComponent, selector: "nx-mobile-toggle-button", inputs: { checked: "checked", negative: "negative", disabled: "disabled", hint: "hint", label: "label", circleText: "circleText" }, host: { properties: { "class.is-disabled": "disabled", "class.is-negative": "negative", "class.is-first": "isFirst", "class.is-last": "isLast", "class.is-flipped": "checked" } }, ngImport: i0, template: "<nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n<!-- If there is no label defined, use the circleText instead -->\n<span class=\"nx-toggle-button__label-text\"><ng-template *ngIf=\"label; then labelContent; else circleTextContent\"></ng-template></span>\n<span *ngIf=\"hint\" class=\"nx-toggle-button__label-hint\">({{ hint }})</span>\n\n<ng-template #labelContent>{{ label }}</ng-template>\n<ng-template #circleTextContent>{{ circleText }}</ng-template>\n", styles: [":host{display:none;position:relative;transition:background-color .2s ease,border-color .2s ease,color .2s ease;flex-direction:row;border-width:1px 2px;border-color:var(--circle-toggle-border-color);border-style:solid;padding:11px 31px;width:100%;justify-content:center;align-items:center;cursor:pointer}:host:not(.is-flipped):not(.is-disabled):hover{background-color:var(--circle-toggle-hover-background-color);border-color:var(--circle-toggle-hover-border-color)}:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:var(--circle-toggle-hover-icon-color)}@media (max-width: 703px){:host-context(.is-responsive){display:flex}}.nx-toggle-button__label-hint{color:var(--circle-toggle-icon-color);font-size:var(--circle-toggle-hint-mobile-font-size);line-height:var(--circle-toggle-hint-mobile-line-height);font-weight:var(--circle-toggle-hint-mobile-font-weight);letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing)}.nx-toggle-button__label-text{color:var(--circle-toggle-icon-color);font-size:var(--circle-toggle-label-mobile-font-size);line-height:var(--circle-toggle-label-mobile-line-height);font-weight:var(--circle-toggle-label-mobile-font-weight);letter-spacing:var(--circle-toggle-label-mobile-letter-spacing);padding-top:0;padding-right:4px;font-weight:600}:host-context([dir=rtl]) .nx-toggle-button__label-text{padding-right:0;padding-right:initial;padding-left:4px}.nx-toggle-button__mobile-check{font-size:24px;height:24px;display:inline-block;opacity:0;margin-right:8px;color:var(--circle-toggle-checkmark-color)}:host-context([dir=rtl]) .nx-toggle-button__mobile-check{margin-right:0;margin-right:initial;margin-left:8px}:host(.is-first){border-top-width:2px;border-radius:4px 4px 0 0}:host(.is-last){border-bottom-width:2px;border-radius:0 0 4px 4px}:host(.is-flipped){background-color:var(--circle-toggle-selected-background-color)}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text{color:var(--circle-toggle-selected-icon-color)}:host(.is-flipped) .nx-toggle-button__mobile-check{opacity:1}:host(.is-negative){border-color:var(--negative)}:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:var(--negative)}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover{background-color:var(--negative-01);border-color:var(--negative-01)}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:var(--negative-accent)}:host(.is-negative.is-flipped){background-color:var(--negative)}:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:var(--negative-accent)}:host(.is-disabled){opacity:.4;cursor:not-allowed}@media screen and (-ms-high-contrast: active){:host{forced-color-adjust:none;background-color:buttonFace!important;border-color:buttonText!important;color:buttonText!important}:host .nx-toggle-button__label-text,:host .nx-toggle-button__label-hint{color:buttonText!important}:host.is-flipped{background-color:highlight!important;color:highlightText!important}:host.is-flipped .nx-toggle-button__label-text,:host.is-flipped .nx-toggle-button__label-hint{color:highlightText!important}:host.is-disabled{opacity:1;border-color:GrayText!important;color:GrayText!important;background-color:buttonFace!important}:host.is-disabled .nx-toggle-button__label-text,:host.is-disabled .nx-toggle-button__label-hint{color:GrayText!important}}\n"], components: [{ type: i1.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMobileToggleButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-mobile-toggle-button', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class.is-disabled]': 'disabled',
                        '[class.is-negative]': 'negative',
                        '[class.is-first]': 'isFirst',
                        '[class.is-last]': 'isLast',
                        '[class.is-flipped]': 'checked',
                    }, template: "<nx-icon class=\"nx-toggle-button__mobile-check\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n<!-- If there is no label defined, use the circleText instead -->\n<span class=\"nx-toggle-button__label-text\"><ng-template *ngIf=\"label; then labelContent; else circleTextContent\"></ng-template></span>\n<span *ngIf=\"hint\" class=\"nx-toggle-button__label-hint\">({{ hint }})</span>\n\n<ng-template #labelContent>{{ label }}</ng-template>\n<ng-template #circleTextContent>{{ circleText }}</ng-template>\n", styles: [":host{display:none;position:relative;transition:background-color .2s ease,border-color .2s ease,color .2s ease;flex-direction:row;border-width:1px 2px;border-color:var(--circle-toggle-border-color);border-style:solid;padding:11px 31px;width:100%;justify-content:center;align-items:center;cursor:pointer}:host:not(.is-flipped):not(.is-disabled):hover{background-color:var(--circle-toggle-hover-background-color);border-color:var(--circle-toggle-hover-border-color)}:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host:not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:var(--circle-toggle-hover-icon-color)}@media (max-width: 703px){:host-context(.is-responsive){display:flex}}.nx-toggle-button__label-hint{color:var(--circle-toggle-icon-color);font-size:var(--circle-toggle-hint-mobile-font-size);line-height:var(--circle-toggle-hint-mobile-line-height);font-weight:var(--circle-toggle-hint-mobile-font-weight);letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing)}.nx-toggle-button__label-text{color:var(--circle-toggle-icon-color);font-size:var(--circle-toggle-label-mobile-font-size);line-height:var(--circle-toggle-label-mobile-line-height);font-weight:var(--circle-toggle-label-mobile-font-weight);letter-spacing:var(--circle-toggle-label-mobile-letter-spacing);padding-top:0;padding-right:4px;font-weight:600}:host-context([dir=rtl]) .nx-toggle-button__label-text{padding-right:0;padding-right:initial;padding-left:4px}.nx-toggle-button__mobile-check{font-size:24px;height:24px;display:inline-block;opacity:0;margin-right:8px;color:var(--circle-toggle-checkmark-color)}:host-context([dir=rtl]) .nx-toggle-button__mobile-check{margin-right:0;margin-right:initial;margin-left:8px}:host(.is-first){border-top-width:2px;border-radius:4px 4px 0 0}:host(.is-last){border-bottom-width:2px;border-radius:0 0 4px 4px}:host(.is-flipped){background-color:var(--circle-toggle-selected-background-color)}:host(.is-flipped) .nx-toggle-button__label-hint,:host(.is-flipped) .nx-toggle-button__label-text{color:var(--circle-toggle-selected-icon-color)}:host(.is-flipped) .nx-toggle-button__mobile-check{opacity:1}:host(.is-negative){border-color:var(--negative)}:host(.is-negative) .nx-toggle-button__label-hint,:host(.is-negative) .nx-toggle-button__label-text,:host(.is-negative) .nx-toggle-button__mobile-check{color:var(--negative)}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover{background-color:var(--negative-01);border-color:var(--negative-01)}:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-hint,:host(.is-negative):not(.is-flipped):not(.is-disabled):hover .nx-toggle-button__label-text{color:var(--negative-accent)}:host(.is-negative.is-flipped){background-color:var(--negative)}:host(.is-negative.is-flipped) .nx-toggle-button__label-hint,:host(.is-negative.is-flipped) .nx-toggle-button__label-text,:host(.is-negative.is-flipped) .nx-toggle-button__mobile-check{color:var(--negative-accent)}:host(.is-disabled){opacity:.4;cursor:not-allowed}@media screen and (-ms-high-contrast: active){:host{forced-color-adjust:none;background-color:buttonFace!important;border-color:buttonText!important;color:buttonText!important}:host .nx-toggle-button__label-text,:host .nx-toggle-button__label-hint{color:buttonText!important}:host.is-flipped{background-color:highlight!important;color:highlightText!important}:host.is-flipped .nx-toggle-button__label-text,:host.is-flipped .nx-toggle-button__label-hint{color:highlightText!important}:host.is-disabled{opacity:1;border-color:GrayText!important;color:GrayText!important;background-color:buttonFace!important}:host.is-disabled .nx-toggle-button__label-text,:host.is-disabled .nx-toggle-button__label-hint{color:GrayText!important}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { checked: [{
                type: Input
            }], negative: [{
                type: Input
            }], disabled: [{
                type: Input
            }], hint: [{
                type: Input
            }], label: [{
                type: Input
            }], circleText: [{
                type: Input
            }] } });

/** @docs-private */
class ToggleButton {
}

const CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS = new InjectionToken('CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS');
let nextId$1 = 0;
class NxCircleToggleGroupComponent {
    constructor(_cdr, _errorStateMatcher, _defaultOptions, ngControl, _parentForm, _parentFormGroup) {
        this._cdr = _cdr;
        this._errorStateMatcher = _errorStateMatcher;
        this._defaultOptions = _defaultOptions;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this.errorState = false;
        this._id = `nx-circle-toggle-group-${nextId$1++}`;
        /** An event emitted when the selection changes. Outputs the value of the currently selected button. */
        this.valueChange = new EventEmitter();
        this._name = `toggle-group-${nextId$1++}`;
        this._disabled = false;
        this._negative = false;
        this._responsive = true;
        this._destroyed = new Subject();
        this.onChangeCallback = (value) => { };
        this.onTouchedCallback = () => { };
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Id of the circle toggle group.
     *
     * If not set, the circle toggle group gets an incremented value by default.
     */
    set id(value) {
        this._id = value;
        this._cdr.markForCheck();
    }
    get id() {
        return this._id;
    }
    /** Name that is used for accessibility. */
    set name(value) {
        this._name = value;
        this.updateToggleButtonsNames();
        this._cdr.markForCheck();
    }
    get name() {
        return this._name;
    }
    /** Whether the circle toggle group is disabled. */
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._cdr.markForCheck();
        }
        if (this.buttons) {
            this.buttons.forEach(button => (button.disabled = newValue));
        }
    }
    get disabled() {
        return this._disabled;
    }
    /** Whether the circle toggle group uses the negative styling. */
    set negative(value) {
        const newValue = coerceBooleanProperty(value);
        if (this.negative !== newValue) {
            this._negative = newValue;
        }
        if (this.buttons) {
            this.buttons.forEach(button => (button.negative = newValue));
        }
    }
    get negative() {
        return this._negative;
    }
    /** The value of the selected circle toggle in the circle toggle group. */
    set value(value) {
        this.writeValue(value);
    }
    get value() {
        return this._value;
    }
    /** Whether the circle toggle group has a responsive behavior. */
    set responsive(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.responsive) {
            this._responsive = newValue;
            this._cdr.markForCheck();
        }
    }
    get responsive() {
        if (this._isExpert) {
            return false;
        }
        return this._responsive;
    }
    get _isExpert() {
        return this.appearance === 'expert';
    }
    /** @docs-private */
    get selectedButton() {
        return this.buttons ? this.buttons.find(button => button.checked) || null : null;
    }
    /** @docs-private */
    get buttons() {
        return this._buttons;
    }
    /**
     * **Expert option**
     *
     * Sets the appearance of the circle toggle group. Default: 'default'
     */
    set appearance(value) {
        if (this._appearance !== value) {
            this._appearance = value;
            this._cdr.markForCheck();
        }
    }
    get appearance() {
        var _a;
        return this._appearance || ((_a = this._defaultOptions) === null || _a === void 0 ? void 0 : _a.appearance) || 'default';
    }
    writeValue(value) {
        Promise.resolve().then(() => {
            if (this.value !== value) {
                this._value = value;
                this.notifySelectedChild(value);
            }
        });
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    ngAfterViewInit() {
        this.subscribeToSelectionChanges();
        // react if a content child is deleted, added etc.
        this.buttons.changes
            .pipe(startWith(this.buttons), filter(toggles => toggles.length > 0), tap((toggles) => __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve().then(() => {
                toggles.forEach((toggle) => toggle.toggleButton.resetClasses());
                this.buttons.first.toggleButton.setFirstButton();
                this.buttons.last.toggleButton.setLastButton();
            });
        })), takeUntil(this._destroyed))
            .subscribe(() => this.subscribeToSelectionChanges());
    }
    /** @docs-private */
    subscribeToSelectionChanges() {
        merge(...this.buttons.map(button => button.selectionChange))
            .pipe(takeUntil(this.buttons.changes), takeUntil(this._destroyed))
            .subscribe((change) => {
            this.onChangeCallback(change.value);
            this.valueChange.emit(change.value);
        });
    }
    /**
     * @docs-private
     * inform the selected button if the group selection is set programattically at the beginning
     */
    notifySelectedChild(newValue) {
        if (this.buttons) {
            const selected = this.buttons.find(button => button.value === newValue);
            if (selected) {
                selected.setGroupSelection();
            }
        }
    }
    /** @docs-private */
    updateToggleButtonsNames() {
        if (this.buttons) {
            this.buttons.forEach(button => (button.name = this.name));
        }
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribed to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this._updateErrorState();
        }
    }
    _updateErrorState() {
        const oldState = this.errorState;
        const parent = this._parentFormGroup || this._parentForm;
        const control = this.ngControl ? this.ngControl.control : null;
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this._cdr.markForCheck();
        }
    }
}
NxCircleToggleGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleGroupComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1$1.ErrorStateMatcher }, { token: CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS, optional: true }, { token: i2$1.NgControl, optional: true, self: true }, { token: i2$1.NgForm, optional: true }, { token: i2$1.FormGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxCircleToggleGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxCircleToggleGroupComponent, selector: "nx-circle-toggle-group", inputs: { name: "name", disabled: "disabled", negative: "negative", value: "value", responsive: "responsive", appearance: "appearance" }, outputs: { valueChange: "valueChange" }, host: { attributes: { "role": "radiogroup" }, properties: { "class.is-responsive": "responsive", "class.is-disabled": "disabled", "attr.aria-disabled": "disabled", "attr.aria-labelledby": "name", "class.has-error": "errorState", "attr.name": "name", "attr.id": "id", "class.nx-circle-toggle-group": "true", "class.is-expert": "this._isExpert" } }, providers: [], queries: [{ propertyName: "_buttons", predicate: ToggleButton, descendants: true }], ngImport: i0, template: `<ng-content></ng-content>
        <ng-container *ngIf="errorState">
            <ng-content select="nx-error"></ng-content>
        </ng-container> `, isInline: true, styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width: 320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width: 704px){:host(.is-responsive){flex-direction:row}}:host(.has-error) ::ng-deep .nx-toggle-circle__icon-wrapper{border-color:var(--danger)}\n"], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleGroupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-circle-toggle-group', template: `<ng-content></ng-content>
        <ng-container *ngIf="errorState">
            <ng-content select="nx-error"></ng-content>
        </ng-container> `, changeDetection: ChangeDetectionStrategy.OnPush, providers: [], host: {
                        '[class.is-responsive]': 'responsive',
                        '[class.is-disabled]': 'disabled',
                        '[attr.aria-disabled]': 'disabled',
                        '[attr.aria-labelledby]': 'name',
                        '[class.has-error]': 'errorState',
                        '[attr.name]': 'name',
                        '[attr.id]': 'id',
                        '[class.nx-circle-toggle-group]': 'true',
                        role: 'radiogroup',
                    }, styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width: 320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width: 704px){:host(.is-responsive){flex-direction:row}}:host(.has-error) ::ng-deep .nx-toggle-circle__icon-wrapper{border-color:var(--danger)}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i1$1.ErrorStateMatcher }, { type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS]
                    }] }, { type: i2$1.NgControl, decorators: [{
                        type: Optional
                    }, {
                        type: Self
                    }] }, { type: i2$1.NgForm, decorators: [{
                        type: Optional
                    }] }, { type: i2$1.FormGroupDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { name: [{
                type: Input
            }], disabled: [{
                type: Input
            }], negative: [{
                type: Input
            }], value: [{
                type: Input
            }], responsive: [{
                type: Input
            }], _isExpert: [{
                type: HostBinding,
                args: ['class.is-expert']
            }], _buttons: [{
                type: ContentChildren,
                args: [ToggleButton, { descendants: true }]
            }], valueChange: [{
                type: Output
            }], appearance: [{
                type: Input
            }] } });

/** @docs-private */
class NxIconToggleButtonComponent {
    constructor() {
        this.inGroup = true;
        this.hint = '';
        this.label = '';
        this.checked = false;
        this.icon = '';
        this.svgUrl = '';
        this.disabled = false;
        this.negative = false;
        this.touched = false;
        this.circleText = '';
    }
}
NxIconToggleButtonComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxIconToggleButtonComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
NxIconToggleButtonComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxIconToggleButtonComponent, selector: "nx-icon-toggle-button", inputs: { inGroup: "inGroup", hint: "hint", label: "label", checked: "checked", icon: "icon", svgUrl: ["svg", "svgUrl"], disabled: "disabled", negative: "negative", touched: "touched", circleText: "circleText" }, host: { properties: { "class.nx-circle-button": "true", "class.is-flipped": "checked", "class.has-checkmark": "!inGroup", "class.is-disabled": "disabled", "class.is-negative": "negative", "class.is-touched": "touched" } }, ngImport: i0, template: "<div class=\"nx-toggle-circle__icon-wrapper\">\n    <ng-container *ngIf=\"!inGroup\">\n        <span class=\"nx-toggle-circle__check-icon\">\n            <nx-icon name=\"check\"></nx-icon>\n        </span>\n        <div class=\"nx-toggle-circle__check-focus\"></div>\n    </ng-container>\n    <span class=\"nx-toggle-circle__icon\">\n        <nx-icon size=\"m\" *ngIf=\"icon\" [name]=\"icon\"></nx-icon>\n        <img *ngIf=\"svgUrl\" class=\"nx-toggle-circle__icon-image\" [src]=\"svgUrl\" />\n        <span *ngIf=\"circleText\" class=\"nx-toggle-circle__content-text\">{{ circleText }}</span>\n    </span>\n</div>\n<span *ngIf=\"label\" [class.is-label-bold]=\"hint\" class=\"nx-toggle-circle__label-text\">{{ label }}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-circle__label-hint\">{{ hint }}</span>\n", styles: ["@media (max-width: 703px){:host-context(.is-responsive){display:none}}:host{display:flex;flex-direction:column;padding:0;align-items:center;cursor:pointer;position:relative;text-align:center}:host .nx-toggle-circle__label-text{font-size:var(--circle-toggle-label-font-size);line-height:var(--circle-toggle-label-line-height);font-weight:var(--circle-toggle-label-font-weight);letter-spacing:var(--circle-toggle-label-letter-spacing);color:var(--circle-toggle-label-color);position:relative;display:inline-block;padding-top:12px;max-width:16rem;z-index:1}@media (max-width: 703px){:host .nx-toggle-circle__label-text{font-size:var(--circle-toggle-label-mobile-font-size);line-height:var(--circle-toggle-label-mobile-line-height);font-weight:var(--circle-toggle-label-mobile-font-weight);letter-spacing:var(--circle-toggle-label-mobile-letter-spacing)}}:host .is-label-bold{font-weight:700}@media (max-width: 703px){:host .is-label-bold{font-weight:400}}:host .nx-toggle-circle__icon-wrapper{height:80px;width:80px;border-radius:50%;border-width:2px;border-style:solid;border-color:var(--circle-toggle-border-color);display:flex;align-items:center;justify-content:center;transition:background-color .2s ease,border-color .2s ease,box-shadow .2s ease}@media (max-width: 703px){:host .nx-toggle-circle__icon-wrapper{height:64px;width:64px}:host .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{font-size:40px}}:host .nx-toggle-circle__check-icon{background-color:var(--circle-toggle-checkmark-background-color);color:var(--circle-toggle-checkmark-color);border-color:var(--circle-toggle-checkmark-border-color);border-radius:50%;border-width:2px;border-style:solid;font-size:24px;width:32px;height:32px;position:absolute;top:-8px;right:calc(50% - 48px);transition:opacity .3s;z-index:1;opacity:0;display:flex;justify-content:center;align-items:center}[dir=rtl] :host .nx-toggle-circle__check-icon{left:calc(50% - 48px);right:auto}:host .nx-toggle-circle__check-focus{border-radius:50%;width:28px;height:28px;position:absolute;top:-6px;right:calc(50% - 46px);z-index:-1;opacity:0;transition:box-shadow .2s ease}[dir=rtl] :host .nx-toggle-circle__check-focus{left:calc(50% - 46px);right:auto}:host .nx-toggle-circle__content-text{font-size:var(--circle-toggle-content-text-font-size);line-height:var(--circle-toggle-content-text-line-height);font-weight:var(--circle-toggle-content-text-font-weight);letter-spacing:var(--circle-toggle-content-text-letter-spacing);color:var(--circle-toggle-content-text-color)}@media (max-width: 703px){:host .nx-toggle-circle__content-text{font-size:var(--circle-toggle-content-text-mobile-font-size);line-height:var(--circle-toggle-content-text-mobile-line-height);font-weight:var(--circle-toggle-content-text-mobile-font-weight);letter-spacing:var(--circle-toggle-content-text-mobile-letter-spacing)}}:host .nx-toggle-circle__label-hint{font-size:var(--circle-toggle-hint-font-size);line-height:var(--circle-toggle-hint-line-height);font-weight:var(--circle-toggle-hint-font-weight);letter-spacing:var(--circle-toggle-hint-letter-spacing);color:var(--circle-toggle-hint-color);display:inline-block;transition:color .2s ease;z-index:1;max-width:16rem}@media (max-width: 703px){:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}[dir=rtl] :host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{left:calc(50% - 40px);right:auto}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}}@media (max-width: 703px){:host .nx-toggle-circle__label-hint{font-size:var(--circle-toggle-hint-mobile-font-size);line-height:var(--circle-toggle-hint-mobile-line-height);font-weight:var(--circle-toggle-hint-mobile-font-weight);letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing)}}:host .nx-toggle-circle__icon{display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__icon nx-icon{color:var(--circle-toggle-icon-color)}:host .nx-toggle-circle__icon-image{pointer-events:none;position:relative;-webkit-user-select:none;user-select:none}:host-context(.is-expert) .nx-toggle-circle__icon-wrapper{height:64px;width:64px}:host-context(.is-expert) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{font-size:40px}:host-context(.is-expert) .nx-toggle-circle__label-text{font-size:var(--circle-toggle-label-mobile-font-size);line-height:var(--circle-toggle-label-mobile-line-height);font-weight:var(--circle-toggle-label-mobile-font-weight);letter-spacing:var(--circle-toggle-label-mobile-letter-spacing)}:host-context(.is-expert) .is-label-bold{font-weight:400}:host-context(.is-expert) .nx-toggle-circle__content-text{font-size:var(--circle-toggle-content-text-mobile-font-size);line-height:var(--circle-toggle-content-text-mobile-line-height);font-weight:var(--circle-toggle-content-text-mobile-font-weight);letter-spacing:var(--circle-toggle-content-text-mobile-letter-spacing)}:host-context(.is-expert) .nx-toggle-circle__label-hint{font-size:var(--circle-toggle-hint-mobile-font-size);line-height:var(--circle-toggle-hint-mobile-line-height);font-weight:var(--circle-toggle-hint-mobile-font-weight);letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing)}:host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}[dir=rtl] :host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{left:calc(50% - 40px);right:auto}:host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}:host(.is-flipped) .nx-toggle-circle__icon-wrapper{background-color:var(--circle-toggle-selected-background-color);border-color:var(--circle-toggle-selected-border-color)}:host(.is-flipped) .nx-toggle-circle__icon nx-icon{color:var(--circle-toggle-selected-icon-color)}:host(.is-flipped) .nx-toggle-circle__content-text{color:var(--circle-toggle-selected-content-text-color)}:host(.is-flipped) .nx-toggle-circle__check-icon,:host(.is-flipped) .nx-toggle-circle__check-focus{opacity:1}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:var(--circle-toggle-hover-border-color);background-color:var(--circle-toggle-hover-background-color)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:var(--circle-toggle-selected-border-color);background-color:var(--circle-toggle-selected-background-color)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__content-text{color:var(--circle-toggle-hover-icon-color)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:var(--circle-toggle-hover-icon-color)}:host:hover.is-flipped:not(.has-checkmark){cursor:auto}:host(.is-disabled){opacity:.4;cursor:not-allowed}:host(.is-negative) .nx-toggle-circle__icon-wrapper{border-color:var(--negative);background-color:transparent}:host(.is-negative) .nx-toggle-circle__icon nx-icon,:host(.is-negative) .nx-toggle-circle__label-text,:host(.is-negative) .nx-toggle-circle__label-hint,:host(.is-negative) .nx-toggle-circle__content-text{color:var(--negative)}:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper,:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:var(--negative);background-color:var(--negative)}:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon,:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:var(--negative-accent)}:host(.is-negative.is-flipped) .nx-toggle-circle__content-text,:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__content-text{color:var(--negative-accent)}@media screen and (-ms-high-contrast: active){:host{forced-color-adjust:none}:host .nx-toggle-circle__icon-wrapper,:host .nx-toggle-circle__check-icon{border-color:buttonText!important;color:buttonText!important;background:buttonFace!important}:host .nx-toggle-circle__content-text,:host .nx-toggle-circle__label-text,:host .nx-toggle-circle__label-hint{color:buttonText!important}:host.is-flipped .nx-toggle-circle__icon-wrapper{background:highlight!important;border-color:highlight!important;color:highlightText!important}:host.is-disabled{opacity:1}:host.is-disabled .nx-toggle-circle__icon-wrapper,:host.is-disabled .nx-toggle-circle__check-icon{background:window!important;border-color:GrayText!important;color:GrayText!important}:host.is-disabled .nx-toggle-circle__label-text,:host.is-disabled .nx-toggle-circle__label-hint{color:GrayText!important}}\n"], components: [{ type: i1.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxIconToggleButtonComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-icon-toggle-button', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class.nx-circle-button]': 'true',
                        '[class.is-flipped]': 'checked',
                        '[class.has-checkmark]': '!inGroup',
                        '[class.is-disabled]': 'disabled',
                        '[class.is-negative]': 'negative',
                        '[class.is-touched]': 'touched',
                    }, template: "<div class=\"nx-toggle-circle__icon-wrapper\">\n    <ng-container *ngIf=\"!inGroup\">\n        <span class=\"nx-toggle-circle__check-icon\">\n            <nx-icon name=\"check\"></nx-icon>\n        </span>\n        <div class=\"nx-toggle-circle__check-focus\"></div>\n    </ng-container>\n    <span class=\"nx-toggle-circle__icon\">\n        <nx-icon size=\"m\" *ngIf=\"icon\" [name]=\"icon\"></nx-icon>\n        <img *ngIf=\"svgUrl\" class=\"nx-toggle-circle__icon-image\" [src]=\"svgUrl\" />\n        <span *ngIf=\"circleText\" class=\"nx-toggle-circle__content-text\">{{ circleText }}</span>\n    </span>\n</div>\n<span *ngIf=\"label\" [class.is-label-bold]=\"hint\" class=\"nx-toggle-circle__label-text\">{{ label }}</span>\n<span *ngIf=\"hint\" class=\"nx-toggle-circle__label-hint\">{{ hint }}</span>\n", styles: ["@media (max-width: 703px){:host-context(.is-responsive){display:none}}:host{display:flex;flex-direction:column;padding:0;align-items:center;cursor:pointer;position:relative;text-align:center}:host .nx-toggle-circle__label-text{font-size:var(--circle-toggle-label-font-size);line-height:var(--circle-toggle-label-line-height);font-weight:var(--circle-toggle-label-font-weight);letter-spacing:var(--circle-toggle-label-letter-spacing);color:var(--circle-toggle-label-color);position:relative;display:inline-block;padding-top:12px;max-width:16rem;z-index:1}@media (max-width: 703px){:host .nx-toggle-circle__label-text{font-size:var(--circle-toggle-label-mobile-font-size);line-height:var(--circle-toggle-label-mobile-line-height);font-weight:var(--circle-toggle-label-mobile-font-weight);letter-spacing:var(--circle-toggle-label-mobile-letter-spacing)}}:host .is-label-bold{font-weight:700}@media (max-width: 703px){:host .is-label-bold{font-weight:400}}:host .nx-toggle-circle__icon-wrapper{height:80px;width:80px;border-radius:50%;border-width:2px;border-style:solid;border-color:var(--circle-toggle-border-color);display:flex;align-items:center;justify-content:center;transition:background-color .2s ease,border-color .2s ease,box-shadow .2s ease}@media (max-width: 703px){:host .nx-toggle-circle__icon-wrapper{height:64px;width:64px}:host .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{font-size:40px}}:host .nx-toggle-circle__check-icon{background-color:var(--circle-toggle-checkmark-background-color);color:var(--circle-toggle-checkmark-color);border-color:var(--circle-toggle-checkmark-border-color);border-radius:50%;border-width:2px;border-style:solid;font-size:24px;width:32px;height:32px;position:absolute;top:-8px;right:calc(50% - 48px);transition:opacity .3s;z-index:1;opacity:0;display:flex;justify-content:center;align-items:center}[dir=rtl] :host .nx-toggle-circle__check-icon{left:calc(50% - 48px);right:auto}:host .nx-toggle-circle__check-focus{border-radius:50%;width:28px;height:28px;position:absolute;top:-6px;right:calc(50% - 46px);z-index:-1;opacity:0;transition:box-shadow .2s ease}[dir=rtl] :host .nx-toggle-circle__check-focus{left:calc(50% - 46px);right:auto}:host .nx-toggle-circle__content-text{font-size:var(--circle-toggle-content-text-font-size);line-height:var(--circle-toggle-content-text-line-height);font-weight:var(--circle-toggle-content-text-font-weight);letter-spacing:var(--circle-toggle-content-text-letter-spacing);color:var(--circle-toggle-content-text-color)}@media (max-width: 703px){:host .nx-toggle-circle__content-text{font-size:var(--circle-toggle-content-text-mobile-font-size);line-height:var(--circle-toggle-content-text-mobile-line-height);font-weight:var(--circle-toggle-content-text-mobile-font-weight);letter-spacing:var(--circle-toggle-content-text-mobile-letter-spacing)}}:host .nx-toggle-circle__label-hint{font-size:var(--circle-toggle-hint-font-size);line-height:var(--circle-toggle-hint-line-height);font-weight:var(--circle-toggle-hint-font-weight);letter-spacing:var(--circle-toggle-hint-letter-spacing);color:var(--circle-toggle-hint-color);display:inline-block;transition:color .2s ease;z-index:1;max-width:16rem}@media (max-width: 703px){:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}[dir=rtl] :host .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{left:calc(50% - 40px);right:auto}:host .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}}@media (max-width: 703px){:host .nx-toggle-circle__label-hint{font-size:var(--circle-toggle-hint-mobile-font-size);line-height:var(--circle-toggle-hint-mobile-line-height);font-weight:var(--circle-toggle-hint-mobile-font-weight);letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing)}}:host .nx-toggle-circle__icon{display:flex;justify-content:center;align-content:center}:host .nx-toggle-circle__icon nx-icon{color:var(--circle-toggle-icon-color)}:host .nx-toggle-circle__icon-image{pointer-events:none;position:relative;-webkit-user-select:none;user-select:none}:host-context(.is-expert) .nx-toggle-circle__icon-wrapper{height:64px;width:64px}:host-context(.is-expert) .nx-toggle-circle__icon-wrapper .nx-toggle-circle__icon nx-icon{font-size:40px}:host-context(.is-expert) .nx-toggle-circle__label-text{font-size:var(--circle-toggle-label-mobile-font-size);line-height:var(--circle-toggle-label-mobile-line-height);font-weight:var(--circle-toggle-label-mobile-font-weight);letter-spacing:var(--circle-toggle-label-mobile-letter-spacing)}:host-context(.is-expert) .is-label-bold{font-weight:400}:host-context(.is-expert) .nx-toggle-circle__content-text{font-size:var(--circle-toggle-content-text-mobile-font-size);line-height:var(--circle-toggle-content-text-mobile-line-height);font-weight:var(--circle-toggle-content-text-mobile-font-weight);letter-spacing:var(--circle-toggle-content-text-mobile-letter-spacing)}:host-context(.is-expert) .nx-toggle-circle__label-hint{font-size:var(--circle-toggle-hint-mobile-font-size);line-height:var(--circle-toggle-hint-mobile-line-height);font-weight:var(--circle-toggle-hint-mobile-font-weight);letter-spacing:var(--circle-toggle-hint-mobile-letter-spacing)}:host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__icon-wrapper{width:64px;height:64px}:host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__icon nx-icon{font-size:32px}:host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{right:calc(50% - 40px)}[dir=rtl] :host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__check-icon{left:calc(50% - 40px);right:auto}:host-context(.is-expert) .nx-toggle-circle__label-hint .nx-toggle-circle__icon-image{width:64px;height:64px}:host(.is-flipped) .nx-toggle-circle__icon-wrapper{background-color:var(--circle-toggle-selected-background-color);border-color:var(--circle-toggle-selected-border-color)}:host(.is-flipped) .nx-toggle-circle__icon nx-icon{color:var(--circle-toggle-selected-icon-color)}:host(.is-flipped) .nx-toggle-circle__content-text{color:var(--circle-toggle-selected-content-text-color)}:host(.is-flipped) .nx-toggle-circle__check-icon,:host(.is-flipped) .nx-toggle-circle__check-focus{opacity:1}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:var(--circle-toggle-hover-border-color);background-color:var(--circle-toggle-hover-background-color)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover:not(.is-flipped) .nx-toggle-circle__icon-wrapper{border-color:var(--circle-toggle-selected-border-color);background-color:var(--circle-toggle-selected-background-color)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__content-text{color:var(--circle-toggle-hover-icon-color)}:host:not(.is-disabled):not(.is-negative):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:var(--circle-toggle-hover-icon-color)}:host:hover.is-flipped:not(.has-checkmark){cursor:auto}:host(.is-disabled){opacity:.4;cursor:not-allowed}:host(.is-negative) .nx-toggle-circle__icon-wrapper{border-color:var(--negative);background-color:transparent}:host(.is-negative) .nx-toggle-circle__icon nx-icon,:host(.is-negative) .nx-toggle-circle__label-text,:host(.is-negative) .nx-toggle-circle__label-hint,:host(.is-negative) .nx-toggle-circle__content-text{color:var(--negative)}:host(.is-negative.is-flipped) .nx-toggle-circle__icon-wrapper,:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon-wrapper{border-color:var(--negative);background-color:var(--negative)}:host(.is-negative.is-flipped) .nx-toggle-circle__icon nx-icon,:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__icon nx-icon{color:var(--negative-accent)}:host(.is-negative.is-flipped) .nx-toggle-circle__content-text,:host(.is-negative):not(.is-disabled):not(.is-touched):hover .nx-toggle-circle__content-text{color:var(--negative-accent)}@media screen and (-ms-high-contrast: active){:host{forced-color-adjust:none}:host .nx-toggle-circle__icon-wrapper,:host .nx-toggle-circle__check-icon{border-color:buttonText!important;color:buttonText!important;background:buttonFace!important}:host .nx-toggle-circle__content-text,:host .nx-toggle-circle__label-text,:host .nx-toggle-circle__label-hint{color:buttonText!important}:host.is-flipped .nx-toggle-circle__icon-wrapper{background:highlight!important;border-color:highlight!important;color:highlightText!important}:host.is-disabled{opacity:1}:host.is-disabled .nx-toggle-circle__icon-wrapper,:host.is-disabled .nx-toggle-circle__check-icon{background:window!important;border-color:GrayText!important;color:GrayText!important}:host.is-disabled .nx-toggle-circle__label-text,:host.is-disabled .nx-toggle-circle__label-hint{color:GrayText!important}}\n"] }]
        }], propDecorators: { inGroup: [{
                type: Input
            }], hint: [{
                type: Input
            }], label: [{
                type: Input
            }], checked: [{
                type: Input
            }], icon: [{
                type: Input
            }], svgUrl: [{
                type: Input,
                args: ['svg']
            }], disabled: [{
                type: Input
            }], negative: [{
                type: Input
            }], touched: [{
                type: Input
            }], circleText: [{
                type: Input
            }] } });

class ToggleChangeEvent {
    constructor(button, value) {
        this.button = button;
        this.value = value;
    }
}
let nextId = 0;
class NxCircleToggleComponent extends ToggleButton {
    constructor(
    /** @docs-private */ toggleGroup, _checkedDispatcher, _cdr, _focusMonitor, ngControl) {
        super();
        this.toggleGroup = toggleGroup;
        this._checkedDispatcher = _checkedDispatcher;
        this._cdr = _cdr;
        this._focusMonitor = _focusMonitor;
        this.ngControl = ngControl;
        this._id = `toggle-button-${nextId++}`;
        /** @docs-private */
        this.inGroup = false;
        this.errorState = false;
        this._name = null;
        /**
         * An event that is emitted when the checked state fo the circle toggle changes.
         */
        this.checkedChange = new EventEmitter();
        /**
         * An event that is emitted when the checked state of the circle toggle changes.
         * The event object contains the circle toggle itself and its value (see ToggleChangeEvent).
         */
        this.selectionChange = new EventEmitter();
        this._checked = false;
        this._value = null;
        this._iconName = null;
        this._svg = null;
        this._svgChecked = null;
        this._circleText = null;
        this._label = null;
        this._hint = null;
        this._hover = false;
        /** touched is set to true on touch devices. */
        this._touched = false;
        this._removeUniqueSelectionListener = () => { };
        this.onChangeCallback = (checked) => { };
        this.onTouchedCallback = () => { };
        if (this.toggleGroup) {
            this.name = this.toggleGroup.name;
        }
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Id of the circle toggle.
     *
     * If not set, the circle toggle gets an incremented value by default.
     */
    set id(value) {
        this._id = value;
        this._cdr.markForCheck();
    }
    get id() {
        return this._id;
    }
    /** Name that is used for accessibility. */
    set name(value) {
        this._name = value;
        this._cdr.markForCheck();
    }
    get name() {
        return this._name;
    }
    /** Whether the circle toggle is checked. */
    set checked(value) {
        const newValue = coerceBooleanProperty(value);
        if (this.checked !== newValue) {
            this._checked = newValue;
            this._cdr.markForCheck();
        }
    }
    get checked() {
        return this._checked;
    }
    /** The value that is used in the model. */
    set value(newValue) {
        this._value = newValue;
        this._cdr.markForCheck();
    }
    get value() {
        return this._value;
    }
    /** Id of the icon that should be displayed. */
    set iconName(name) {
        this._iconName = name;
        this._cdr.markForCheck();
    }
    get iconName() {
        return this._iconName;
    }
    /** SVG that is displayed if the circle toggle is unchecked. */
    set svg(src) {
        this._svg = src;
        this._cdr.markForCheck();
    }
    get svg() {
        return this._svg;
    }
    /** SVG that is displayed if the circle toggle is checked. */
    set svgChecked(src) {
        this._svgChecked = src;
        this._cdr.markForCheck();
    }
    get svgChecked() {
        return this._svgChecked;
    }
    /** A text that is displayed inside the circle toggle. */
    set circleText(value) {
        if (value !== this._circleText) {
            this._circleText = value;
            this._cdr.markForCheck();
        }
    }
    get circleText() {
        return this._circleText;
    }
    /** Label displayed below the circle. */
    set label(value) {
        this._label = value;
        this._cdr.markForCheck();
    }
    get label() {
        return this._label;
    }
    /** Additional hint displayed below the label. */
    set hint(value) {
        this._hint = value;
        this._cdr.markForCheck();
    }
    get hint() {
        return this._hint;
    }
    /** Whether the circle toggle uses the negative set of styling. */
    set negative(value) {
        const newValue = coerceBooleanProperty(value);
        if (this.negative !== newValue) {
            this._negative = newValue;
            this._cdr.markForCheck();
        }
    }
    get negative() {
        return !!this._negative;
    }
    /** Whether the circle toggle has a responsive behavior. */
    set responsive(value) {
        const newValue = coerceBooleanProperty(value);
        if (this.responsive !== newValue) {
            this._responsive = newValue;
            this._cdr.markForCheck();
        }
    }
    get responsive() {
        return !!this._responsive;
    }
    /** Whether the circle toggle is disabled. */
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (this.disabled !== newValue) {
            this._disabled = newValue;
            this._cdr.markForCheck();
        }
    }
    get disabled() {
        return !!this._disabled;
    }
    /** @docs-private */
    onMouseEnter() {
        if (!this._touched) {
            this._hover = true;
        }
    }
    /** @docs-private */
    onMouseLeave() {
        if (!this._touched) {
            this._hover = false;
        }
    }
    /** @docs-private */
    onTouchStart() {
        this._touched = true;
    }
    ngOnInit() {
        if (this.toggleGroup) {
            this.attachListenerForGroup();
        }
    }
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.errorState = !this.ngControl.valid;
        }
    }
    ngAfterViewInit() {
        Promise.resolve().then(() => {
            if (this.toggleGroup) {
                this.inGroup = true;
                this.negative = this.toggleGroup.negative;
                this.disabled = this.toggleGroup.disabled;
                this.responsive = this.toggleGroup.responsive;
                this.id = this.toggleGroup.id + `-button-${nextId++}`;
            }
        });
        this._focusMonitor.monitor(this._nativeInput);
    }
    ngOnDestroy() {
        // function returned by the listener
        this._removeUniqueSelectionListener();
        this._focusMonitor.stopMonitoring(this._nativeInput);
    }
    /** @docs-private */
    attachListenerForGroup() {
        this._removeUniqueSelectionListener = this._checkedDispatcher.listen((groupId, buttonId) => {
            var _a;
            if (this.id !== buttonId && groupId === ((_a = this.toggleGroup) === null || _a === void 0 ? void 0 : _a.id)) {
                this.checked = false;
            }
        });
    }
    writeValue(newValue) {
        this.checked = newValue;
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /** Focuses the radio button element. */
    focus(focusOrigin) {
        this._focusMonitor.focusVia(this._nativeInput, focusOrigin);
    }
    /** @docs-private */
    toggle(event) {
        event.preventDefault();
        event.stopPropagation();
        // TODO simplify if statement
        if (!((this.toggleGroup && this.checked) || this.disabled)) {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this.checkedChange.emit(this.checked);
            this.selectionChange.emit(new ToggleChangeEvent(this, this.value));
            if (this.toggleGroup) {
                this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
            }
        }
    }
    /**
     * @docs-private
     *
     * method called by the group if the internal value of the group is changed programatically,
     * does not trigger change emission
     */
    setGroupSelection() {
        if (!this.toggleGroup) {
            return;
        }
        // propagate changes only if the value in the group is different than the button checked value
        if (!this.checked) {
            this.checked = !this.checked;
            this.onChangeCallback(this.checked);
            this._checkedDispatcher.notify(this.toggleGroup.id, this.id);
        }
    }
    /** @docs-private */
    get svgButton() {
        return !!this.svg && !!this.svgChecked;
    }
    /** @docs-private */
    get svgUrl() {
        let useFilledSvg = this.checked || (!this.disabled && this._hover);
        if (this.negative) {
            useFilledSvg = !useFilledSvg;
        }
        return useFilledSvg ? this.svgChecked : this.svg;
    }
    /** @docs-private */
    get type() {
        return this.toggleGroup ? 'radio' : 'checkbox';
    }
    /** @docs-private */
    handleEnterKey(event) {
        if (!this.toggleGroup) {
            this.toggle(event);
        }
    }
}
NxCircleToggleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleComponent, deps: [{ token: NxCircleToggleGroupComponent, optional: true }, { token: i2$2.UniqueSelectionDispatcher }, { token: i0.ChangeDetectorRef }, { token: i3.FocusMonitor }, { token: i2$1.NgControl, optional: true, self: true }], target: i0.ɵɵFactoryTarget.Component });
NxCircleToggleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxCircleToggleComponent, selector: "nx-circle-toggle", inputs: { name: "name", checked: "checked", value: "value", iconName: ["icon", "iconName"], svg: "svg", svgChecked: "svgChecked", circleText: "circleText", label: "label", hint: "hint", negative: "negative", responsive: "responsive", disabled: "disabled" }, outputs: { checkedChange: "checkedChange", selectionChange: "selectionChange" }, host: { listeners: { "mouseenter": "onMouseEnter()", "mouseleave": "onMouseLeave()", "touchstart": "onTouchStart()" }, properties: { "class.nx-toggle-circle": "true", "class.in-group": "inGroup", "class.is-disabled": "disabled", "class.is-responsive": "responsive", "class.has-error": "errorState" } }, providers: [
        {
            provide: ToggleButton,
            useExisting: forwardRef(() => NxCircleToggleComponent),
        },
    ], viewQueries: [{ propertyName: "_nativeInput", first: true, predicate: ["input"], descendants: true }, { propertyName: "toggleButton", first: true, predicate: NxMobileToggleButtonComponent, descendants: true, static: true }], usesInheritance: true, ngImport: i0, template: "<input\n    #input\n    [id]=\"id + '-input'\"\n    class=\"nx-circle-toggle__input\"\n    [attr.aria-labelledby]=\"id + '-label'\"\n    [type]=\"type\"\n    [attr.name]=\"name\"\n    [checked]=\"checked\"\n    [disabled]=\"disabled\"\n    [attr.aria-checked]=\"checked\"\n    (keydown.enter)=\"handleEnterKey($event)\"\n    (click)=\"toggle($event)\"\n/>\n<label class=\"nx-circle-toggle__label\" [for]=\"id + '-input'\" [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n        [label]=\"label\"\n        [hint]=\"hint\"\n        [checked]=\"checked\"\n        [icon]=\"iconName\"\n        [negative]=\"negative\"\n        [svg]=\"svgUrl\"\n        [disabled]=\"disabled\"\n        [inGroup]=\"inGroup\"\n        [touched]=\"_touched\"\n        [circleText]=\"circleText\"\n    >\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button [label]=\"label\" [hint]=\"hint\" [checked]=\"checked\" [negative]=\"negative\" [disabled]=\"disabled\" [circleText]=\"circleText\">\n    </nx-mobile-toggle-button>\n    <ng-content select=\"nx-error\" *ngIf=\"errorState\"></ng-content>\n</label>\n", styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width: 703px){:host:not(.in-group){margin-right:48px}}[dir=rtl] :host:not(.in-group){margin-right:0;margin-right:initial;margin-left:64px}@media (max-width: 703px){[dir=rtl] :host:not(.in-group){margin-right:0;margin-right:initial;margin-left:48px}}:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper,:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus{box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper,:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:var(--focus-box-shadow);z-index:1}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host(.has-error) ::ng-deep .is-flipped .nx-toggle-circle__check-icon,:host(.has-error) ::ng-deep .is-flipped .nx-toggle-circle__icon-wrapper{background-color:var(--danger)!important}:host(.has-error) ::ng-deep .nx-toggle-circle__icon-wrapper{border-color:var(--danger)!important}\n"], components: [{ type: NxIconToggleButtonComponent, selector: "nx-icon-toggle-button", inputs: ["inGroup", "hint", "label", "checked", "icon", "svg", "disabled", "negative", "touched", "circleText"] }, { type: NxMobileToggleButtonComponent, selector: "nx-mobile-toggle-button", inputs: ["checked", "negative", "disabled", "hint", "label", "circleText"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-circle-toggle', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: ToggleButton,
                            useExisting: forwardRef(() => NxCircleToggleComponent),
                        },
                    ], host: {
                        '[class.nx-toggle-circle]': 'true',
                        '[class.in-group]': 'inGroup',
                        '[class.is-disabled]': 'disabled',
                        '[class.is-responsive]': 'responsive',
                        '[class.has-error]': 'errorState',
                    }, template: "<input\n    #input\n    [id]=\"id + '-input'\"\n    class=\"nx-circle-toggle__input\"\n    [attr.aria-labelledby]=\"id + '-label'\"\n    [type]=\"type\"\n    [attr.name]=\"name\"\n    [checked]=\"checked\"\n    [disabled]=\"disabled\"\n    [attr.aria-checked]=\"checked\"\n    (keydown.enter)=\"handleEnterKey($event)\"\n    (click)=\"toggle($event)\"\n/>\n<label class=\"nx-circle-toggle__label\" [for]=\"id + '-input'\" [id]=\"id + '-label'\">\n    <nx-icon-toggle-button\n        [label]=\"label\"\n        [hint]=\"hint\"\n        [checked]=\"checked\"\n        [icon]=\"iconName\"\n        [negative]=\"negative\"\n        [svg]=\"svgUrl\"\n        [disabled]=\"disabled\"\n        [inGroup]=\"inGroup\"\n        [touched]=\"_touched\"\n        [circleText]=\"circleText\"\n    >\n    </nx-icon-toggle-button>\n    <!-- The mobile toggle button is needed for the responsive mobile version of the component.\n    The display swtich is handled in the css. -->\n    <nx-mobile-toggle-button [label]=\"label\" [hint]=\"hint\" [checked]=\"checked\" [negative]=\"negative\" [disabled]=\"disabled\" [circleText]=\"circleText\">\n    </nx-mobile-toggle-button>\n    <ng-content select=\"nx-error\" *ngIf=\"errorState\"></ng-content>\n</label>\n", styles: [":host{display:inline-block;vertical-align:top;position:relative}:host:not(.is-responsive){opacity:.9999}:host .nx-circle-toggle__input{opacity:0;position:absolute}:host:not(.in-group){margin-right:64px}@media (max-width: 703px){:host:not(.in-group){margin-right:48px}}[dir=rtl] :host:not(.in-group){margin-right:0;margin-right:initial;margin-left:64px}@media (max-width: 703px){[dir=rtl] :host:not(.in-group){margin-right:0;margin-right:initial;margin-left:48px}}:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper,:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus{box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__icon-wrapper,:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep .nx-toggle-circle__check-focus{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:var(--focus-box-shadow);z-index:1}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host .nx-circle-toggle__input.cdk-keyboard-focused+.nx-circle-toggle__label ::ng-deep nx-mobile-toggle-button{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host(.has-error) ::ng-deep .is-flipped .nx-toggle-circle__check-icon,:host(.has-error) ::ng-deep .is-flipped .nx-toggle-circle__icon-wrapper{background-color:var(--danger)!important}:host(.has-error) ::ng-deep .nx-toggle-circle__icon-wrapper{border-color:var(--danger)!important}\n"] }]
        }], ctorParameters: function () {
        return [{ type: NxCircleToggleGroupComponent, decorators: [{
                        type: Optional
                    }] }, { type: i2$2.UniqueSelectionDispatcher }, { type: i0.ChangeDetectorRef }, { type: i3.FocusMonitor }, { type: i2$1.NgControl, decorators: [{
                        type: Optional
                    }, {
                        type: Self
                    }] }];
    }, propDecorators: { _nativeInput: [{
                type: ViewChild,
                args: ['input']
            }], name: [{
                type: Input
            }], checkedChange: [{
                type: Output
            }], selectionChange: [{
                type: Output
            }], checked: [{
                type: Input
            }], value: [{
                type: Input
            }], iconName: [{
                type: Input,
                args: ['icon']
            }], svg: [{
                type: Input
            }], svgChecked: [{
                type: Input
            }], circleText: [{
                type: Input
            }], label: [{
                type: Input
            }], hint: [{
                type: Input
            }], negative: [{
                type: Input
            }], responsive: [{
                type: Input
            }], disabled: [{
                type: Input
            }], toggleButton: [{
                type: ViewChild,
                args: [NxMobileToggleButtonComponent, { static: true }]
            }], onMouseEnter: [{
                type: HostListener,
                args: ['mouseenter']
            }], onMouseLeave: [{
                type: HostListener,
                args: ['mouseleave']
            }], onTouchStart: [{
                type: HostListener,
                args: ['touchstart']
            }] } });

class NxCircleToggleModule {
}
NxCircleToggleModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxCircleToggleModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleModule, declarations: [NxCircleToggleGroupComponent, NxCircleToggleComponent, NxIconToggleButtonComponent, NxMobileToggleButtonComponent], imports: [CommonModule, NxIconModule], exports: [NxCircleToggleGroupComponent, NxIconToggleButtonComponent, NxCircleToggleComponent, NxMobileToggleButtonComponent] });
NxCircleToggleModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleModule, imports: [[CommonModule, NxIconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NxCircleToggleGroupComponent, NxCircleToggleComponent, NxIconToggleButtonComponent, NxMobileToggleButtonComponent],
                    exports: [NxCircleToggleGroupComponent, NxIconToggleButtonComponent, NxCircleToggleComponent, NxMobileToggleButtonComponent],
                    imports: [CommonModule, NxIconModule],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS, NxCircleToggleComponent, NxCircleToggleGroupComponent, NxCircleToggleModule, NxIconToggleButtonComponent, NxMobileToggleButtonComponent, ToggleChangeEvent };
//# sourceMappingURL=aposin-ng-aquila-circle-toggle.mjs.map
