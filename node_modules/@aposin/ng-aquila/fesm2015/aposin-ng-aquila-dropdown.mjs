import * as i0 from '@angular/core';
import { Directive, Component, ChangeDetectionStrategy, Input, EventEmitter, Inject, Optional, Output, ViewChild, InjectionToken, isDevMode, Attribute, Self, ContentChildren, ContentChild, ViewChildren, HostListener, HostBinding, NgModule } from '@angular/core';
import { __classPrivateFieldSet, __classPrivateFieldGet } from 'tslib';
import * as i5$1 from '@angular/cdk/a11y';
import { ActiveDescendantKeyManager, A11yModule } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { SelectionModel } from '@angular/cdk/collections';
import { DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW, ENTER, SPACE, HOME, END, SHIFT, TAB } from '@angular/cdk/keycodes';
import * as i8 from '@angular/cdk/overlay';
import { Overlay, CdkConnectedOverlay, OverlayModule } from '@angular/cdk/overlay';
import * as i3$1 from '@aposin/ng-aquila/formfield';
import { NxFormfieldControl, NxFormfieldModule } from '@aposin/ng-aquila/formfield';
import { Subject, BehaviorSubject, merge } from 'rxjs';
import { takeUntil, filter, map, startWith, take } from 'rxjs/operators';
import * as i2 from '@aposin/ng-aquila/checkbox';
import { NxCheckboxModule } from '@aposin/ng-aquila/checkbox';
import * as i3 from '@aposin/ng-aquila/icon';
import { NxIconModule } from '@aposin/ng-aquila/icon';
import * as i4 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i5 from '@aposin/ng-aquila/tooltip';
import { NxTooltipModule } from '@aposin/ng-aquila/tooltip';
import * as i6 from '@angular/cdk/observers';
import { ObserversModule } from '@angular/cdk/observers';
import * as i2$1 from '@aposin/ng-aquila/utils';
import * as i4$1 from '@angular/forms';
import { FormsModule } from '@angular/forms';
import * as i4$2 from '@angular/cdk/bidi';
import * as i7 from '@aposin/ng-aquila/button';
import { NxButtonModule } from '@aposin/ng-aquila/button';
import * as i12 from '@aposin/ng-aquila/input';
import { NxInputModule } from '@aposin/ng-aquila/input';

// This Directive solely purpose is to mark given ng-template and project it into the required destination.
class NxDropdownClosedLabelDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
}
NxDropdownClosedLabelDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownClosedLabelDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
NxDropdownClosedLabelDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxDropdownClosedLabelDirective, selector: "[nxClosedLabel]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownClosedLabelDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxClosedLabel]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; } });

class NxDropdownControl extends NxFormfieldControl {
    constructor() {
        super(...arguments);
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         *
         * Note: Please make sure the value you bind is an array. If not an error is thrown! */
        this.isMultiSelect = false;
        this.ignoreItemTrunctation = false;
    }
}

/**
 * Returns an exception to be thrown when attempting to change a select's `multiple` option
 * after initialization.
 * @docs-private
 */
function getNxDropdownDynamicMultipleError() {
    return Error('Cannot change `multiselect` mode of select after initialization.');
}
/**
 * Returns an exception to be thrown when attempting to assign a non-array value to a select
 * in `multiselect` mode. Note that `undefined` and `null` are still valid values to allow for
 * resetting the value.
 * @docs-private
 */
function getNxDropdownNonArrayValueError() {
    return Error('Value must be an array in multiselect mode.');
}

function defaultPositions(offsetY = 0) {
    return [
        {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'top',
            offsetY,
        },
        {
            originX: 'start',
            originY: 'center',
            overlayX: 'start',
            overlayY: 'center',
        },
        {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'bottom',
        },
    ];
}
function outlinePositions() {
    return [
        {
            originX: 'start',
            originY: 'bottom',
            overlayX: 'start',
            overlayY: 'top',
            offsetY: 8,
        },
        {
            originX: 'start',
            originY: 'top',
            overlayX: 'start',
            overlayY: 'bottom',
            offsetY: -8,
        },
    ];
}
function getPositions(appearance, offsetY) {
    if (appearance === 'outline') {
        return outlinePositions();
    }
    return defaultPositions(offsetY);
}
function getPositionOffset(dropdownElement, formFieldElement, panelHeaderElement) {
    const formFieldRect = formFieldElement.getBoundingClientRect();
    const dropdownRect = dropdownElement.getBoundingClientRect();
    const panelHeaderPaddingTop = panelHeaderElement ? parseInt(getComputedStyle(panelHeaderElement).paddingTop, 10) : 0;
    return formFieldRect.top - dropdownRect.top - panelHeaderPaddingTop;
}

class NxDropdownGroupComponent {
}
NxDropdownGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownGroupComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
NxDropdownGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxDropdownGroupComponent, selector: "nx-dropdown-group", inputs: { label: ["nxLabel", "label"] }, ngImport: i0, template: "<div class=\"nx-dropdown-results__group\">\n    <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n    <ng-content></ng-content>\n</div>\n", styles: [":host{display:block}:host:not(:last-child) .nx-dropdown-results__group{position:relative}:host:not(:last-child) .nx-dropdown-results__group:after{content:\"\";position:absolute;width:calc(100% - 64px);height:1px;margin:0 32px;background-color:var(--dropdown-group-divider);bottom:0;left:0}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-size:var(--formfield-label-font-size);line-height:var(--formfield-label-line-height);font-weight:var(--formfield-label-font-weight);letter-spacing:var(--formfield-label-letter-spacing);font-style:italic;font-weight:700;padding:24px 32px 16px}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownGroupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-dropdown-group', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"nx-dropdown-results__group\">\n    <div class=\"nx-dropdown-results__group-label\">{{label}}</div>\n    <ng-content></ng-content>\n</div>\n", styles: [":host{display:block}:host:not(:last-child) .nx-dropdown-results__group{position:relative}:host:not(:last-child) .nx-dropdown-results__group:after{content:\"\";position:absolute;width:calc(100% - 64px);height:1px;margin:0 32px;background-color:var(--dropdown-group-divider);bottom:0;left:0}:host:first-child .nx-dropdown-results__group-label{padding-top:16px}.nx-dropdown-results__group-label{font-size:var(--formfield-label-font-size);line-height:var(--formfield-label-line-height);font-weight:var(--formfield-label-font-weight);letter-spacing:var(--formfield-label-letter-spacing);font-style:italic;font-weight:700;padding:24px 32px 16px}\n"] }]
        }], propDecorators: { label: [{
                type: Input,
                args: ['nxLabel']
            }] } });

class NxDropdownItemChange {
    constructor(
    /** Reference to the option that emitted the event. */
    item, 
    /** Whether the change in the option's value was a result of a user action. */
    isUserInput = false) {
        this.item = item;
        this.isUserInput = isUserInput;
    }
}
/** the unique id counter */
let nextId = 0;
class NxDropdownItemComponent {
    constructor(_dropdown, 
    /** @docs-private */ group, _cdr, _elementRef) {
        this._dropdown = _dropdown;
        this.group = group;
        this._cdr = _cdr;
        this._elementRef = _elementRef;
        this._hidden = false;
        this._mostRecentViewValue = '';
        this._id = `nx-dropdown-item-${nextId++}`;
        this._disabled = false;
        this._selected = false;
        /** Emits whenever the component is destroyed. */
        this._destroyed = new Subject();
        /** Event emitted when the option is selected or deselected. */
        this.onSelectionChange = new EventEmitter();
        /** Emits when the state of the option changes and any parents have to be notified. */
        this._stateChanges = new Subject();
        this._dropdown.filterChanges.pipe(takeUntil(this._destroyed)).subscribe(value => {
            this._showOrHideByFilter(value);
        });
        // reset the hidden state when dropdown closes that on next open the user is seeing the full list again
        this._dropdown._closedStream.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this._hidden = false;
        });
    }
    get label() {
        return this._mostRecentViewValue || this.viewValue;
    }
    /** The unique ID of the option. */
    get id() {
        return this._id;
    }
    /** Whether the dropdown item is disabled. */
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (this.disabled !== newValue) {
            this._disabled = newValue;
            this._cdr.markForCheck();
        }
    }
    get disabled() {
        return this._disabled;
    }
    /** Whether the item is selected. */
    get selected() {
        return this._selected;
    }
    /** Whether the item is active. */
    get active() {
        return this._active;
    }
    /**
     * @docs-private
     * Whether the parent dropdown is in multiselect mode.
     */
    get multiselect() {
        var _a;
        return (_a = this._dropdown) === null || _a === void 0 ? void 0 : _a.isMultiSelect;
    }
    /**
     * @docs-private
     * Whether the parent dropdown allows item truncation.
     */
    get truncateItems() {
        var _a;
        return !((_a = this._dropdown) === null || _a === void 0 ? void 0 : _a.ignoreItemTrunctation);
    }
    ngAfterViewChecked() {
        // Since the parent dropdown component could be using the item's label to display the selected values
        // and it doesn't have a way of knowing if the item's label has changed
        // we have to check for changes in the DOM ourselves and dispatch an event. These checks are
        // relatively cheap, however we still limit them only to selected options in order to avoid
        // hitting the DOM too often.
        this._updateViewValue();
    }
    _updateViewValue() {
        if (this._selected) {
            const viewValue = this.viewValue;
            if (viewValue !== this._mostRecentViewValue) {
                this._mostRecentViewValue = viewValue;
                this._stateChanges.next();
            }
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._stateChanges.complete();
    }
    _onClick(event) {
        /* preventDefault to stop triggering the event twice when you click on the checkbox or the label inside the item */
        event.preventDefault();
        event.stopPropagation();
        this._selectViaInteraction();
    }
    /**
     * `Selects the option while indicating the selection came from the user. Used to
     * determine if the select's view -> model callback should be invoked.`
     */
    _selectViaInteraction() {
        if (!this.disabled) {
            this._selected = this.multiselect ? !this._selected : true;
            this._updateViewValue();
            this._cdr.markForCheck();
            this._emitSelectionChangeEvent(true);
        }
    }
    /**
     * @docs-private
     * Gets the `aria-selected` value for the option. The attribute is omitted from the single-select dropdown
     * for the unselected options. Including the `aria-selected="false" attributes adds a lot of of noise to
     * screen-reader users without providing useful information.
     */
    _getAriaSelected() {
        return this.multiselect ? this.selected : null;
    }
    /** @docs-private */
    show() {
        this._hidden = false;
        this._cdr.markForCheck();
    }
    /** @docs-private */
    hide() {
        this._hidden = true;
        this._cdr.markForCheck();
    }
    _showOrHideByFilter(search) {
        const constraint = this._dropdown.filterFn(search, this.viewValue);
        this._hidden = !constraint;
        this._cdr.markForCheck();
    }
    get _formattedValue() {
        return this._dropdown.valueFormatter(this.value);
    }
    /** @docs-private */
    get viewValue() {
        return (this._elementRef.nativeElement.textContent || '').trim();
    }
    /** @docs-private */
    get elementRef() {
        return this._elementRef;
    }
    select() {
        if (!this._selected && !this.disabled) {
            this._selected = true;
            this._cdr.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    /** @docs-private */
    deselect() {
        if (this._selected) {
            this._selected = false;
            this._cdr.markForCheck();
            this._emitSelectionChangeEvent();
        }
    }
    _initSelected(selected) {
        this._selected = selected;
        this._cdr.markForCheck();
    }
    /** @docs-private */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    _emitSelectionChangeEvent(isUserInput = false) {
        this.onSelectionChange.emit(new NxDropdownItemChange(this, isUserInput));
    }
    /** @docs-private */
    setActiveStyles() {
        this._active = true;
        this._cdr.markForCheck();
    }
    /** @docs-private */
    setInactiveStyles() {
        this._active = false;
        this._cdr.markForCheck();
    }
    /**
     * Returns the list item's text label. Implemented as a part of the ListKeyManagerOption.
     * @docs-private */
    getLabel() {
        return this.viewValue;
    }
    _isContentEmpty(element) {
        var _a;
        return element.children.length === 0 && !((_a = element.textContent) === null || _a === void 0 ? void 0 : _a.trim());
    }
    _onLabelChange() {
        // trigger change detection when the label content changes for the case that ng-content was empty before.
        // this is also important when the label comes in deferred, e.g. by a delayed observable,
        // then first the default label derived from the value is shown
        // and after the value from the async observable is ready we need to trigger change detection that the derived label
        // gets hidden again.
        // Notice(!): the event of (cdkObserveContent) is run outside of the ngZone
        // We run detectChanges directly here as markForCheck wasn't enough to always trigger change detection correctly
        this._cdr.detectChanges();
    }
    /** Returns the correct tabindex for the option depending on disabled state. */
    _getTabIndex() {
        return this.disabled ? '-1' : '0';
    }
}
NxDropdownItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownItemComponent, deps: [{ token: NxDropdownControl }, { token: NxDropdownGroupComponent, optional: true }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
NxDropdownItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxDropdownItemComponent, selector: "nx-dropdown-item", inputs: { value: ["nxValue", "value"], disabled: "disabled" }, outputs: { onSelectionChange: "onSelectionChange" }, host: { attributes: { "role": "option" }, listeners: { "click": "_onClick($event)" }, properties: { "id": "id", "attr.tabindex": "_getTabIndex()", "attr.aria-disabled": "disabled.toString()", "attr.aria-selected": "_getAriaSelected()", "class.nx-hidden": "_hidden", "class.nx-dropdown-item--active": "active", "class.nx-dropdown-item--disabled": "disabled", "class.nx-selected": "selected", "class.nx-multiselect": "multiselect" } }, viewQueries: [{ propertyName: "containerElement", first: true, predicate: ["container"], descendants: true, static: true }], ngImport: i0, template: "<div #container class=\"nx-dropdown-results__option\" [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n    <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\" [disabled]=\"disabled\">\n        <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n        <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n        <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n    <div class=\"nx-dropdown-results__option-label\">\n        <div\n            #content\n            (cdkObserveContent)=\"_onLabelChange()\"\n            [nxTooltip]=\"truncateItems && viewValue?.length > 35 ? viewValue : null\"\n            [ngClass]=\"{ 'ellipsis': truncateItems }\"\n        >\n            <ng-content></ng-content>\n        </div>\n\n        <div [nxTooltip]=\"truncateItems && value?.length > 35 ? value : null\" [ngClass]=\"{ 'ellipsis': truncateItems }\">\n            <ng-container *ngIf=\"_isContentEmpty(content)\"> {{_formattedValue }} </ng-container>\n        </div>\n    </div>\n</ng-template>\n", styles: [":host{display:block}:host:focus{outline:none}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}:host:last-child .nx-dropdown-results__option{padding-bottom:24px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:var(--dropdown-item-font-size);line-height:var(--dropdown-item-line-height);font-weight:var(--dropdown-item-font-weight);letter-spacing:var(--dropdown-item-letter-spacing);padding:8px 32px 8px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}:host-context([dir=rtl]) .nx-dropdown-results__option{padding:8px 8px 8px 32px}.nx-dropdown-results__option-label{padding:0 12px;margin:0 -12px;color:var(--dropdown-item-text-color);white-space:pre-line}@media screen and (-ms-high-contrast: active){.nx-dropdown-results__option-label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}[dir=rtl] :host(.nx-multiselect) .nx-dropdown-results__option{padding-right:32px}:host:not(.nx-dropdown-item--disabled):hover .nx-dropdown-results__option-label,:host(.nx-selected):not(.nx-dropdown-item--disabled):hover .nx-dropdown-results__option-label,:host(.nx-selected):not(.nx-dropdown-item--disabled):hover .nx-dropdown-results__option-checkicon{color:var(--dropdown-item-hover-color)}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}:host(.nx-selected) .nx-dropdown-results__option-label{color:var(--dropdown-item-selected-color)}.nx-dropdown-results__option-checkicon{opacity:0;margin-right:8px;height:var(--dropdown-item-line-height);color:var(--dropdown-item-checkmark-color)}.nx-dropdown-results__option-checkicon nx-icon{line-height:var(--dropdown-item-line-height);font-size:16px}:host-context([dir=rtl]) .nx-dropdown-results__option-checkicon{margin-right:0;margin-right:initial;margin-left:8px}:host(.nx-dropdown-item--active) .nx-dropdown-results__option .nx-dropdown-results__option-label{border-radius:4px;box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host(.nx-dropdown-item--active) .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host(.nx-multiselect.nx-dropdown-item--active) .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}@media screen and (-ms-high-contrast: active){:host(.nx-multiselect.nx-dropdown-item--active) .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}}:host(.nx-multiselect.nx-dropdown-item--active) ::ng-deep .nx-checkbox__label{border-radius:4px;box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host(.nx-multiselect.nx-dropdown-item--active) ::ng-deep .nx-checkbox__label{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}[dir=rtl] :host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:0;padding-left:initial;margin-left:0;margin-left:initial;padding-right:24px;margin-right:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}:host(.nx-dropdown-item--disabled) .nx-dropdown-results__option{cursor:not-allowed}:host(.nx-dropdown-item--disabled) .nx-dropdown-results__option-label{color:var(--dropdown-item-text-color-disabled)}@media screen and (-ms-high-contrast: active){:host:hover:not(.nx-dropdown-item--disabled) .nx-dropdown-results__option-label,:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-label{color:highlightText;background-color:highlight}:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-checkicon{-ms-high-contrast-adjust:none;color:highlightText;background:highlight;z-index:1}:host(.nx-dropdown-item--disabled) .nx-dropdown-results__option-label{color:GrayText}}.ellipsis{max-width:35ch;text-overflow:ellipsis;overflow:hidden;white-space:nowrap}\n"], components: [{ type: i2.NxCheckboxComponent, selector: "nx-checkbox", inputs: ["id", "name", "disabled", "labelSize", "negative", "checked", "indeterminate", "required", "value"], outputs: ["indeterminateChange", "checkedChange", "checkboxChange"] }, { type: i3.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i4.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i5.NxTooltipDirective, selector: "[nxTooltip]", inputs: ["nxTooltipPosition", "nxTooltipDisabled", "nxTooltipSelectable", "nxTooltipShowDelay", "nxTooltipHideDelay", "nxTooltip"], exportAs: ["nxTooltip"] }, { type: i6.CdkObserveContent, selector: "[cdkObserveContent]", inputs: ["cdkObserveContentDisabled", "debounce"], outputs: ["cdkObserveContent"], exportAs: ["cdkObserveContent"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownItemComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-dropdown-item', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[id]': 'id',
                        role: 'option',
                        '[attr.tabindex]': '_getTabIndex()',
                        '[attr.aria-disabled]': 'disabled.toString()',
                        '[attr.aria-selected]': '_getAriaSelected()',
                        '[class.nx-hidden]': '_hidden',
                        '[class.nx-dropdown-item--active]': 'active',
                        '[class.nx-dropdown-item--disabled]': 'disabled',
                        '[class.nx-selected]': 'selected',
                        '[class.nx-multiselect]': 'multiselect',
                        '(click)': '_onClick($event)',
                    }, template: "<div #container class=\"nx-dropdown-results__option\" [ngClass]=\"{'nx-dropdown-results__option--selected': selected}\">\n    <nx-checkbox *ngIf=\"multiselect\" [checked]=\"selected\" [disabled]=\"disabled\">\n        <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </nx-checkbox>\n\n    <span *ngIf=\"!multiselect\" class=\"nx-dropdown-results__option-checkicon\">\n        <nx-icon name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <ng-container *ngIf=\"!multiselect\">\n        <ng-container *ngTemplateOutlet=\"contentTemplate\"></ng-container>\n    </ng-container>\n</div>\n\n<ng-template #contentTemplate>\n    <div class=\"nx-dropdown-results__option-label\">\n        <div\n            #content\n            (cdkObserveContent)=\"_onLabelChange()\"\n            [nxTooltip]=\"truncateItems && viewValue?.length > 35 ? viewValue : null\"\n            [ngClass]=\"{ 'ellipsis': truncateItems }\"\n        >\n            <ng-content></ng-content>\n        </div>\n\n        <div [nxTooltip]=\"truncateItems && value?.length > 35 ? value : null\" [ngClass]=\"{ 'ellipsis': truncateItems }\">\n            <ng-container *ngIf=\"_isContentEmpty(content)\"> {{_formattedValue }} </ng-container>\n        </div>\n    </div>\n</ng-template>\n", styles: [":host{display:block}:host:focus{outline:none}:host(.nx-hidden){display:none}:host:first-child .nx-dropdown-results__option{padding-top:16px}:host:last-child .nx-dropdown-results__option{padding-bottom:24px}nx-checkbox{margin-bottom:0}.nx-dropdown-results__option{font-size:var(--dropdown-item-font-size);line-height:var(--dropdown-item-line-height);font-weight:var(--dropdown-item-font-weight);letter-spacing:var(--dropdown-item-letter-spacing);padding:8px 32px 8px 8px;cursor:pointer;position:relative;display:flex;max-width:100%;white-space:nowrap}:host-context([dir=rtl]) .nx-dropdown-results__option{padding:8px 8px 8px 32px}.nx-dropdown-results__option-label{padding:0 12px;margin:0 -12px;color:var(--dropdown-item-text-color);white-space:pre-line}@media screen and (-ms-high-contrast: active){.nx-dropdown-results__option-label{-ms-high-contrast-adjust:none;color:buttonText;background-color:buttonFace;border-radius:4px}}:host(.nx-multiselect) .nx-dropdown-results__option{display:block;padding-left:32px}[dir=rtl] :host(.nx-multiselect) .nx-dropdown-results__option{padding-right:32px}:host:not(.nx-dropdown-item--disabled):hover .nx-dropdown-results__option-label,:host(.nx-selected):not(.nx-dropdown-item--disabled):hover .nx-dropdown-results__option-label,:host(.nx-selected):not(.nx-dropdown-item--disabled):hover .nx-dropdown-results__option-checkicon{color:var(--dropdown-item-hover-color)}:host(.nx-selected) .nx-dropdown-results__option-checkicon{opacity:1}:host(.nx-selected) .nx-dropdown-results__option-label{color:var(--dropdown-item-selected-color)}.nx-dropdown-results__option-checkicon{opacity:0;margin-right:8px;height:var(--dropdown-item-line-height);color:var(--dropdown-item-checkmark-color)}.nx-dropdown-results__option-checkicon nx-icon{line-height:var(--dropdown-item-line-height);font-size:16px}:host-context([dir=rtl]) .nx-dropdown-results__option-checkicon{margin-right:0;margin-right:initial;margin-left:8px}:host(.nx-dropdown-item--active) .nx-dropdown-results__option .nx-dropdown-results__option-label{border-radius:4px;box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host(.nx-dropdown-item--active) .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host(.nx-multiselect.nx-dropdown-item--active) .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}@media screen and (-ms-high-contrast: active){:host(.nx-multiselect.nx-dropdown-item--active) .nx-dropdown-results__option .nx-dropdown-results__option-label{box-shadow:none}}:host(.nx-multiselect.nx-dropdown-item--active) ::ng-deep .nx-checkbox__label{border-radius:4px;box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host(.nx-multiselect.nx-dropdown-item--active) ::ng-deep .nx-checkbox__label{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:24px;margin-left:-24px}[dir=rtl] :host(.nx-selected.nx-dropdown-item--active) .nx-dropdown-results__option-label{padding-left:0;padding-left:initial;margin-left:0;margin-left:initial;padding-right:24px;margin-right:-24px}:host ::ng-deep .nx-checkbox__label{padding:0 4px;margin:0 -4px}:host(.nx-dropdown-item--disabled) .nx-dropdown-results__option{cursor:not-allowed}:host(.nx-dropdown-item--disabled) .nx-dropdown-results__option-label{color:var(--dropdown-item-text-color-disabled)}@media screen and (-ms-high-contrast: active){:host:hover:not(.nx-dropdown-item--disabled) .nx-dropdown-results__option-label,:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-label{color:highlightText;background-color:highlight}:host(.nx-dropdown-item--active):not(.nx-multiselect) .nx-dropdown-results__option-checkicon{-ms-high-contrast-adjust:none;color:highlightText;background:highlight;z-index:1}:host(.nx-dropdown-item--disabled) .nx-dropdown-results__option-label{color:GrayText}}.ellipsis{max-width:35ch;text-overflow:ellipsis;overflow:hidden;white-space:nowrap}\n"] }]
        }], ctorParameters: function () {
        return [{ type: NxDropdownControl, decorators: [{
                        type: Inject,
                        args: [NxDropdownControl]
                    }] }, { type: NxDropdownGroupComponent, decorators: [{
                        type: Optional
                    }] }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }];
    }, propDecorators: { value: [{
                type: Input,
                args: ['nxValue']
            }], disabled: [{
                type: Input
            }], onSelectionChange: [{
                type: Output
            }], containerElement: [{
                type: ViewChild,
                args: ['container', { static: true }]
            }] } });

var _NxDropdownComponent_valueFormatter, _NxDropdownComponent_compareWith, _NxDropdownComponent_filterFn;
let nextUniqueId = 0;
/** Dropdown data that requires internationalization. */
class NxDropdownIntl {
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        /** A label for the multi-select component. */
        this.selectAll = 'Select all';
        /** A label for the multi-select component. */
        this.clearAll = 'Clear all';
    }
}
/** Change event object that is emitted when the select value has changed. */
class NxDropdownSelectChange {
    constructor(
    /** Reference to the select that emitted the change event. */
    source, 
    /** Current value of the select that emitted the event. */
    value) {
        this.source = source;
        this.value = value;
    }
}
/** Injection token that determines the scroll handling while a dropdown is open. */
const NX_DROPDOWN_SCROLL_STRATEGY = new InjectionToken('nx-dropdown-scroll-strategy');
/** @docs-private */
function NX_DROPDOWN_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/** @docs-private */
const NX_DROPDOWN_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_DROPDOWN_SCROLL_STRATEGY,
    useFactory: NX_DROPDOWN_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
const _defaultFilterFn$1 = (query, label) => label.toLocaleLowerCase().includes(query.toLocaleLowerCase()); // TODO why not `toLowerCase()` as in multi-select?
const _defaultCompareWithFn = (o1, o2) => o1 === o2;
const _defaultValueFormatterFn = value => (value == null ? '' : value.toString());
class NxDropdownComponent {
    constructor(_cdr, _elementRef, _ngZone, tabIndex, formFieldComponent, _errorStateMatcher, 
    /** @docs-private */ ngControl, _parentForm, _parentFormGroup, _dir, _defaultScrollStrategyFactory, liveAnnouncer) {
        this._cdr = _cdr;
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this.formFieldComponent = formFieldComponent;
        this._errorStateMatcher = _errorStateMatcher;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._dir = _dir;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this.liveAnnouncer = liveAnnouncer;
        // The dropdown currently doesn't support readonly of the NxFormfieldControl so we hardcode it here
        this.readonly = false;
        this._disabled = false;
        /** The ID of rendered dropdown html element. */
        this.renderedValueId = `nx-dropdown-rendered-${nextUniqueId++}`;
        this._placeholder = '';
        this._focused = false;
        /** Whether or not the overlay panel is open. */
        this._panelOpen = false;
        /** @docs-private */
        this.errorState = false;
        /**
         * Disable truncation of long item texts.
         * We recommend following UX guidelines and always truncating long items.
         * Please only disable truncation if it's impossible to use short descriptions.
         */
        this._ignoreItemTrunctation = false;
        /**
         * Name of this control that is used inside the formfield component
         * @docs-private
         */
        this.controlType = 'nx-dropdown';
        /** The minimal space between the viewport and the overlay */
        this._overlayViewportMargin = this.dir === 'rtl' ? 0 : 16;
        this._positions = getPositions('auto', 0);
        /**
         * @docs-private
         * Emits when internal state changes to inform formfield about it.
         */
        this.stateChanges = new Subject();
        this._tabIndex = 0;
        /** @docs-private */
        this.currentFilter = '';
        // @ts-expect-error TODO: refactor to be TS compatible
        this._options = new BehaviorSubject(null);
        this._filterInputType = 'text';
        /**
         * Whether the dropdown should allow multi selection and additional checkboxes are shown.
         * Note: Please make sure the value you bind is an array.
         *
         * @throws Error if true and the bound value is not an array
         * @deprecated Please use the new `<nx-multi-select>` component instead.
         */
        this.isMultiSelect = false;
        this._style = '';
        /** Whether the dropdown should render in its negative style or not. */
        this._negative = false;
        /** Whether the dropdown should be shown with an additional filter input. */
        this.showFilter = false;
        /** Text displayed as placeholder for the filter. */
        this.filterPlaceholder = '';
        /** Text that is displayed at the top of the overlay. If not set the formfield label is used by default. */
        this.overlayLabel = '';
        /** Event emitted when the select panel has been toggled. */
        this.openedChange = new EventEmitter();
        /** Event emitted when the dropdown items get filtered. Returns the currently visible dropdown items. */
        this.filterResultChange = new EventEmitter();
        /** Event emitted when the select has been opened. */
        this._openedStream = this.openedChange.pipe(filter(o => o), map(() => { }));
        /** Event emitted when the select has been closed. */
        this._closedStream = this.openedChange.pipe(filter(o => !o), map(() => { }));
        /** Event emitted when the user types in the filter input. */
        this.filterChanges = new Subject();
        /**
         * Event that emits whenever the raw value of the select changes. This is here primarily
         * to facilitate the two-way binding for the `value` input.
         * @docs-private
         */
        this.valueChange = new EventEmitter();
        /** Event emitted when the selected value has been changed. */
        this.selectionChange = new EventEmitter();
        this._destroyed = new Subject();
        /** Strategy factory that will be used to handle scrolling while the dropdown panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
        _NxDropdownComponent_valueFormatter.set(this, void 0);
        _NxDropdownComponent_compareWith.set(this, void 0);
        _NxDropdownComponent_filterFn.set(this, void 0);
        /** Strategy that will be used to handle scrolling while the dropdown panel is open. */
        this._scrollStrategy = this._scrollStrategyFactory();
        /** Comparison function to specify which option is displayed. Defaults to object equality. */
        this._compareWith = (o1, o2) => o1 === o2;
        /** `View -> model callback called when value changes` */
        this._onChange = () => { };
        /** `View -> model callback called when select has been touched` */
        this._onTouched = () => { };
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
        this.tabIndex = parseInt(tabIndex, 10) || 0;
    }
    /**
     * Array of options for the dropdown.
     */
    set options(value) {
        this._options.next(value);
    }
    get options() {
        return this._options.value;
    }
    /**
     * Type of filter input (default: text)
     */
    set filterInputType(value) {
        this._filterInputType = value;
    }
    get filterInputType() {
        return this._filterInputType;
    }
    get tabIndex() {
        return this.disabled ? -1 : this._tabIndex;
    }
    set tabIndex(value) {
        // If the specified tabIndex value is null or undefined, fall back to the default value.
        this._tabIndex = value != null ? value : 0;
    }
    /** Selected value */
    get value() {
        return this._value;
    }
    set value(newValue) {
        if (newValue !== this._value) {
            this.writeValue(newValue);
            this._value = newValue;
            this._onChange(newValue);
        }
    }
    /** Whether the dropdown is disabled. */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
    }
    /** The id of the input. */
    get id() {
        return this.renderedValueId;
    }
    /** If set to 'negative', the component is displayed with the negative set of styles. */
    set styles(value) {
        if (this._style === value) {
            return;
        }
        this._style = value;
        this._negative = !!this._style.match(/negative/);
    }
    /** Placeholder to be shown if no value has been selected. */
    get placeholder() {
        return this._placeholder;
    }
    set placeholder(value) {
        this._placeholder = value;
        this.stateChanges.next();
    }
    /**
     * Disable truncation of long item texts.
     * We recommend following UX guidelines and always truncating long items.
     * Please only disable truncation if it's impossible to use short descriptions.
     */
    get ignoreItemTrunctation() {
        return this._ignoreItemTrunctation;
    }
    set ignoreItemTrunctation(value) {
        this._ignoreItemTrunctation = coerceBooleanProperty(value);
    }
    get dropdownItems() {
        return this._isLazy ? this._lazyDropdownItems : this._contentDropdownItems;
    }
    /** @docs-private */
    get closedDropdownLabel() {
        return this._closedDropdownLabel;
    }
    /** @docs-private */
    get panelOpen() {
        return this._panelOpen;
    }
    set panelOpen(value) {
        this._panelOpen = value;
    }
    /** @docs-private */
    get label() {
        var _a, _b;
        if (this._isInOutlineField) {
            return '';
        }
        return this.overlayLabel ? this.overlayLabel : (_b = (_a = this.formFieldComponent) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : '';
    }
    /**
     * Function that transforms the value into a string.
     * This function is used for displaying and filtering the content.
     *
     * Defaults to `(value: any) => value == null ? '' : value.toString()`
     */
    set valueFormatter(value) {
        __classPrivateFieldSet(this, _NxDropdownComponent_valueFormatter, value, "f");
    }
    get valueFormatter() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _NxDropdownComponent_valueFormatter, "f")) !== null && _a !== void 0 ? _a : _defaultValueFormatterFn;
    }
    /**
     * Function to compare the option values with the selected values. The first argument
     * is a value from an option. The second is a value from the selection. A boolean
     * should be returned.
     *
     * Defaults to object equality.
     */
    set compareWith(value) {
        __classPrivateFieldSet(this, _NxDropdownComponent_compareWith, value, "f");
        if (this._selectionModel) {
            // A different comparator means the selection could change.
            this._initializeSelection();
        }
    }
    get compareWith() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _NxDropdownComponent_compareWith, "f")) !== null && _a !== void 0 ? _a : _defaultCompareWithFn;
    }
    /**
     * Function to be used when the user types into the search filter. The first argument is the user input,
     * the second argument is the dropdown item value as displayed. The dropdown items will use this function
     * to set their visibility state. A boolean should be returned.
     *
     * Defaults to lower case inclusion.
     */
    set filterFn(value) {
        __classPrivateFieldSet(this, _NxDropdownComponent_filterFn, value, "f");
    }
    get filterFn() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _NxDropdownComponent_filterFn, "f")) !== null && _a !== void 0 ? _a : _defaultFilterFn$1;
    }
    /**
     * @docs-private
     * Whether the select is focused.
     */
    get focused() {
        return this._focused || this.panelOpen;
    }
    /** @docs-private */
    get elementRef() {
        return this._elementRef;
    }
    /** The text direction of the containing app. */
    get dir() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    ngOnInit() {
        this._selectionModel = new SelectionModel(this.isMultiSelect);
    }
    ngAfterViewInit() {
        this._initKeyManager();
    }
    ngAfterContentInit() {
        var _a;
        this._closedDropdownLabel = ((_a = this._customClosedDropdownLabel) === null || _a === void 0 ? void 0 : _a.templateRef) || this._defaultClosedDropdownLabel;
        this._selectionModel.changed.pipe(takeUntil(this._destroyed)).subscribe(event => {
            event.added.forEach(({ value }) => {
                this.dropdownItems.filter(option => option.value === value).forEach(option => option.select());
            });
            event.removed.forEach(({ value }) => {
                this.dropdownItems.filter(option => option.value === value).forEach(option => option.deselect());
            });
        });
        if (this._isLazy) {
            this._options.pipe(takeUntil(this._destroyed)).subscribe(() => {
                this._initializeSelection();
            });
        }
        else {
            this.dropdownItems.changes.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {
                this._subscribeToOptionChanges();
                this._initializeSelection();
            });
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /** @docs-private */
    updateErrorState() {
        const oldState = this.errorState;
        const parent = this._parentFormGroup || this._parentForm;
        const control = this.ngControl ? this.ngControl.control : null;
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /** Sets up a key manager to listen to keyboard events on the overlay panel. */
    _initKeyManager() {
        this._keyManager = new ActiveDescendantKeyManager(this.dropdownItems)
            .withTypeAhead()
            .withHomeAndEnd()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate(item => item._hidden || item.disabled);
        this._keyManager.tabOut.pipe(takeUntil(this._closedStream), takeUntil(this._destroyed)).subscribe(() => {
            // Restore focus to the trigger before closing. Ensures that the focus
            // position won't be lost if the user got focus into the overlay.
            this.closePanel();
        });
        this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
            if (this._panelOpen && this.panel) {
                this._scrollActiveOptionIntoView();
            }
            else if (!this._panelOpen && !this.isMultiSelect && this._keyManager.activeItem) {
                this._keyManager.activeItem._selectViaInteraction();
            }
        });
    }
    _initActiveItem() {
        if (!this.isMultiSelect && this._selectionModel.selected[0]) {
            const option = this.dropdownItems.find(o => o.value === this._selectionModel.selected[0].value);
            if (option) {
                this._keyManager.setActiveItem(option);
                this._scrollActiveOptionIntoCenter();
            }
        }
        else {
            this._keyManager.setFirstItemActive();
        }
    }
    _subscribeToOptionChanges() {
        merge(...this.dropdownItems.map(option => option.onSelectionChange))
            .pipe(takeUntil(this.dropdownItems.changes), takeUntil(this._destroyed))
            .subscribe(event => {
            this._onSelect(event.item, event.isUserInput);
        });
        // Listen to changes in the internal state of the options and react accordingly.
        // Handles cases like the labels of the selected options changing.
        merge(...this.dropdownItems.map(option => option._stateChanges))
            .pipe(takeUntil(this.dropdownItems.changes), takeUntil(this._destroyed))
            .subscribe(() => {
            // defer it for the next cycle to not run in changed after checked errors
            // the combination of dropdown-item notifying parent and when the parent
            // tries to fetch the triggerValue from the child throws these errors
            setTimeout(() => {
                this._cdr.markForCheck();
                this.stateChanges.next();
            });
        });
    }
    /** Invoked when an option is clicked. */
    _onSelect(option, isUserInput, item) {
        var _a;
        const wasSelected = this._selectionModel.isSelected(option);
        const selectedOption = item || option;
        if (option.value === null && !this.isMultiSelect) {
            option.deselect();
            this._selectionModel.clear();
            this._propagateChanges(selectedOption.value);
        }
        else {
            if (option.selected) {
                this._selectionModel.select(selectedOption);
            }
            else {
                this._selectionModel.deselect(selectedOption);
            }
            if (isUserInput) {
                (_a = this._keyManager) === null || _a === void 0 ? void 0 : _a.setActiveItem(option);
            }
            if (this.isMultiSelect) {
                this._sortValues();
            }
        }
        const isSelected = this._selectionModel.isSelected(selectedOption);
        if (wasSelected !== isSelected) {
            this._propagateChanges();
        }
        this.stateChanges.next();
        if (isUserInput && !this.isMultiSelect && this._panelOpen) {
            this.closePanel();
        }
    }
    _initializeSelection() {
        // Defer setting the value in order to avoid the "Expression
        // has changed after it was checked" errors from Angular.
        Promise.resolve().then(() => {
            this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);
        });
    }
    /**
     * Sets the selected option based on a value. If no option can be
     * found with the designated value, the select trigger is cleared.
     */
    _setSelectionByValue(value) {
        if (!this._selectionModel) {
            return;
        }
        this._selectionModel.clear();
        if (this.isMultiSelect && value) {
            if (!Array.isArray(value)) {
                throw getNxDropdownNonArrayValueError();
            }
            value.forEach(v => this._selectValue(v));
            this._sortValues();
        }
        else {
            this._selectValue(value);
        }
        this._cdr.markForCheck();
    }
    /**
     * Finds and selects and option based on its value.
     */
    _selectValue(value) {
        const filterFn = (o) => {
            try {
                // Treat null as a special reset value.
                return o.value !== null && this.compareWith(o.value, value);
            }
            catch (error) {
                if (isDevMode()) {
                    // Notify developers of errors in their comparator.
                    console.warn(error);
                }
                return false;
            }
        };
        const options = this._isLazy ? this.options : this.dropdownItems.toArray();
        const option = options.find(filterFn);
        if (option) {
            this._selectionModel.select(option);
        }
    }
    /** Emits change event to set the model value. */
    _propagateChanges(fallbackValue) {
        let valueToEmit = null;
        if (this.isMultiSelect) {
            valueToEmit = this._selectionModel.selected.map(option => option.value);
        }
        else {
            const selectedOption = this._selectionModel.selected[0];
            valueToEmit = selectedOption ? selectedOption.value : fallbackValue;
        }
        this._value = valueToEmit;
        this.valueChange.emit(valueToEmit);
        this._onChange(valueToEmit);
        this.selectionChange.emit(new NxDropdownSelectChange(this, valueToEmit));
        this._cdr.markForCheck();
    }
    /** Sorts the selected values in the selected based on their order in the panel. */
    _sortValues() {
        if (this.isMultiSelect) {
            const options = this._isLazy ? this.options : this.dropdownItems.toArray();
            this._selectionModel.sort((a, b) => options.findIndex(o => o.value === a.value) - options.findIndex(o => o.value === b.value));
            this.stateChanges.next();
        }
    }
    /** Adds a offset to the overlay position, so the formfield label and the dropdown panel header are vertically aligned. */
    _updatePosition() {
        if (this.formFieldComponent) {
            const panelHeader = this.overlayDir.overlayRef.overlayElement.querySelector('.nx-dropdown__panel-header');
            const offset = getPositionOffset(this._elementRef.nativeElement, this.formFieldComponent.elementRef.nativeElement, panelHeader);
            this._positions = getPositions(this.formFieldComponent.appearance, offset);
        }
    }
    /** Focuses the select element. */
    focus() {
        this._elementRef.nativeElement.focus();
    }
    /** Opens the panel of the dropdown. */
    openPanel($event) {
        var _a, _b;
        if (this.disabled || !(((_a = this.dropdownItems) === null || _a === void 0 ? void 0 : _a.length) || ((_b = this.options) === null || _b === void 0 ? void 0 : _b.length)) || this._panelOpen) {
            return;
        }
        $event.preventDefault();
        this._panelOpen = true;
        setTimeout(() => {
            this._selectionModel.selected.forEach(selectedOption => {
                const option = this.dropdownItems.find(o => o.value === selectedOption.value);
                if (option) {
                    option._initSelected(true);
                }
            });
            this._initActiveItem();
        });
        this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();
        this._cdr.markForCheck();
    }
    /** Closes the panel of the dropdown. */
    closePanel() {
        if (this._panelOpen) {
            this._panelOpen = false;
            this._cdr.markForCheck();
            this._onTouched();
            this.openedChange.emit(false);
            // defer the focus if the dropdown triggers actions that detach
            // a template/view from the DOM to prevent changed after checked errors
            this._ngZone.runOutsideAngular(() => {
                setTimeout(() => this.focus());
            });
        }
    }
    _scrollActiveOptionIntoCenter() {
        if (!this.panelBody) {
            return;
        }
        // reset the scrolltop to make calculation easier
        this.panelBody.nativeElement.scrollTop = 0;
        if (!this.empty) {
            const offset = this._getItemOffset(this._keyManager.activeItem);
            const panelHeight = this.panelBody.nativeElement.offsetHeight;
            const panelRect = this.panelBody.nativeElement.getBoundingClientRect();
            const middleOfPanel = panelRect.top + panelHeight / 2;
            if (offset > middleOfPanel) {
                // because we reset the scrollTop to 0 at the top we can simply take the middleOfPanel which is our
                // target position for the item and subtract it from the offset (which is now always relative to the viewport)
                this.panelBody.nativeElement.scrollTop = offset - middleOfPanel;
            }
        }
    }
    /** Scrolls the active option into view. */
    _scrollActiveOptionIntoView() {
        if (!this.panelBody || !this.panelOpen || !this._keyManager.activeItem) {
            return;
        }
        const activeItem = this._keyManager.activeItem.containerElement.nativeElement;
        this.liveAnnouncer.announce(activeItem.textContent); // force screen reader to speak active option
        const panel = this.panelBody.nativeElement;
        const panelOffset = panel.offsetTop; // how much the overlay is repositioned on the page
        const panelTopScrollPosition = panel.scrollTop;
        const panelHeight = panel.clientHeight;
        const itemTop = activeItem.offsetTop - panelOffset;
        const itemBottom = activeItem.offsetTop - panelOffset + activeItem.getBoundingClientRect().height;
        // item half or less visible on top
        if (itemTop < panelTopScrollPosition) {
            this.panelBody.nativeElement.scrollTop = itemTop;
            // item half or less visible on bottom
        }
        else if (itemBottom > panelTopScrollPosition + panelHeight) {
            this.panelBody.nativeElement.scrollTop = itemBottom - panelHeight;
        }
    }
    _getItemOffset(item) {
        if (!item) {
            return 0;
        }
        const itemRect = item.containerElement.nativeElement.getBoundingClientRect();
        return itemRect.top + itemRect.height / 2; // get position of the item's center
    }
    /**
     * @docs-private
     * Formfield Implementation
     */
    setDescribedByIds(ids) {
        this.ariaDescribedby = ids.join(' ');
    }
    /**
     * @docs-private
     * aria-label support removed in favor of aria-labelledby
     * The NxFormfieldControl abstract class requires implementation
     * of below method.
     */
    setAriaLabel(value) {
        return value;
    }
    /**
     * @docs-private
     * Returns html ids of dropdown rendered value and label (if available),
     * separated by space.
     */
    _getAriaLabelledBy() {
        var _a;
        const valueId = this.renderedValueId;
        const labelId = (_a = this.formFieldComponent) === null || _a === void 0 ? void 0 : _a.labelId;
        if (labelId) {
            return `${valueId} ${labelId}`;
        }
        return valueId;
    }
    get _isInOutlineField() {
        return this.formFieldComponent !== null && this.formFieldComponent.appearance === 'outline';
    }
    /**
     * @docs-private
     * Whether the select has a value.
     */
    get empty() {
        return !this._selectionModel || this._selectionModel.isEmpty();
    }
    /** @docs-private */
    get hasValue() {
        return this._selectionModel.hasValue();
    }
    /** @docs-private */
    get shouldLabelFloat() {
        return this.focused || !this.empty || !!(this.placeholder && this.placeholder.length > 0);
    }
    /** End Formfield */
    /** ControlValueAccessor */
    /**
     * Sets the select's value. Part of the ControlValueAccessor interface
     * required to integrate with Angular's core forms API.
     *
     * setTimeout allows to write value after ngOnInit (happens before it right now),
     * so that we have the input `options` set, and it's shown properly in the dropdown
     * https://github.com/angular/angular/issues/29218#issuecomment-592015773
     * It can be removed after the Angular issue is resolved
     *
     * @param value New value to be written to the model.
     */
    writeValue(value) {
        Promise.resolve().then(() => {
            this._setSelectionByValue(value);
        });
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /**
     * Disables the select. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param isDisabled Sets whether the component is disabled.
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._cdr.markForCheck();
        this.stateChanges.next();
    }
    /** End ControlValueAccessor */
    _handleKeydown(event) {
        this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);
    }
    get _isLazy() {
        return Array.isArray(this.options);
    }
    setNextItemActive() {
        const options = this._isLazy ? this.options : this.dropdownItems.toArray();
        const next = Math.min(options.length - 1, options.indexOf(this._selectionModel.selected[0]) + 1);
        this._selectionModel.select(options[next]);
        this._propagateChanges();
    }
    setPreviousItemActive() {
        const options = this._isLazy ? this.options : this.dropdownItems.toArray();
        const prev = Math.max(0, options.indexOf(this._selectionModel.selected[0]) - 1);
        this._selectionModel.select(options[prev]);
        this._propagateChanges();
    }
    _handleClosedKeydown(event) {
        if (this.disabled) {
            return;
        }
        // TODO use event.code after removing IE11 support
        const keyCode = event.keyCode;
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;
        const isOpenKey = keyCode === ENTER || keyCode === SPACE;
        // Open the select on ALT + arrow key to match the native <select>
        if (isOpenKey || ((this.isMultiSelect || event.altKey) && isArrowKey)) {
            event.preventDefault(); // prevents the page from scrolling down when pressing space
            this.openPanel(event);
        }
        else if (!this.isMultiSelect) {
            switch (keyCode) {
                case DOWN_ARROW:
                    this.setNextItemActive();
                    event.preventDefault();
                    break;
                case UP_ARROW:
                    this.setPreviousItemActive();
                    event.preventDefault();
                    break;
                default:
                    this._keyManager.onKeydown(event);
            }
        }
    }
    _handleOpenKeydown(event) {
        // TODO use event.code after removing IE11 support
        const keyCode = event.keyCode;
        // if has filter all events other than the listed ones should be ignored or handled in _onFilter()
        if (![DOWN_ARROW, UP_ARROW, HOME, END, ENTER, LEFT_ARROW, RIGHT_ARROW, SHIFT, SPACE, TAB].includes(keyCode) && this.showFilter) {
            return;
        }
        const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;
        const manager = this._keyManager;
        const allHidden = this.dropdownItems.map(option => option._hidden).every(option => Boolean(option));
        if (keyCode === HOME || keyCode === END) {
            event.preventDefault();
            keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
        }
        else if (isArrowKey && event.altKey) {
            // Close the select on ALT + arrow key to match the native <select>
            event.preventDefault();
            this.closePanel();
        }
        else if (keyCode === ENTER && manager.activeItem && !allHidden) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === ENTER && allHidden) {
            event.preventDefault();
            this.closePanel();
        }
        else if (!this.showFilter && keyCode === SPACE && manager.activeItem) {
            event.preventDefault();
            manager.activeItem._selectViaInteraction();
        }
        else if (keyCode === TAB) {
            this.closePanel();
        }
        else {
            const previouslyFocusedIndex = manager.activeItemIndex;
            manager.onKeydown(event);
            if (this.isMultiSelect && isArrowKey && event.shiftKey && manager.activeItem && manager.activeItemIndex !== previouslyFocusedIndex) {
                manager.activeItem._selectViaInteraction();
            }
        }
    }
    /** @docs-private */
    formatValue(value) {
        return this.valueFormatter(value);
    }
    /** Called when the user types in the filter input */
    _onFilter(event) {
        event.preventDefault();
        this.currentFilter = event.target.value;
        this.filterChanges.next(event.target.value);
        const allHidden = this.dropdownItems.toArray().every(option => option._hidden);
        if (allHidden) {
            // @ts-expect-error: not possible according to TS, but has been working already
            this._keyManager.setActiveItem(null);
        }
        else {
            this._keyManager.setFirstItemActive();
        }
        const visibleItems = this.dropdownItems.filter(option => !option._hidden);
        this.filterResultChange.next(visibleItems);
    }
    /**
     * @docs-private
     * The value displayed in the trigger.
     */
    get triggerValue() {
        if (this.empty) {
            return '';
        }
        if (this.isMultiSelect) {
            return this._selectionModel.selected.map(option => this._getLabel(option)).join(', ');
        }
        return this._getLabel(this._selectionModel.selected[0]);
    }
    _getLabel(option) {
        return option.label || this.formatValue(option.value);
    }
    /**
     * Callback that is invoked when the overlay panel has been attached.
     */
    _onAttached() {
        this.overlayDir.positionChange.pipe(take(1)).subscribe(() => {
            var _a, _b;
            const overlayRef = this.overlayDir.overlayRef;
            const positionStrategy = overlayRef.getConfig().positionStrategy;
            this._updatePosition();
            positionStrategy.withPositions(this._positions);
            overlayRef.updatePosition();
            this._cdr.markForCheck();
            this.openedChange.emit(true);
            if (this.showFilter) {
                (_a = this.filterInput) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();
            }
            else {
                (_b = this.panelBody) === null || _b === void 0 ? void 0 : _b.nativeElement.focus();
            }
        });
    }
    _onFocus() {
        if (!this.disabled) {
            this._focused = true;
            this.stateChanges.next();
        }
    }
    /**
     * Calls the touched callback only if the panel is closed. Otherwise, the trigger will
     * "blur" to the panel when it opens, causing a false positive.
     */
    _onBlur() {
        this._focused = false;
        if (this.filterInput && this.showFilter) {
            this._clearFilter();
        }
        if (!this.disabled && !this.panelOpen) {
            this._onTouched();
            this._cdr.markForCheck();
            this.stateChanges.next();
        }
    }
    /** @docs-private */
    get isFilterEmpty() {
        return this.currentFilter.length === 0;
    }
    _clearFilter() {
        if (!this.filterInput) {
            return;
        }
        this.filterInput.nativeElement.value = '';
        this.currentFilter = '';
        this.filterChanges.next('');
    }
    /** determines the `aria-activedescendant` to be set on the host. */
    _getAriaActiveDescendant() {
        if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    }
}
_NxDropdownComponent_valueFormatter = new WeakMap(), _NxDropdownComponent_compareWith = new WeakMap(), _NxDropdownComponent_filterFn = new WeakMap();
NxDropdownComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: 'tabindex', attribute: true }, { token: i3$1.NxFormfieldComponent, optional: true }, { token: i2$1.ErrorStateMatcher }, { token: i4$1.NgControl, optional: true, self: true }, { token: i4$1.NgForm, optional: true }, { token: i4$1.FormGroupDirective, optional: true }, { token: i4$2.Directionality, optional: true }, { token: NX_DROPDOWN_SCROLL_STRATEGY }, { token: i5$1.LiveAnnouncer }], target: i0.ɵɵFactoryTarget.Component });
NxDropdownComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxDropdownComponent, selector: "nx-dropdown", inputs: { options: "options", filterInputType: "filterInputType", tabIndex: "tabIndex", value: ["nxValue", "value"], disabled: ["nxDisabled", "disabled"], isMultiSelect: ["nxIsMultiselect", "isMultiSelect"], required: ["nxRequired", "required"], styles: ["nxStyle", "styles"], placeholder: "placeholder", ignoreItemTrunctation: ["nxIgnoreItemTrunctation", "ignoreItemTrunctation"], showFilter: ["nxShowFilter", "showFilter"], filterPlaceholder: ["nxFilterPlaceholder", "filterPlaceholder"], overlayLabel: ["nxOverlayLabel", "overlayLabel"], valueFormatter: ["nxValueFormatter", "valueFormatter"], compareWith: "compareWith", filterFn: "filterFn" }, outputs: { openedChange: "openedChange", filterResultChange: "filterResult", _openedStream: "opened", _closedStream: "closed", filterChanges: "filterInput", valueChange: "nxValueChange", selectionChange: "selectionChange" }, host: { attributes: { "role": "button", "aria-haspopup": "listbox" }, listeners: { "keydown": "_handleKeydown($event)", "focus": "_onFocus()", "blur": "_onBlur()", "click": "openPanel($event)" }, properties: { "class.nx-dropdown": "true", "class.is-filled": "hasValue", "class.has-focus": "focused", "class.nx-dropdown--negative": "_negative", "class.nx-dropdown--disabled": "disabled", "attr.aria-describedby": "ariaDescribedby || null", "attr.aria-required": "required", "attr.aria-disabled": "disabled", "attr.aria-labelledby": "_getAriaLabelledBy()", "attr.aria-expanded": "panelOpen", "attr.disabled": "disabled || null", "attr.tabindex": "tabIndex" } }, providers: [
        { provide: NxDropdownControl, useExisting: NxDropdownComponent },
        { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
    ], queries: [{ propertyName: "_customClosedDropdownLabel", first: true, predicate: NxDropdownClosedLabelDirective, descendants: true }, { propertyName: "_contentDropdownItems", predicate: NxDropdownItemComponent, descendants: true }, { propertyName: "groups", predicate: NxDropdownGroupComponent }], viewQueries: [{ propertyName: "panel", first: true, predicate: ["panel"], descendants: true }, { propertyName: "panelBody", first: true, predicate: ["panelBody"], descendants: true }, { propertyName: "trigger", first: true, predicate: ["trigger"], descendants: true, static: true }, { propertyName: "filterInput", first: true, predicate: ["filterInput"], descendants: true }, { propertyName: "overlayDir", first: true, predicate: CdkConnectedOverlay, descendants: true, static: true }, { propertyName: "_defaultClosedDropdownLabel", first: true, predicate: ["defaultClosedDropdownLabel"], descendants: true, static: true }, { propertyName: "_lazyDropdownItems", predicate: NxDropdownItemComponent, descendants: true }], ngImport: i0, template: "<!-- input and stuff-->\n<div cdkOverlayOrigin #origin=\"cdkOverlayOrigin\" class=\"nx-dropdown__container\" #trigger>\n    <div class=\"nx-dropdown__rendered\" [id]=\"renderedValueId\">\n        <span *ngIf=\"empty && placeholder\">{{ placeholder }}</span>\n        <ng-container *ngIf=\"!empty\">\n            <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n        </ng-container>\n    </div>\n    <div class=\"nx-dropdown__icon\">\n        <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n    </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n    <span *ngIf=\"triggerValue\">{{ triggerValue }}</span>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n    cdkConnectedOverlay\n    cdkConnectedOverlayHasBackdrop\n    cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n    [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\"\n    [cdkConnectedOverlayOrigin]=\"origin\"\n    [cdkConnectedOverlayOpen]=\"panelOpen\"\n    [cdkConnectedOverlayPositions]=\"_positions\"\n    [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width!\"\n    [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n    [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n    [cdkConnectedOverlayPush]=\"true\"\n    (backdropClick)=\"closePanel()\"\n    (attach)=\"_onAttached()\"\n    (detach)=\"closePanel()\"\n>\n    <div\n        class=\"nx-dropdown__panel\"\n        [class.has-filter]=\"showFilter\"\n        [class.nx-dropdown__panel--in-outline-field]=\"_isInOutlineField\"\n        (keydown)=\"_handleKeydown($event)\"\n        [dir]=\"dir\"\n        #panel\n    >\n        <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\"> {{ label }} </div>\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n            <input\n                class=\"nx-dropdown__filter-input\"\n                [class.is-filled]=\"!isFilterEmpty\"\n                #filterInput\n                [type]=\"filterInputType\"\n                (input)=\"_onFilter($event)\"\n                [placeholder]=\"filterPlaceholder\"\n            />\n            <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n                <nx-icon name=\"close\"></nx-icon>\n            </span>\n        </div>\n\n        <div\n            class=\"nx-dropdown__panel-body\"\n            tabindex=\"-1\"\n            role=\"listbox\"\n            #panelBody\n            [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n            [attr.aria-multiselectable]=\"isMultiSelect\"\n        >\n            <ng-content></ng-content>\n            <ng-container *ngFor=\"let option of options\">\n                <nx-dropdown-item (onSelectionChange)=\"_onSelect($event.item, $event.isUserInput, option)\" [nxValue]=\"option.value\"\n                    >{{ _getLabel(option) }}</nx-dropdown-item\n                >\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n", styles: [":host{display:block;width:100%}:host:focus{outline:none}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:var(--negative)}:host([aria-expanded=true]) .nx-dropdown__chevron{transform:rotate(180deg)}.nx-dropdown__container{display:flex;justify-content:flex-end;align-items:center;height:100%;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:var(--shadow-small);border-radius:4px;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:var(--dropdown-item-font-size);line-height:var(--dropdown-item-line-height);font-weight:var(--dropdown-item-font-weight);letter-spacing:var(--dropdown-item-letter-spacing);display:flex;align-items:center}.nx-dropdown__panel:focus{outline:none}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-body{max-height:calc(6 * (var(--dropdown-item-outline-line-height) + 16px) + 16px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown-results__group-label{font-size:var(--formfield-outline-label-font-size);line-height:var(--formfield-outline-label-line-height);font-weight:var(--formfield-outline-label-font-weight);letter-spacing:var(--formfield-outline-label-letter-spacing);font-style:normal;font-weight:700}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option,.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-label{font-size:var(--dropdown-item-outline-font-size);line-height:var(--dropdown-item-outline-line-height);font-weight:var(--dropdown-item-outline-font-weight);letter-spacing:var(--dropdown-item-outline-letter-spacing)}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-checkicon{height:var(--dropdown-item-outline-line-height)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input{font-size:var(--formfield-outline-control-font-size);line-height:var(--formfield-outline-control-line-height);font-weight:var(--formfield-outline-control-font-weight);letter-spacing:var(--formfield-outline-control-letter-spacing)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input:empty{font-weight:300}.nx-dropdown__icon{font-size:var(--dropdown-chevron-size);line-height:0}.nx-dropdown__chevron{vertical-align:middle}.nx-dropdown__panel-header{font-size:var(--formfield-label-font-size);line-height:var(--formfield-label-line-height);font-weight:var(--formfield-label-font-weight);letter-spacing:var(--formfield-label-letter-spacing);color:var(--dropdown-panel-header-text-color);background-color:var(--dropdown-panel-header-background-color);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1}.nx-dropdown__panel-body{background-color:var(--dropdown-panel-background-color);max-height:calc(6 * (var(--dropdown-item-line-height) + 16px) + 16px);overflow-y:auto;outline:none}.nx-dropdown__filter{position:relative;padding:16px 32px 12px;background-color:var(--dropdown-panel-background-color)}[dir=rtl] .nx-dropdown__filter{padding:16px 32px 12px}.nx-dropdown__filter-input{font-size:var(--formfield-control-font-size);line-height:var(--formfield-control-line-height);font-weight:var(--formfield-control-font-weight);letter-spacing:var(--formfield-control-letter-spacing);border:0;border-bottom:1px var(--dropdown-filter-input-border-color) solid;color:var(--dropdown-filter-input-text-color);width:100%;outline:none;background-color:transparent;padding:0 24px 3px 0;font-weight:300}.nx-dropdown__filter-input::-ms-clear{display:none}[dir=rtl] .nx-dropdown__filter-input{padding:0 0 3px 24px}.nx-dropdown__panel.has-filter ::ng-deep nx-dropdown-item:first-of-type .nx-dropdown-results__option{padding-top:12px}.nx-dropdown__filter-icon{position:absolute;height:24px;right:32px;top:17px;cursor:pointer}[dir=rtl] .nx-dropdown__filter-icon{left:32px;right:auto}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input:focus{border-color:var(--dropdown-filter-input-active-border-color)}.nx-dropdown__filter-input.is-filled:focus{font-weight:600;color:var(--dropdown-filter-input-active-text-color);border-color:var(--dropdown-filter-input-active-border-color)}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:var(--dropdown-filter-input-active-text-color)}@media screen and (-ms-high-contrast: active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText;border:1px solid CanvasText}.nx-dropdown__panel-header{border-bottom:1px solid windowText}.nx-dropdown__filter-input{border-bottom-color:buttonText}}\n"], components: [{ type: i3.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }, { type: NxDropdownItemComponent, selector: "nx-dropdown-item", inputs: ["nxValue", "disabled"], outputs: ["onSelectionChange"] }], directives: [{ type: i8.CdkOverlayOrigin, selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]", exportAs: ["cdkOverlayOrigin"] }, { type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i4.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }, { type: i8.CdkConnectedOverlay, selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]", inputs: ["cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayPositionStrategy", "cdkConnectedOverlayOffsetX", "cdkConnectedOverlayOffsetY", "cdkConnectedOverlayWidth", "cdkConnectedOverlayHeight", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayMinHeight", "cdkConnectedOverlayBackdropClass", "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayViewportMargin", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOpen", "cdkConnectedOverlayDisableClose", "cdkConnectedOverlayTransformOriginOn", "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayLockPosition", "cdkConnectedOverlayFlexibleDimensions", "cdkConnectedOverlayGrowAfterOpen", "cdkConnectedOverlayPush"], outputs: ["backdropClick", "positionChange", "attach", "detach", "overlayKeydown", "overlayOutsideClick"], exportAs: ["cdkConnectedOverlay"] }, { type: i4$2.Dir, selector: "[dir]", inputs: ["dir"], outputs: ["dirChange"], exportAs: ["dir"] }, { type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-dropdown', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        { provide: NxDropdownControl, useExisting: NxDropdownComponent },
                        { provide: NxFormfieldControl, useExisting: NxDropdownComponent },
                    ], host: {
                        role: 'button',
                        '[class.nx-dropdown]': 'true',
                        '[class.is-filled]': 'hasValue',
                        '[class.has-focus]': 'focused',
                        '[class.nx-dropdown--negative]': '_negative',
                        '[class.nx-dropdown--disabled]': 'disabled',
                        '[attr.aria-describedby]': 'ariaDescribedby || null',
                        '[attr.aria-required]': 'required',
                        '[attr.aria-disabled]': 'disabled',
                        '[attr.aria-labelledby]': '_getAriaLabelledBy()',
                        'aria-haspopup': 'listbox',
                        '[attr.aria-expanded]': 'panelOpen',
                        '[attr.disabled]': 'disabled || null',
                        '[attr.tabindex]': 'tabIndex',
                        '(keydown)': '_handleKeydown($event)',
                        '(focus)': '_onFocus()',
                        '(blur)': '_onBlur()',
                        '(click)': 'openPanel($event)',
                    }, template: "<!-- input and stuff-->\n<div cdkOverlayOrigin #origin=\"cdkOverlayOrigin\" class=\"nx-dropdown__container\" #trigger>\n    <div class=\"nx-dropdown__rendered\" [id]=\"renderedValueId\">\n        <span *ngIf=\"empty && placeholder\">{{ placeholder }}</span>\n        <ng-container *ngIf=\"!empty\">\n            <ng-container *ngTemplateOutlet=\"closedDropdownLabel\"></ng-container>\n        </ng-container>\n    </div>\n    <div class=\"nx-dropdown__icon\">\n        <nx-icon class=\"nx-dropdown__chevron\" name=\"chevron-down\"></nx-icon>\n    </div>\n</div>\n\n<ng-template #defaultClosedDropdownLabel>\n    <span *ngIf=\"triggerValue\">{{ triggerValue }}</span>\n</ng-template>\n\n<!-- overlay -->\n<ng-template\n    cdkConnectedOverlay\n    cdkConnectedOverlayHasBackdrop\n    cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n    [cdkConnectedOverlayScrollStrategy]=\"_scrollStrategy\"\n    [cdkConnectedOverlayOrigin]=\"origin\"\n    [cdkConnectedOverlayOpen]=\"panelOpen\"\n    [cdkConnectedOverlayPositions]=\"_positions\"\n    [cdkConnectedOverlayMinWidth]=\"_triggerRect?.width!\"\n    [cdkConnectedOverlayFlexibleDimensions]=\"true\"\n    [cdkConnectedOverlayViewportMargin]=\"_overlayViewportMargin\"\n    [cdkConnectedOverlayPush]=\"true\"\n    (backdropClick)=\"closePanel()\"\n    (attach)=\"_onAttached()\"\n    (detach)=\"closePanel()\"\n>\n    <div\n        class=\"nx-dropdown__panel\"\n        [class.has-filter]=\"showFilter\"\n        [class.nx-dropdown__panel--in-outline-field]=\"_isInOutlineField\"\n        (keydown)=\"_handleKeydown($event)\"\n        [dir]=\"dir\"\n        #panel\n    >\n        <div class=\"nx-dropdown__panel-header\" *ngIf=\"label\"> {{ label }} </div>\n        <div class=\"nx-dropdown__filter\" *ngIf=\"showFilter\">\n            <input\n                class=\"nx-dropdown__filter-input\"\n                [class.is-filled]=\"!isFilterEmpty\"\n                #filterInput\n                [type]=\"filterInputType\"\n                (input)=\"_onFilter($event)\"\n                [placeholder]=\"filterPlaceholder\"\n            />\n            <span class=\"nx-dropdown__filter-icon\" *ngIf=\"!isFilterEmpty\" (click)=\"_clearFilter()\">\n                <nx-icon name=\"close\"></nx-icon>\n            </span>\n        </div>\n\n        <div\n            class=\"nx-dropdown__panel-body\"\n            tabindex=\"-1\"\n            role=\"listbox\"\n            #panelBody\n            [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n            [attr.aria-multiselectable]=\"isMultiSelect\"\n        >\n            <ng-content></ng-content>\n            <ng-container *ngFor=\"let option of options\">\n                <nx-dropdown-item (onSelectionChange)=\"_onSelect($event.item, $event.isUserInput, option)\" [nxValue]=\"option.value\"\n                    >{{ _getLabel(option) }}</nx-dropdown-item\n                >\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n", styles: [":host{display:block;width:100%}:host:focus{outline:none}:host(.nx-dropdown--negative):focus{font-weight:600}:host(.nx-dropdown--negative){color:var(--negative)}:host([aria-expanded=true]) .nx-dropdown__chevron{transform:rotate(180deg)}.nx-dropdown__container{display:flex;justify-content:flex-end;align-items:center;height:100%;cursor:pointer}:host(.nx-dropdown--disabled) .nx-dropdown__container{cursor:not-allowed}.nx-dropdown__rendered{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.nx-dropdown__panel{box-shadow:var(--shadow-small);border-radius:4px;min-width:100%}.nx-dropdown__panel ::ng-deep .nx-checkbox__label{font-size:var(--dropdown-item-font-size);line-height:var(--dropdown-item-line-height);font-weight:var(--dropdown-item-font-weight);letter-spacing:var(--dropdown-item-letter-spacing);display:flex;align-items:center}.nx-dropdown__panel:focus{outline:none}.nx-dropdown__panel--in-outline-field .nx-dropdown__panel-body{max-height:calc(6 * (var(--dropdown-item-outline-line-height) + 16px) + 16px)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown-results__group-label{font-size:var(--formfield-outline-label-font-size);line-height:var(--formfield-outline-label-line-height);font-weight:var(--formfield-outline-label-font-weight);letter-spacing:var(--formfield-outline-label-letter-spacing);font-style:normal;font-weight:700}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option,.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-label{font-size:var(--dropdown-item-outline-font-size);line-height:var(--dropdown-item-outline-line-height);font-weight:var(--dropdown-item-outline-font-weight);letter-spacing:var(--dropdown-item-outline-letter-spacing)}.nx-dropdown__panel--in-outline-field ::ng-deep nx-dropdown-item .nx-dropdown-results__option-checkicon{height:var(--dropdown-item-outline-line-height)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input{font-size:var(--formfield-outline-control-font-size);line-height:var(--formfield-outline-control-line-height);font-weight:var(--formfield-outline-control-font-weight);letter-spacing:var(--formfield-outline-control-letter-spacing)}.nx-dropdown__panel--in-outline-field ::ng-deep .nx-dropdown__filter-input:empty{font-weight:300}.nx-dropdown__icon{font-size:var(--dropdown-chevron-size);line-height:0}.nx-dropdown__chevron{vertical-align:middle}.nx-dropdown__panel-header{font-size:var(--formfield-label-font-size);line-height:var(--formfield-label-line-height);font-weight:var(--formfield-label-font-weight);letter-spacing:var(--formfield-label-letter-spacing);color:var(--dropdown-panel-header-text-color);background-color:var(--dropdown-panel-header-background-color);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1}.nx-dropdown__panel-body{background-color:var(--dropdown-panel-background-color);max-height:calc(6 * (var(--dropdown-item-line-height) + 16px) + 16px);overflow-y:auto;outline:none}.nx-dropdown__filter{position:relative;padding:16px 32px 12px;background-color:var(--dropdown-panel-background-color)}[dir=rtl] .nx-dropdown__filter{padding:16px 32px 12px}.nx-dropdown__filter-input{font-size:var(--formfield-control-font-size);line-height:var(--formfield-control-line-height);font-weight:var(--formfield-control-font-weight);letter-spacing:var(--formfield-control-letter-spacing);border:0;border-bottom:1px var(--dropdown-filter-input-border-color) solid;color:var(--dropdown-filter-input-text-color);width:100%;outline:none;background-color:transparent;padding:0 24px 3px 0;font-weight:300}.nx-dropdown__filter-input::-ms-clear{display:none}[dir=rtl] .nx-dropdown__filter-input{padding:0 0 3px 24px}.nx-dropdown__panel.has-filter ::ng-deep nx-dropdown-item:first-of-type .nx-dropdown-results__option{padding-top:12px}.nx-dropdown__filter-icon{position:absolute;height:24px;right:32px;top:17px;cursor:pointer}[dir=rtl] .nx-dropdown__filter-icon{left:32px;right:auto}.nx-dropdown__filter-icon nx-icon{font-size:24px}.nx-dropdown__filter-input:focus{border-color:var(--dropdown-filter-input-active-border-color)}.nx-dropdown__filter-input.is-filled:focus{font-weight:600;color:var(--dropdown-filter-input-active-text-color);border-color:var(--dropdown-filter-input-active-border-color)}.nx-dropdown__filter-input.is-filled:focus+.nx-dropdown__filter-icon{color:var(--dropdown-filter-input-active-text-color)}@media screen and (-ms-high-contrast: active){.nx-dropdown__panel{box-shadow:0 0 0 1px windowText;border:1px solid CanvasText}.nx-dropdown__panel-header{border-bottom:1px solid windowText}.nx-dropdown__filter-input{border-bottom-color:buttonText}}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: undefined, decorators: [{
                        type: Attribute,
                        args: ['tabindex']
                    }] }, { type: i3$1.NxFormfieldComponent, decorators: [{
                        type: Optional
                    }] }, { type: i2$1.ErrorStateMatcher }, { type: i4$1.NgControl, decorators: [{
                        type: Optional
                    }, {
                        type: Self
                    }] }, { type: i4$1.NgForm, decorators: [{
                        type: Optional
                    }] }, { type: i4$1.FormGroupDirective, decorators: [{
                        type: Optional
                    }] }, { type: i4$2.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [NX_DROPDOWN_SCROLL_STRATEGY]
                    }] }, { type: i5$1.LiveAnnouncer }];
    }, propDecorators: { options: [{
                type: Input
            }], filterInputType: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], value: [{
                type: Input,
                args: ['nxValue']
            }], disabled: [{
                type: Input,
                args: ['nxDisabled']
            }], isMultiSelect: [{
                type: Input,
                args: ['nxIsMultiselect']
            }], required: [{
                type: Input,
                args: ['nxRequired']
            }], styles: [{
                type: Input,
                args: ['nxStyle']
            }], placeholder: [{
                type: Input
            }], ignoreItemTrunctation: [{
                type: Input,
                args: ['nxIgnoreItemTrunctation']
            }], showFilter: [{
                type: Input,
                args: ['nxShowFilter']
            }], filterPlaceholder: [{
                type: Input,
                args: ['nxFilterPlaceholder']
            }], overlayLabel: [{
                type: Input,
                args: ['nxOverlayLabel']
            }], openedChange: [{
                type: Output
            }], filterResultChange: [{
                type: Output,
                args: ['filterResult']
            }], _openedStream: [{
                type: Output,
                args: ['opened']
            }], _closedStream: [{
                type: Output,
                args: ['closed']
            }], filterChanges: [{
                type: Output,
                args: ['filterInput']
            }], valueChange: [{
                type: Output,
                args: ['nxValueChange']
            }], selectionChange: [{
                type: Output
            }], panel: [{
                type: ViewChild,
                args: ['panel']
            }], panelBody: [{
                type: ViewChild,
                args: ['panelBody']
            }], trigger: [{
                type: ViewChild,
                args: ['trigger', { static: true }]
            }], filterInput: [{
                type: ViewChild,
                args: ['filterInput']
            }], overlayDir: [{
                type: ViewChild,
                args: [CdkConnectedOverlay, { static: true }]
            }], _contentDropdownItems: [{
                type: ContentChildren,
                args: [NxDropdownItemComponent, { descendants: true }]
            }], groups: [{
                type: ContentChildren,
                args: [NxDropdownGroupComponent]
            }], _customClosedDropdownLabel: [{
                type: ContentChild,
                args: [NxDropdownClosedLabelDirective]
            }], _defaultClosedDropdownLabel: [{
                type: ViewChild,
                args: ['defaultClosedDropdownLabel', { static: true }]
            }], _lazyDropdownItems: [{
                type: ViewChildren,
                args: [NxDropdownItemComponent]
            }], valueFormatter: [{
                type: Input,
                args: ['nxValueFormatter']
            }], compareWith: [{
                type: Input
            }], filterFn: [{
                type: Input
            }] } });

let optionId = 0;
/**
 * A single option witin the multi select.
 *
 * @docs-private
 */
class NxMultiSelectOptionComponent {
    constructor(_cdr, elementRef) {
        this._cdr = _cdr;
        this.elementRef = elementRef;
        this._active = false;
        this.id = `nx-multi-select-option-${optionId++}`;
        this.appearance = 'auto';
        /**
         * Label of this option.
         */
        this.label = '';
        /**
         * Whether this option is selected.
         */
        this.selected = false;
        /**
         * Whether thisoption is disabled.
         */
        this.disabled = false;
        /**
         * Emits an event when this option is selected or unselected by the user.
         */
        this.selectedChange = new EventEmitter();
    }
    /**
     * Sets this option active highlighting it to the user.
     */
    set active(value) {
        this._active = value;
        this._cdr.markForCheck();
    }
    get active() {
        return this._active;
    }
    setActiveStyles() {
        this.active = true;
    }
    setInactiveStyles() {
        this.active = false;
    }
    _onClick() {
        if (!this.disabled) {
            this.selected = !this.selected;
            this.selectedChange.emit(this.selected);
        }
    }
    /**
     * Selects this option as if the user clicked on it.
     */
    selectViaInteraction() {
        this._onClick();
        this._cdr.markForCheck();
    }
}
NxMultiSelectOptionComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMultiSelectOptionComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
NxMultiSelectOptionComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxMultiSelectOptionComponent, selector: "nx-multi-select-option", inputs: { appearance: "appearance", value: "value", label: "label", selected: "selected", disabled: "disabled" }, outputs: { selectedChange: "selectedChange" }, host: { attributes: { "role": "option" }, listeners: { "click": "_onClick()" }, properties: { "id": "id", "attr.aria-selected": "selected || null", "attr.aria-disabled": "disabled || null", "class.is-outline": "appearance === \"outline\"" } }, ngImport: i0, template: "<div class=\"nx-checkbox\" [class.is-active]=\"active\" [class.is-selected]=\"selected\" [class.is-disabled]=\"disabled\">\n    <span class=\"nx-checkbox__control\">\n        <nx-icon *ngIf=\"selected\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <span class=\"nx-checkbox__label\">\n        {{ label }}\n    </span>\n</div>\n", styles: [":host{display:flex;width:100%;padding:8px 0}:host.is-outline{padding:8px 0}:host.is-outline .nx-checkbox{font-size:var(--checkbox-small-label-font-size);line-height:var(--checkbox-small-label-line-height);font-weight:var(--checkbox-small-label-font-weight);letter-spacing:var(--checkbox-small-label-letter-spacing)}.nx-checkbox{font-size:var(--checkbox-large-label-font-size);line-height:var(--checkbox-large-label-line-height);font-weight:var(--checkbox-large-label-font-weight);letter-spacing:var(--checkbox-large-label-letter-spacing);color:var(--checkbox-label-color);cursor:pointer;display:flex;align-items:flex-start}.nx-checkbox.is-active{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-checkbox.is-active{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}.nx-checkbox.is-disabled{cursor:not-allowed}.nx-checkbox.is-disabled .nx-checkbox__control{background-color:var(--checkbox-disabled-background-color);border-color:var(--checkbox-disabled-border-color);color:var(--checkbox-disabled-icon-color)}.nx-checkbox.is-disabled .nx-checkbox__label{color:var(--checkbox-label-disabled-color)}.nx-checkbox.is-selected .nx-checkbox__control{background-color:var(--checkbox-selected-background-color);border-color:var(--checkbox-selected-border-color)}.nx-checkbox__control{background-color:var(--checkbox-background-color);border-style:solid;border-width:var(--checkbox-border-width);border-color:var(--checkbox-border-color);border-radius:var(--checkbox-border-radius);color:var(--checkbox-icon-color);font-size:var(--checkbox-icon-size);height:var(--checkbox-control-size);width:var(--checkbox-control-size);min-width:var(--checkbox-control-size);display:flex;justify-content:center;align-items:flex-start;z-index:0}.nx-checkbox__label{padding:0;margin-left:var(--checkbox-small-label-text-margin-left)}:host-context([dir=rtl]) .nx-checkbox__label{margin-left:0;margin-left:initial;margin-right:var(--checkbox-small-label-text-margin-left)}\n"], components: [{ type: i3.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMultiSelectOptionComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-multi-select-option', host: {
                        role: 'option',
                        '[id]': 'id',
                        '[attr.aria-selected]': 'selected || null',
                        '[attr.aria-disabled]': 'disabled || null',
                        '[class.is-outline]': 'appearance === "outline"',
                    }, changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"nx-checkbox\" [class.is-active]=\"active\" [class.is-selected]=\"selected\" [class.is-disabled]=\"disabled\">\n    <span class=\"nx-checkbox__control\">\n        <nx-icon *ngIf=\"selected\" name=\"check\" aria-hidden=\"true\"></nx-icon>\n    </span>\n\n    <span class=\"nx-checkbox__label\">\n        {{ label }}\n    </span>\n</div>\n", styles: [":host{display:flex;width:100%;padding:8px 0}:host.is-outline{padding:8px 0}:host.is-outline .nx-checkbox{font-size:var(--checkbox-small-label-font-size);line-height:var(--checkbox-small-label-line-height);font-weight:var(--checkbox-small-label-font-weight);letter-spacing:var(--checkbox-small-label-letter-spacing)}.nx-checkbox{font-size:var(--checkbox-large-label-font-size);line-height:var(--checkbox-large-label-line-height);font-weight:var(--checkbox-large-label-font-weight);letter-spacing:var(--checkbox-large-label-letter-spacing);color:var(--checkbox-label-color);cursor:pointer;display:flex;align-items:flex-start}.nx-checkbox.is-active{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-checkbox.is-active{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}.nx-checkbox.is-disabled{cursor:not-allowed}.nx-checkbox.is-disabled .nx-checkbox__control{background-color:var(--checkbox-disabled-background-color);border-color:var(--checkbox-disabled-border-color);color:var(--checkbox-disabled-icon-color)}.nx-checkbox.is-disabled .nx-checkbox__label{color:var(--checkbox-label-disabled-color)}.nx-checkbox.is-selected .nx-checkbox__control{background-color:var(--checkbox-selected-background-color);border-color:var(--checkbox-selected-border-color)}.nx-checkbox__control{background-color:var(--checkbox-background-color);border-style:solid;border-width:var(--checkbox-border-width);border-color:var(--checkbox-border-color);border-radius:var(--checkbox-border-radius);color:var(--checkbox-icon-color);font-size:var(--checkbox-icon-size);height:var(--checkbox-control-size);width:var(--checkbox-control-size);min-width:var(--checkbox-control-size);display:flex;justify-content:center;align-items:flex-start;z-index:0}.nx-checkbox__label{padding:0;margin-left:var(--checkbox-small-label-text-margin-left)}:host-context([dir=rtl]) .nx-checkbox__label{margin-left:0;margin-left:initial;margin-right:var(--checkbox-small-label-text-margin-left)}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }]; }, propDecorators: { appearance: [{
                type: Input
            }], value: [{
                type: Input
            }], label: [{
                type: Input
            }], selected: [{
                type: Input
            }], disabled: [{
                type: Input
            }], selectedChange: [{
                type: Output
            }], _onClick: [{
                type: HostListener,
                args: ['click']
            }] } });

var _NxMultiSelectComponent_disableSelectAll, _NxMultiSelectComponent_filterFn;
let id = 0;
const OVERLAY_MIN_WIDTH = 260;
const _defaultFilterFn = (query, label) => label.toLowerCase().includes(query.toLowerCase());
/**
 * Multi Select component.
 * @typeParam S Type of the items in the options array
 * @typeParam T Type of the ngModel value
 */
class NxMultiSelectComponent {
    constructor(_intl, _elementRef, _errorStateMatcher, _cdr, _formFieldComponent, ngControl, _parentForm, _parentFormGroup) {
        this._intl = _intl;
        this._elementRef = _elementRef;
        this._errorStateMatcher = _errorStateMatcher;
        this._cdr = _cdr;
        this._formFieldComponent = _formFieldComponent;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        _NxMultiSelectComponent_disableSelectAll.set(this, false);
        _NxMultiSelectComponent_filterFn.set(this, void 0);
        this._required = false;
        this._disabled = false;
        this._readonly = false;
        this._placeholder = '';
        this._filter = false;
        this._openedBy = 'mouse';
        /** @docs-private */
        this._divider = 0;
        /** Event emitted when the selected value has been changed. */
        this.selectionChange = new EventEmitter();
        /** @docs-private */
        this.controlType = 'nx-multi-select';
        /** @docs-private */
        this.errorState = false;
        this._positions = getPositions('auto', 0);
        this._inputFocused = false;
        this._ariaDescribedby = '';
        this._width = 0;
        this._filterValue = '';
        this._tooltipText = '';
        this.listItems = [];
        this.selectedItems = new Set();
        this.id = `nx-multi-select-${id++}`;
        this._comboboxId = `${this.id}-combobox`;
        this.stateChanges = new Subject();
        /**
         * List of options to choose from.
         */
        this.options = [];
        /**
         * Placeholder for the filter input.
         */
        this.filterPlaceholder = 'Type to filter';
        /**
         * Selector to get the value of an option.
         * Can be either a property name or a selector function.
         * When empty the whole option is treated as the value.
         */
        this.selectValue = '';
        /**
         * Selector to get the label of an option.
         * Can be either a property name or a selector function.
         * When empty the whole option is treated as the label.
         */
        this.selectLabel = '';
        this._isOpen = false;
        this._destroyed = new Subject();
        this._onChange = () => { };
        this._onTouched = () => { };
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
        this._isDisabled = this._isDisabled.bind(this);
        _intl.changes.pipe(takeUntil(this._destroyed)).subscribe(() => _cdr.markForCheck());
    }
    get value() {
        return this.options.filter(option => this.selectedItems.has(option)).map(option => this._selectValue(option));
    }
    get _isOutline() {
        return this._appearance === 'outline';
    }
    get _appearance() {
        var _a;
        return (_a = this._formFieldComponent) === null || _a === void 0 ? void 0 : _a.appearance;
    }
    get _overlayLabel() {
        var _a;
        return (_a = this._formFieldComponent) === null || _a === void 0 ? void 0 : _a.label;
    }
    /**
     * Whether the value is empty.
     */
    get empty() {
        return this.selectedItems.size === 0;
    }
    get focused() {
        return this._isOpen || this._inputFocused;
    }
    // @Input()
    // selectValue(value: string | () )
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value;
    }
    /** Whether the multi select is disabled. */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = value;
    }
    /** Whether the multi select should be read only. */
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        this._readonly = coerceBooleanProperty(value);
        this.stateChanges.next();
    }
    /** The placeholder shown in the multi select field. */
    get placeholder() {
        return this._placeholder;
    }
    set placeholder(value) {
        this._placeholder = value;
        this.stateChanges.next();
    }
    /**
     * Whether this multi select can be filtered.
     */
    set filter(value) {
        this._filter = coerceBooleanProperty(value);
    }
    get filter() {
        return this._filter;
    }
    /** Whether the (select all / clear all) should be disabled and hidden. */
    set disableSelectAll(value) {
        const coercedValue = coerceBooleanProperty(value);
        if (__classPrivateFieldGet(this, _NxMultiSelectComponent_disableSelectAll, "f") !== coercedValue) {
            __classPrivateFieldSet(this, _NxMultiSelectComponent_disableSelectAll, coercedValue, "f");
            this._cdr.markForCheck();
        }
    }
    get disableSelectAll() {
        return __classPrivateFieldGet(this, _NxMultiSelectComponent_disableSelectAll, "f");
    }
    /**
     * Function to be used when the user types into the search filter. The first argument is the user input,
     * the second argument is the dropdown item value as displayed. The dropdown items will use this function
     * to set their visibility state. A boolean should be returned.
     *
     * Defaults to lower case inclusion.
     */
    set filterFn(value) {
        __classPrivateFieldSet(this, _NxMultiSelectComponent_filterFn, value, "f");
    }
    get filterFn() {
        var _a;
        return (_a = __classPrivateFieldGet(this, _NxMultiSelectComponent_filterFn, "f")) !== null && _a !== void 0 ? _a : _defaultFilterFn;
    }
    /** @docs-private */
    get shouldLabelFloat() {
        return this.focused || !this.empty || !!(this.placeholder && this.placeholder.length > 0);
    }
    /** @docs-private */
    get elementRef() {
        return this._elementRef;
    }
    get _allSelected() {
        return this.selectedItems.size === this.options.filter(option => !this._isDisabled(option)).length;
    }
    get _someSelected() {
        return this.selectedItems.size > 0 && !this._allSelected;
    }
    get _isActiveItemFiltered() {
        return (typeof this._keyManager.activeItem !== 'undefined' &&
            !this.listItems.some(option => { var _a; return this._selectValue(option) === ((_a = this._keyManager.activeItem) === null || _a === void 0 ? void 0 : _a.value); }));
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._cdr.markForCheck();
        this.stateChanges.next();
    }
    _selectValue(option) {
        if (!this.selectValue) {
            return option;
        }
        if (typeof this.selectValue === 'string') {
            return option[this.selectValue];
        }
        return this.selectValue(option);
    }
    _selectLabel(option) {
        if (!this.selectLabel) {
            return String(this._selectValue(option));
        }
        if (typeof this.selectLabel === 'string') {
            return String(option[this.selectLabel]);
        }
        return this.selectLabel(option);
    }
    _updatePositions() {
        var _a;
        if (this._formFieldComponent) {
            const offset = getPositionOffset(this._elementRef.nativeElement, this._formFieldComponent.elementRef.nativeElement, (_a = this._panelHeader) === null || _a === void 0 ? void 0 : _a.nativeElement);
            this._positions = getPositions(this._appearance, offset);
        }
    }
    _isDisabled(option) {
        if (typeof this.selectDisabled === 'string') {
            return option[this.selectDisabled];
        }
        if (typeof this.selectDisabled === 'function') {
            return this.selectDisabled(option);
        }
        return false;
    }
    /**
     * Returns html ids of multi select rendered value and label (if available),
     * separated by space.
     */
    _getAriaLabelledBy() {
        var _a;
        const valueId = this.id;
        const labelId = (_a = this._formFieldComponent) === null || _a === void 0 ? void 0 : _a.labelId;
        if (labelId) {
            return `${valueId} ${labelId}`;
        }
        return valueId;
    }
    /** @docs-private */
    setDescribedByIds(ids) {
        this._ariaDescribedby = ids.join(' ');
    }
    ngAfterViewInit() {
        this._initKeyManager();
    }
    open($event, origin) {
        this._open($event, origin);
    }
    _open($event, origin) {
        var _a;
        if (this._isOpen || this.disabled) {
            return;
        }
        const sortSelectedToTop = (a, b) => {
            const aSelected = this.selectedItems.has(a);
            const bSelected = this.selectedItems.has(b);
            if (aSelected && !bSelected) {
                return -1;
            }
            else if (!aSelected && bSelected) {
                return 1;
            }
            return 0;
        };
        $event.preventDefault();
        this._filterValue = '';
        this._width = Math.max(OVERLAY_MIN_WIDTH, (_a = this._trigger) === null || _a === void 0 ? void 0 : _a.nativeElement.getBoundingClientRect().width);
        this._isOpen = true;
        this.listItems = this.options.slice().sort(sortSelectedToTop);
        this._divider = this.selectedItems.size - 1;
        this._openedBy = origin;
        this._cdr.markForCheck();
    }
    _close() {
        var _a;
        this._isOpen = false;
        this._updateTooltipText();
        (_a = this._trigger) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();
    }
    _onSelect(item, selected) {
        if (selected) {
            this.selectedItems.add(item);
        }
        else {
            this.selectedItems.delete(item);
        }
        this._onChange(this.value);
        this.selectionChange.emit(this.value);
    }
    _onKeydown($event) {
        var _a;
        if (!this._isOpen || this.disabled) {
            return;
        }
        const key = $event.key;
        if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'Home' || key === 'End') {
            this._keyManager.onKeydown($event);
            this._scrollActiveOptionIntoView();
            $event.preventDefault();
        }
        if ((window.navigator.platform.match('Mac') ? $event.metaKey : $event.ctrlKey) && key === 'a') {
            this._onSelectAll();
            $event.preventDefault();
        }
        if (key === 'Tab') {
            this._keyManager.onKeydown($event);
        }
        if (key === 'Enter' || (this._filterValue.trim() === '' && key === ' ')) {
            (_a = this._keyManager.activeItem) === null || _a === void 0 ? void 0 : _a.selectViaInteraction();
            $event.preventDefault();
        }
    }
    _onTriggerBlur() {
        this._onTouched();
    }
    _onFocusWithinOverlay($event) {
        // Keeps focus on the filter when clicking around in the overlay
        if (this._filterInput && $event.target !== this._filterInput.nativeElement) {
            this._filterInput.nativeElement.focus();
        }
    }
    _getAriaActiveDescendant() {
        if (this._keyManager.activeItem) {
            return this._keyManager.activeItem.id;
        }
        return null;
    }
    _onFilterChange(query) {
        var _a;
        if (query) {
            this.listItems = this.options.filter(item => this.filterFn(query, this._selectLabel(item)));
        }
        else {
            this.listItems = this.options.slice();
        }
        if (this._isActiveItemFiltered) {
            setTimeout(() => {
                this._keyManager.setFirstItemActive();
            });
        }
        (_a = this._optionsList) === null || _a === void 0 ? void 0 : _a.nativeElement.scrollTo(0, 0);
    }
    _getValueText() {
        return this.options
            .filter(option => this.selectedItems.has(option))
            .map(option => this._selectLabel(option))
            .join(', ');
    }
    _onAttach() {
        var _a;
        (_a = this._overlayDir) === null || _a === void 0 ? void 0 : _a.positionChange.pipe(take(1)).subscribe(() => {
            var _a, _b;
            const overlayRef = this._overlayDir.overlayRef;
            const positionStrategy = overlayRef.getConfig().positionStrategy;
            this._updatePositions();
            positionStrategy.withPositions(this._positions);
            overlayRef.updatePosition();
            (_a = this._filterInput) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();
            (_b = this._panelContent) === null || _b === void 0 ? void 0 : _b.nativeElement.focus();
            if (this._openedBy === 'keyboard') {
                this._keyManager.setFirstItemActive();
                this._scrollActiveOptionIntoView();
            }
            this._cdr.markForCheck();
        });
    }
    _onDetach() {
        this._close();
    }
    _onSelectAll() {
        if (this._allSelected) {
            this.selectedItems.clear();
        }
        else {
            this.listItems.filter(option => !this._isDisabled(option)).forEach(option => this.selectedItems.add(option));
        }
        this._onChange(this.value);
        this.selectionChange.emit(this.value);
    }
    _clear() {
        this.selectedItems.clear();
        this._onChange(this.value);
        this.selectionChange.emit(this.value);
    }
    _clearFilter() {
        this._filterValue = '';
        this._onFilterChange(this._filterValue);
    }
    writeValue(value) {
        this.selectedItems.clear();
        if (Array.isArray(value)) {
            for (const item of value) {
                const selectedItem = this.options.find(option => this._selectValue(option) === item);
                if (selectedItem) {
                    this.selectedItems.add(selectedItem);
                }
                else {
                    console.warn('NxMultiSelect: Model contains value that does not exist in given options', item);
                }
            }
        }
        this._cdr.markForCheck();
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    ngDoCheck() {
        if (this.ngControl) {
            this.updateErrorState();
        }
    }
    updateErrorState() {
        const oldState = this.errorState;
        const parent = this._parentFormGroup || this._parentForm;
        const control = this.ngControl ? this.ngControl.control : null;
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    _updateTooltipText() {
        if (!this._trigger) {
            return;
        }
        const [label, suffix, icon] = this._trigger.nativeElement.children;
        const { paddingLeft, paddingRight } = getComputedStyle(this._trigger.nativeElement);
        const triggerContentWidth = this._trigger.nativeElement.clientWidth - parseInt(paddingLeft, 10) - parseInt(paddingRight, 10);
        if (triggerContentWidth - suffix.offsetWidth - icon.offsetWidth <= label.offsetWidth) {
            this._tooltipText = this._getValueText();
        }
        else {
            this._tooltipText = '';
        }
    }
    _scrollActiveOptionIntoView() {
        var _a;
        if (!this._keyManager.activeItem) {
            return;
        }
        const activeItem = this._keyManager.activeItem.elementRef.nativeElement;
        const list = (_a = this._optionsList) === null || _a === void 0 ? void 0 : _a.nativeElement;
        const listTopScrollPosition = list.scrollTop;
        const listHeight = list.clientHeight;
        const itemTop = activeItem.offsetTop;
        const itemBottom = activeItem.offsetTop + activeItem.offsetHeight;
        // item half or less visible on top
        if (itemTop < listTopScrollPosition) {
            list.scrollTop = itemTop;
            // item half or less visible on bottom
        }
        else if (itemBottom > listTopScrollPosition + listHeight) {
            list.scrollTop = itemBottom - listHeight;
        }
    }
    _initKeyManager() {
        this._keyManager = new ActiveDescendantKeyManager(this._options)
            .withHomeAndEnd()
            .withVerticalOrientation()
            .withHorizontalOrientation('ltr')
            .skipPredicate(item => item.disabled);
        this._keyManager.tabOut.pipe(takeUntil(this._destroyed)).subscribe(() => this._close());
    }
}
_NxMultiSelectComponent_disableSelectAll = new WeakMap(), _NxMultiSelectComponent_filterFn = new WeakMap();
NxMultiSelectComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMultiSelectComponent, deps: [{ token: NxDropdownIntl }, { token: i0.ElementRef }, { token: i2$1.ErrorStateMatcher }, { token: i0.ChangeDetectorRef }, { token: i3$1.NxFormfieldComponent, optional: true }, { token: i4$1.NgControl, optional: true, self: true }, { token: i4$1.NgForm, optional: true }, { token: i4$1.FormGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxMultiSelectComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxMultiSelectComponent, selector: "nx-multi-select", inputs: { required: "required", disabled: "disabled", readonly: "readonly", placeholder: "placeholder", filter: "filter", disableSelectAll: "disableSelectAll", filterFn: "filterFn", options: "options", filterPlaceholder: "filterPlaceholder", selectValue: "selectValue", selectLabel: "selectLabel", selectDisabled: "selectDisabled" }, outputs: { selectionChange: "selectionChange" }, host: { properties: { "class.is-open": "this._isOpen" } }, providers: [{ provide: NxFormfieldControl, useExisting: NxMultiSelectComponent }], viewQueries: [{ propertyName: "_panelContent", first: true, predicate: ["panelContent"], descendants: true }, { propertyName: "_filterInput", first: true, predicate: ["filterInput"], descendants: true }, { propertyName: "_optionsList", first: true, predicate: ["itemsList"], descendants: true }, { propertyName: "_trigger", first: true, predicate: ["trigger"], descendants: true }, { propertyName: "_panelHeader", first: true, predicate: ["panelHeader"], descendants: true }, { propertyName: "_overlayDir", first: true, predicate: CdkConnectedOverlay, descendants: true, static: true }, { propertyName: "_options", predicate: NxMultiSelectOptionComponent, descendants: true }], ngImport: i0, template: "<div\n    [nxTooltip]=\"_tooltipText\"\n    class=\"value\"\n    (click)=\"_open($event, 'mouse')\"\n    (keydown.enter)=\"_open($event, 'keyboard')\"\n    (keydown.space)=\"_open($event, 'keyboard')\"\n    cdkOverlayOrigin\n    #trigger\n    #origin=\"cdkOverlayOrigin\"\n    role=\"combobox\"\n    tabindex=\"0\"\n    aria-haspopup=\"listbox\"\n    [attr.aria-controls]=\"_comboboxId\"\n    (blur)=\"_onTriggerBlur(); _inputFocused = false\"\n    [attr.aria-expanded]=\"_isOpen\"\n    [attr.aria-labelledby]=\"_getAriaLabelledBy()\"\n    [id]=\"id\"\n    (focus)=\"disabled ? null : (_inputFocused = true)\"\n    (keydown)=\"_onKeydown($event)\"\n>\n    <span class=\"value-text\">{{ empty ? placeholder : _getValueText() }}</span>\n    <span>{{ selectedItems.size ? '(' + selectedItems.size + ')' : '' }}</span>\n    <nx-icon size=\"s\" aria-hidden=\"true\" class=\"indicator\" name=\"chevron-down\"></nx-icon>\n</div>\n<ng-template\n    cdkConnectedOverlay\n    cdkConnectedOverlayHasBackdrop\n    cdkConnectedOverlayPush\n    cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n    [cdkConnectedOverlayPositions]=\"_positions\"\n    [cdkConnectedOverlayWidth]=\"_width\"\n    [cdkConnectedOverlayOrigin]=\"origin\"\n    [cdkConnectedOverlayOpen]=\"_isOpen\"\n    (overlayOutsideClick)=\"_close()\"\n    (attach)=\"_onAttach()\"\n    (detach)=\"_onDetach()\"\n>\n    <div\n        class=\"panel\"\n        [class.is-outline]=\"_isOutline\"\n        (keydown)=\"_onKeydown($event)\"\n        [attr.aria-owns]=\"_comboboxId\"\n        aria-expanded=\"true\"\n        (focusin)=\"_onFocusWithinOverlay($event)\"\n        role=\"combobox\"\n        [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n        tabindex=\"-1\"\n        [attr.aria-labelledby]=\"_getAriaLabelledBy()\"\n        #panelContent\n    >\n        <div *ngIf=\"!_isOutline && _overlayLabel\" class=\"panel-header\" #panelHeader>\n            {{ _overlayLabel }}\n        </div>\n        <div *ngIf=\"filter\" class=\"filter-wrapper\">\n            <nx-formfield class=\"filter\" appearance=\"auto\">\n                <input\n                    nxInput\n                    #filterInput\n                    [(ngModel)]=\"_filterValue\"\n                    (ngModelChange)=\"_onFilterChange($event)\"\n                    [placeholder]=\"filterPlaceholder\"\n                    autocomplete=\"off\"\n                    [attr.aria-controls]=\"_comboboxId\"\n                    [attr.aria-labelledby]=\"_getAriaLabelledBy()\"\n                    [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n                />\n                <nx-icon\n                    aria-hidden=\"true\"\n                    nxFormfieldSuffix\n                    [class.hidden]=\"!_filterValue.length\"\n                    class=\"clear\"\n                    (click)=\"_clearFilter()\"\n                    name=\"close\"\n                ></nx-icon>\n            </nx-formfield>\n        </div>\n        <div class=\"item actions\" *ngIf=\"_isOutline && !disableSelectAll\">\n            <nx-checkbox [ngModel]=\"_allSelected\" (ngModelChange)=\"_onSelectAll()\" [indeterminate]=\"_someSelected\"> {{ _intl.selectAll }} </nx-checkbox>\n            <button type=\"button\" nxPlainButton (click)=\"_clear()\" [disabled]=\"selectedItems.size === 0\"> {{ _intl.clearAll }} </button>\n        </div>\n        <div class=\"items\" #itemsList [id]=\"_comboboxId\" role=\"listbox\" aria-multiselectable=\"true\">\n            <nx-multi-select-option\n                *ngFor=\"let option of listItems; let i = index\"\n                class=\"item\"\n                [class.divider]=\"_divider === i\"\n                (selectedChange)=\"_onSelect(option, $event)\"\n                [value]=\"_selectValue(option)\"\n                [label]=\"_selectLabel(option)\"\n                [selected]=\"this.selectedItems.has(option)\"\n                [disabled]=\"this._isDisabled(option)\"\n                [appearance]=\"_appearance\"\n            ></nx-multi-select-option>\n        </div>\n    </div>\n</ng-template>\n", styles: [":host{display:block;width:100%;height:100%}.panel{width:100%;box-shadow:var(--shadow-small);border-radius:4px;background:var(--ui-01)}.panel.is-outline .filter{--formfield-label-height: 8px;--formfield-bottom-padding: 8px}.panel.is-outline .items{padding-bottom:8px;max-height:200px}.value{display:grid;align-items:center;width:100%;height:100%;max-width:100%;grid-template-columns:auto -webkit-min-content -webkit-min-content;grid-template-columns:auto min-content min-content;cursor:pointer}.value:focus{outline:none}.value::-moz-focus-inner{border:0}:host-context(.nx-formfield.is-disabled) .value{cursor:not-allowed}.value-text{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;padding-right:8px}.panel-header{font-size:var(--formfield-label-font-size);line-height:var(--formfield-label-line-height);font-weight:var(--formfield-label-font-weight);letter-spacing:var(--formfield-label-letter-spacing);color:var(--dropdown-panel-header-text-color);background-color:var(--dropdown-panel-header-background-color);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px}.label span:nth-child(2){font-weight:600;margin-left:auto;padding-right:12px;flex:0 0 auto}.indicator{transform:rotate(0)}:host(.is-open) .indicator{transform:rotate(180deg)}.items{list-style:none;max-height:272px;overflow-y:auto;position:relative;padding:12px 32px}.filter-wrapper{padding:0 32px}.filter{width:100%}.border{padding-top:8px;margin-top:8px;border-top:1px solid lightgrey}.toggle{width:100%;display:block}.actions{display:flex;justify-content:space-between;white-space:nowrap;padding:8px 32px}.clear{cursor:pointer}.hidden{display:none}.divider{border-bottom:1px solid var(--dropdown-item-divider);margin-bottom:8px;padding-bottom:16px}\n"], components: [{ type: i3.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }, { type: i3$1.NxFormfieldComponent, selector: "nx-formfield", inputs: ["nxLabel", "nxFloatLabel", "nxStyle", "appearance"] }, { type: i2.NxCheckboxComponent, selector: "nx-checkbox", inputs: ["id", "name", "disabled", "labelSize", "negative", "checked", "indeterminate", "required", "value"], outputs: ["indeterminateChange", "checkedChange", "checkboxChange"] }, { type: i7.NxPlainButtonComponent, selector: "button[nxPlainButton]", inputs: ["nxPlainButton", "disabled"] }, { type: NxMultiSelectOptionComponent, selector: "nx-multi-select-option", inputs: ["appearance", "value", "label", "selected", "disabled"], outputs: ["selectedChange"] }], directives: [{ type: i8.CdkOverlayOrigin, selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]", exportAs: ["cdkOverlayOrigin"] }, { type: i5.NxTooltipDirective, selector: "[nxTooltip]", inputs: ["nxTooltipPosition", "nxTooltipDisabled", "nxTooltipSelectable", "nxTooltipShowDelay", "nxTooltipHideDelay", "nxTooltip"], exportAs: ["nxTooltip"] }, { type: i8.CdkConnectedOverlay, selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]", inputs: ["cdkConnectedOverlayOrigin", "cdkConnectedOverlayPositions", "cdkConnectedOverlayPositionStrategy", "cdkConnectedOverlayOffsetX", "cdkConnectedOverlayOffsetY", "cdkConnectedOverlayWidth", "cdkConnectedOverlayHeight", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayMinHeight", "cdkConnectedOverlayBackdropClass", "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayViewportMargin", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOpen", "cdkConnectedOverlayDisableClose", "cdkConnectedOverlayTransformOriginOn", "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayLockPosition", "cdkConnectedOverlayFlexibleDimensions", "cdkConnectedOverlayGrowAfterOpen", "cdkConnectedOverlayPush"], outputs: ["backdropClick", "positionChange", "attach", "detach", "overlayKeydown", "overlayOutsideClick"], exportAs: ["cdkConnectedOverlay"] }, { type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i12.NxInputDirective, selector: "input[nxInput], textarea[nxInput], select[nxInput]", inputs: ["nxAriaLabel", "id", "value", "readonly", "disabled", "required", "type", "placeholder"], exportAs: ["nxInput"] }, { type: i4$1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i4$1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i4$1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i3$1.NxFormfieldSuffixDirective, selector: "[nxFormfieldSuffix]" }, { type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMultiSelectComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-multi-select', providers: [{ provide: NxFormfieldControl, useExisting: NxMultiSelectComponent }], changeDetection: ChangeDetectionStrategy.OnPush, template: "<div\n    [nxTooltip]=\"_tooltipText\"\n    class=\"value\"\n    (click)=\"_open($event, 'mouse')\"\n    (keydown.enter)=\"_open($event, 'keyboard')\"\n    (keydown.space)=\"_open($event, 'keyboard')\"\n    cdkOverlayOrigin\n    #trigger\n    #origin=\"cdkOverlayOrigin\"\n    role=\"combobox\"\n    tabindex=\"0\"\n    aria-haspopup=\"listbox\"\n    [attr.aria-controls]=\"_comboboxId\"\n    (blur)=\"_onTriggerBlur(); _inputFocused = false\"\n    [attr.aria-expanded]=\"_isOpen\"\n    [attr.aria-labelledby]=\"_getAriaLabelledBy()\"\n    [id]=\"id\"\n    (focus)=\"disabled ? null : (_inputFocused = true)\"\n    (keydown)=\"_onKeydown($event)\"\n>\n    <span class=\"value-text\">{{ empty ? placeholder : _getValueText() }}</span>\n    <span>{{ selectedItems.size ? '(' + selectedItems.size + ')' : '' }}</span>\n    <nx-icon size=\"s\" aria-hidden=\"true\" class=\"indicator\" name=\"chevron-down\"></nx-icon>\n</div>\n<ng-template\n    cdkConnectedOverlay\n    cdkConnectedOverlayHasBackdrop\n    cdkConnectedOverlayPush\n    cdkConnectedOverlayBackdropClass=\"cdk-overlay-transparent-backdrop\"\n    [cdkConnectedOverlayPositions]=\"_positions\"\n    [cdkConnectedOverlayWidth]=\"_width\"\n    [cdkConnectedOverlayOrigin]=\"origin\"\n    [cdkConnectedOverlayOpen]=\"_isOpen\"\n    (overlayOutsideClick)=\"_close()\"\n    (attach)=\"_onAttach()\"\n    (detach)=\"_onDetach()\"\n>\n    <div\n        class=\"panel\"\n        [class.is-outline]=\"_isOutline\"\n        (keydown)=\"_onKeydown($event)\"\n        [attr.aria-owns]=\"_comboboxId\"\n        aria-expanded=\"true\"\n        (focusin)=\"_onFocusWithinOverlay($event)\"\n        role=\"combobox\"\n        [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n        tabindex=\"-1\"\n        [attr.aria-labelledby]=\"_getAriaLabelledBy()\"\n        #panelContent\n    >\n        <div *ngIf=\"!_isOutline && _overlayLabel\" class=\"panel-header\" #panelHeader>\n            {{ _overlayLabel }}\n        </div>\n        <div *ngIf=\"filter\" class=\"filter-wrapper\">\n            <nx-formfield class=\"filter\" appearance=\"auto\">\n                <input\n                    nxInput\n                    #filterInput\n                    [(ngModel)]=\"_filterValue\"\n                    (ngModelChange)=\"_onFilterChange($event)\"\n                    [placeholder]=\"filterPlaceholder\"\n                    autocomplete=\"off\"\n                    [attr.aria-controls]=\"_comboboxId\"\n                    [attr.aria-labelledby]=\"_getAriaLabelledBy()\"\n                    [attr.aria-activedescendant]=\"_getAriaActiveDescendant()\"\n                />\n                <nx-icon\n                    aria-hidden=\"true\"\n                    nxFormfieldSuffix\n                    [class.hidden]=\"!_filterValue.length\"\n                    class=\"clear\"\n                    (click)=\"_clearFilter()\"\n                    name=\"close\"\n                ></nx-icon>\n            </nx-formfield>\n        </div>\n        <div class=\"item actions\" *ngIf=\"_isOutline && !disableSelectAll\">\n            <nx-checkbox [ngModel]=\"_allSelected\" (ngModelChange)=\"_onSelectAll()\" [indeterminate]=\"_someSelected\"> {{ _intl.selectAll }} </nx-checkbox>\n            <button type=\"button\" nxPlainButton (click)=\"_clear()\" [disabled]=\"selectedItems.size === 0\"> {{ _intl.clearAll }} </button>\n        </div>\n        <div class=\"items\" #itemsList [id]=\"_comboboxId\" role=\"listbox\" aria-multiselectable=\"true\">\n            <nx-multi-select-option\n                *ngFor=\"let option of listItems; let i = index\"\n                class=\"item\"\n                [class.divider]=\"_divider === i\"\n                (selectedChange)=\"_onSelect(option, $event)\"\n                [value]=\"_selectValue(option)\"\n                [label]=\"_selectLabel(option)\"\n                [selected]=\"this.selectedItems.has(option)\"\n                [disabled]=\"this._isDisabled(option)\"\n                [appearance]=\"_appearance\"\n            ></nx-multi-select-option>\n        </div>\n    </div>\n</ng-template>\n", styles: [":host{display:block;width:100%;height:100%}.panel{width:100%;box-shadow:var(--shadow-small);border-radius:4px;background:var(--ui-01)}.panel.is-outline .filter{--formfield-label-height: 8px;--formfield-bottom-padding: 8px}.panel.is-outline .items{padding-bottom:8px;max-height:200px}.value{display:grid;align-items:center;width:100%;height:100%;max-width:100%;grid-template-columns:auto -webkit-min-content -webkit-min-content;grid-template-columns:auto min-content min-content;cursor:pointer}.value:focus{outline:none}.value::-moz-focus-inner{border:0}:host-context(.nx-formfield.is-disabled) .value{cursor:not-allowed}.value-text{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;padding-right:8px}.panel-header{font-size:var(--formfield-label-font-size);line-height:var(--formfield-label-line-height);font-weight:var(--formfield-label-font-weight);letter-spacing:var(--formfield-label-letter-spacing);color:var(--dropdown-panel-header-text-color);background-color:var(--dropdown-panel-header-background-color);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px}.label span:nth-child(2){font-weight:600;margin-left:auto;padding-right:12px;flex:0 0 auto}.indicator{transform:rotate(0)}:host(.is-open) .indicator{transform:rotate(180deg)}.items{list-style:none;max-height:272px;overflow-y:auto;position:relative;padding:12px 32px}.filter-wrapper{padding:0 32px}.filter{width:100%}.border{padding-top:8px;margin-top:8px;border-top:1px solid lightgrey}.toggle{width:100%;display:block}.actions{display:flex;justify-content:space-between;white-space:nowrap;padding:8px 32px}.clear{cursor:pointer}.hidden{display:none}.divider{border-bottom:1px solid var(--dropdown-item-divider);margin-bottom:8px;padding-bottom:16px}\n"] }]
        }], ctorParameters: function () {
        return [{ type: NxDropdownIntl }, { type: i0.ElementRef }, { type: i2$1.ErrorStateMatcher }, { type: i0.ChangeDetectorRef }, { type: i3$1.NxFormfieldComponent, decorators: [{
                        type: Optional
                    }] }, { type: i4$1.NgControl, decorators: [{
                        type: Optional
                    }, {
                        type: Self
                    }] }, { type: i4$1.NgForm, decorators: [{
                        type: Optional
                    }] }, { type: i4$1.FormGroupDirective, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { required: [{
                type: Input
            }], disabled: [{
                type: Input
            }], readonly: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], filter: [{
                type: Input
            }], disableSelectAll: [{
                type: Input
            }], filterFn: [{
                type: Input
            }], _options: [{
                type: ViewChildren,
                args: [NxMultiSelectOptionComponent]
            }], _panelContent: [{
                type: ViewChild,
                args: ['panelContent']
            }], _filterInput: [{
                type: ViewChild,
                args: ['filterInput']
            }], _optionsList: [{
                type: ViewChild,
                args: ['itemsList']
            }], _trigger: [{
                type: ViewChild,
                args: ['trigger']
            }], _panelHeader: [{
                type: ViewChild,
                args: ['panelHeader']
            }], _overlayDir: [{
                type: ViewChild,
                args: [CdkConnectedOverlay, { static: true }]
            }], selectionChange: [{
                type: Output
            }], options: [{
                type: Input
            }], filterPlaceholder: [{
                type: Input
            }], selectValue: [{
                type: Input
            }], selectLabel: [{
                type: Input
            }], selectDisabled: [{
                type: Input
            }], _isOpen: [{
                type: HostBinding,
                args: ['class.is-open']
            }] } });

class NxDropdownModule {
}
NxDropdownModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxDropdownModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownModule, declarations: [NxDropdownComponent,
        NxDropdownItemComponent,
        NxDropdownGroupComponent,
        NxDropdownClosedLabelDirective,
        NxMultiSelectComponent,
        NxMultiSelectOptionComponent], imports: [CommonModule,
        NxFormfieldModule,
        NxCheckboxModule,
        OverlayModule,
        A11yModule,
        NxIconModule,
        ObserversModule,
        FormsModule,
        NxTooltipModule,
        NxButtonModule,
        NxInputModule], exports: [NxDropdownComponent, NxDropdownItemComponent, NxDropdownGroupComponent, NxDropdownClosedLabelDirective, NxMultiSelectComponent] });
NxDropdownModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownModule, providers: [NxDropdownIntl, NX_DROPDOWN_SCROLL_STRATEGY_PROVIDER], imports: [[
            CommonModule,
            NxFormfieldModule,
            NxCheckboxModule,
            OverlayModule,
            A11yModule,
            NxIconModule,
            ObserversModule,
            FormsModule,
            NxTooltipModule,
            NxButtonModule,
            NxInputModule,
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDropdownModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        CommonModule,
                        NxFormfieldModule,
                        NxCheckboxModule,
                        OverlayModule,
                        A11yModule,
                        NxIconModule,
                        ObserversModule,
                        FormsModule,
                        NxTooltipModule,
                        NxButtonModule,
                        NxInputModule,
                    ],
                    declarations: [
                        NxDropdownComponent,
                        NxDropdownItemComponent,
                        NxDropdownGroupComponent,
                        NxDropdownClosedLabelDirective,
                        NxMultiSelectComponent,
                        NxMultiSelectOptionComponent,
                    ],
                    providers: [NxDropdownIntl, NX_DROPDOWN_SCROLL_STRATEGY_PROVIDER],
                    exports: [NxDropdownComponent, NxDropdownItemComponent, NxDropdownGroupComponent, NxDropdownClosedLabelDirective, NxMultiSelectComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NX_DROPDOWN_SCROLL_STRATEGY, NX_DROPDOWN_SCROLL_STRATEGY_PROVIDER, NX_DROPDOWN_SCROLL_STRATEGY_PROVIDER_FACTORY, NxDropdownClosedLabelDirective, NxDropdownComponent, NxDropdownGroupComponent, NxDropdownIntl, NxDropdownItemChange, NxDropdownItemComponent, NxDropdownModule, NxDropdownSelectChange, NxMultiSelectComponent, NxMultiSelectOptionComponent };
//# sourceMappingURL=aposin-ng-aquila-dropdown.mjs.map
