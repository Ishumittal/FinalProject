import { coerceBooleanProperty } from '@angular/cdk/coercion';
import * as i1 from '@angular/cdk/platform';
import { getSupportedInputTypes } from '@angular/cdk/platform';
import * as i0 from '@angular/core';
import { InjectionToken, Directive, Optional, Self, Inject, Input, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { NxFormfieldControl, NxFormfieldModule } from '@aposin/ng-aquila/formfield';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as i2 from '@angular/forms';
import * as i3 from '@aposin/ng-aquila/utils';
import * as i4 from '@angular/cdk/text-field';
import { CommonModule } from '@angular/common';
import * as i2$1 from '@aposin/ng-aquila/icon';
import { NxIconModule } from '@aposin/ng-aquila/icon';
import { ENTER, SPACE } from '@angular/cdk/keycodes';
import * as i1$1 from '@angular/cdk/a11y';

const NX_INPUT_VALUE_ACCESSOR = new InjectionToken('NX_INPUT_VALUE_ACCESSOR');
const INVALID_TYPES = ['button', 'checkbox', 'file', 'hidden', 'image', 'radio', 'range', 'reset', 'submit'];
const NEVER_EMPTY = ['date', 'datetime', 'datetime-local', 'month', 'time', 'week'].filter(t => getSupportedInputTypes().has(t));
let nextUniqueId = 0;
class NxInputDirective {
    constructor(_elementRef, _platform, 
    /** @docs-private */ ngControl, _parentForm, _parentFormGroup, _errorStateMatcher, inputValueAccessor, _autofillMonitor) {
        this._elementRef = _elementRef;
        this._platform = _platform;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._errorStateMatcher = _errorStateMatcher;
        this._autofillMonitor = _autofillMonitor;
        this._type = 'text';
        this._uid = `nx-input-${nextUniqueId++}`;
        this._disabled = false;
        this._required = false;
        this._readonly = false;
        /** @docs-private */
        this.errorState = false;
        /**
         * Name of this control that is used inside the formfield component
         * @docs-private
         */
        this.controlType = 'nx-input';
        /**
         * @docs-private
         */
        this.autofilled = false;
        /** @docs-private */
        this.stateChanges = new Subject();
        /** @docs-private */
        this.focused = false;
        this._destroyed = new Subject();
        const id = this.id;
        this.id = id; // invoke setter
        // This will enable other directives to plugin itself as the value accessor
        // by using the NX_INPUT_VALUE_ACCESSOR Token. Default is the given input field.
        // TODO eliminate injected dateValueAccessor once we have intra-package support in ng-packagr
        // See the datefield for details.
        this._inputValueAccessor = inputValueAccessor || this._elementRef.nativeElement;
        this._previousNativeValue = this.value;
        if (this._elementRef.nativeElement.nodeName.toLowerCase() === 'textarea') {
            this.controlType = 'textarea';
        }
    }
    /** The id of the input. */
    get id() {
        return this._id;
    }
    set id(value) {
        this._id = value || this._uid;
    }
    /** The input element's value. */
    get value() {
        return this._inputValueAccessor.value;
    }
    set value(value) {
        if (value !== this.value) {
            this._inputValueAccessor.value = value;
        }
    }
    /** Whether the element is readonly. */
    get readonly() {
        return this._readonly;
    }
    set readonly(value) {
        this._readonly = coerceBooleanProperty(value);
        this.stateChanges.next();
    }
    /** Whether the input is disabled. */
    get disabled() {
        var _a;
        if (((_a = this.ngControl) === null || _a === void 0 ? void 0 : _a.disabled) != null) {
            return this.ngControl.disabled;
        }
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        // Browsers may not fire the blur event if the input is disabled too quickly.
        // Reset from here to ensure that the element doesn't become stuck.
        if (this.focused) {
            this.focused = false;
            this.stateChanges.next();
        }
    }
    /** Whether the element is required. */
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = coerceBooleanProperty(value);
    }
    /** Sets the type of the input element (e.g. password, text etc). */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value || 'text';
        this._validateType();
        // When using Angular inputs, developers are no longer able to set the properties on the native
        // input element. To ensure that bindings for `type` work, we need to sync the setter
        // with the native property. Textarea elements don't support the type property or attribute.
        if (!this._isTextarea() && getSupportedInputTypes().has(this._type)) {
            this._elementRef.nativeElement.type = this._type;
        }
    }
    /**
     * Sets the text for the input placeholder
     */
    get placeholder() {
        return this.empty ? this._placeholder : '';
    }
    set placeholder(value) {
        this._placeholder = value;
    }
    ngOnInit() {
        if (this._platform.isBrowser) {
            this._autofillMonitor
                .monitor(this._elementRef.nativeElement)
                .pipe(takeUntil(this._destroyed))
                .subscribe(event => {
                this.autofilled = event.isAutofilled;
                this.stateChanges.next();
            });
        }
    }
    /** @docs-private */
    get elementRef() {
        return this._elementRef;
    }
    _onInput() {
        // force to to run change detection so we know about changes in the native form input
    }
    _focusChanged(isFocused) {
        if (isFocused !== this.focused && !this.readonly) {
            this.focused = isFocused;
            this.stateChanges.next();
        }
    }
    ngOnChanges() {
        this.stateChanges.next();
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this.stateChanges.complete();
        if (this._platform.isBrowser) {
            this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement);
        }
    }
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
        // We need to dirty-check the native element's value, because there are some cases where
        // we won't be notified when it changes (e.g. the consumer isn't using forms or they're
        // updating the value using `emitEvent: false`).
        this._dirtyCheckNativeValue();
    }
    /** @docs-private */
    updateErrorState() {
        const oldState = this.errorState;
        const parent = this._parentFormGroup || this._parentForm;
        const control = this.ngControl ? this.ngControl.control : null;
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this.stateChanges.next();
        }
    }
    /**
     * Set a list of ids that is currently describing this input
     * (if you have hints and errors for example).
     */
    setDescribedByIds(ids) {
        this._ariaDescribedby = ids.join(' ');
    }
    // allow to set a arial label value in case there
    // is not possibility to display a proper label
    /**
     * Method to set the aria label.
     * This is required if you use the input outside of a formfield
     * where you don't have a label connected.
     */
    setAriaLabel(value) {
        this._ariaLabel = value;
    }
    _isBadInput() {
        // The `validity` property won't be present on platform-server.
        const validity = this._elementRef.nativeElement.validity;
        return validity === null || validity === void 0 ? void 0 : validity.badInput;
    }
    /** @docs-private */
    get empty() {
        return !this._isNeverEmpty() && !this._elementRef.nativeElement.value && !this._isBadInput() && !this.autofilled;
    }
    _isNeverEmpty() {
        return NEVER_EMPTY.includes(this._type);
    }
    _isTextarea() {
        const nativeElement = this._elementRef.nativeElement;
        return nativeElement.nodeName ? nativeElement.nodeName.toLowerCase() === 'textarea' : false;
    }
    _validateType() {
        if (INVALID_TYPES.includes(this._type)) {
            throw new Error(`Input of type '${this._type}' is not supported`);
        }
    }
    /** @docs-private */
    get shouldLabelFloat() {
        return !!(this.focused || !this.empty || (this.placeholder && this.placeholder.length > 0));
    }
    _dirtyCheckNativeValue() {
        const newValue = this.value;
        if (this._previousNativeValue !== newValue) {
            this._previousNativeValue = newValue;
            this.stateChanges.next();
        }
    }
}
NxInputDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxInputDirective, deps: [{ token: i0.ElementRef }, { token: i1.Platform }, { token: i2.NgControl, optional: true, self: true }, { token: i2.NgForm, optional: true }, { token: i2.FormGroupDirective, optional: true }, { token: i3.ErrorStateMatcher }, { token: NX_INPUT_VALUE_ACCESSOR, optional: true, self: true }, { token: i4.AutofillMonitor }], target: i0.ɵɵFactoryTarget.Directive });
NxInputDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxInputDirective, selector: "input[nxInput], textarea[nxInput], select[nxInput]", inputs: { _ariaLabel: ["nxAriaLabel", "_ariaLabel"], id: "id", value: "value", readonly: "readonly", disabled: "disabled", required: "required", type: "type", placeholder: "placeholder" }, host: { listeners: { "blur": "_focusChanged(false)", "focus": "_focusChanged(true)", "input": "_onInput()" }, properties: { "class.c-input": "true", "class.nx-input": "true", "attr.id": "id", "class.is-filled": "empty === false", "class.is-disabled": "disabled", "class.has-error": "errorState", "class.is-focused": "focused", "attr.disabled": "disabled || null", "attr.readonly": "readonly || null", "attr.required": "required || null", "attr.aria-label": "_ariaLabel || null", "attr.aria-describedby": "_ariaDescribedby || null", "attr.aria-invalid": "errorState", "attr.aria-required": "required.toString()", "attr.placeholder": "placeholder || null" } }, providers: [{ provide: NxFormfieldControl, useExisting: NxInputDirective }], exportAs: ["nxInput"], usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxInputDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[nxInput], textarea[nxInput], select[nxInput]',
                    exportAs: 'nxInput',
                    host: {
                        '[class.c-input]': 'true',
                        '[class.nx-input]': 'true',
                        '[attr.id]': 'id',
                        '[class.is-filled]': 'empty === false',
                        '[class.is-disabled]': 'disabled',
                        '[class.has-error]': 'errorState',
                        '[class.is-focused]': 'focused',
                        '[attr.disabled]': 'disabled || null',
                        '[attr.readonly]': 'readonly || null',
                        '[attr.required]': 'required || null',
                        '[attr.aria-label]': '_ariaLabel || null',
                        '[attr.aria-describedby]': '_ariaDescribedby || null',
                        '[attr.aria-invalid]': 'errorState',
                        '[attr.aria-required]': 'required.toString()',
                        '[attr.placeholder]': 'placeholder || null',
                        '(blur)': '_focusChanged(false)',
                        '(focus)': '_focusChanged(true)',
                        '(input)': '_onInput()',
                    },
                    providers: [{ provide: NxFormfieldControl, useExisting: NxInputDirective }],
                }]
        }], ctorParameters: function () {
        return [{ type: i0.ElementRef }, { type: i1.Platform }, { type: i2.NgControl, decorators: [{
                        type: Optional
                    }, {
                        type: Self
                    }] }, { type: i2.NgForm, decorators: [{
                        type: Optional
                    }] }, { type: i2.FormGroupDirective, decorators: [{
                        type: Optional
                    }] }, { type: i3.ErrorStateMatcher }, { type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Self
                    }, {
                        type: Inject,
                        args: [NX_INPUT_VALUE_ACCESSOR]
                    }] }, { type: i4.AutofillMonitor }];
    }, propDecorators: { _ariaLabel: [{
                type: Input,
                args: ['nxAriaLabel']
            }], id: [{
                type: Input
            }], value: [{
                type: Input
            }], readonly: [{
                type: Input
            }], disabled: [{
                type: Input
            }], required: [{
                type: Input
            }], type: [{
                type: Input
            }], placeholder: [{
                type: Input
            }] } });

const visibilityIcons = {
    show: 'password-show-o',
    hide: 'password-hide-o',
};
class NxPasswordToggleComponent {
    constructor(_cdr, _elementRef, _focusMonitor) {
        this._cdr = _cdr;
        this._elementRef = _elementRef;
        this._focusMonitor = _focusMonitor;
        /** @docs-private */
        this._currentIcon = visibilityIcons['show'];
        /** @docs-private */
        this._pressed = false;
        this._ariaLabel = 'Show password';
        this._focusMonitor.monitor(this._elementRef);
    }
    /** Sets the aria-label needed for accessibility.
     * Notice that this `aria-label` should describe the initial action according to the status of the visibility.
     * E.g if you have an `input[type=password]` at the beginning then the
     * password will be hidden and the correct aria-label would be 'Show password.'
     */
    set ariaLabel(value) {
        if (value !== this._ariaLabel) {
            this._ariaLabel = value;
            this._cdr.markForCheck();
        }
    }
    get ariaLabel() {
        return this._ariaLabel;
    }
    ngAfterViewInit() {
        if (!this.control) {
            console.warn('You need to pass an input as a control to the password toggle.');
            return;
        }
        // show the right icon according to the initial type of the input
        this._currentIcon = this.control.type === 'password' ? visibilityIcons['show'] : visibilityIcons['hide'];
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    /** Toggles the type of the input. */
    toggleInputType() {
        if (this.control) {
            this.control.type = this.control.type === 'password' ? 'text' : 'password';
            this._pressed = !this._pressed;
            this.toggleIcon();
            this._cdr.markForCheck();
        }
    }
    /** @docs-private */
    toggleIcon() {
        this._currentIcon = this._currentIcon === visibilityIcons['show'] ? visibilityIcons['hide'] : visibilityIcons['show'];
    }
    /** @docs-private */
    _onKeydown($event) {
        if ($event && ($event.keyCode === ENTER || $event.keyCode === SPACE)) {
            this.toggleInputType();
        }
    }
    /** @docs-private */
    get tabindex() {
        if (this.control) {
            return this.control.disabled ? -1 : 0;
        }
        return null;
    }
}
NxPasswordToggleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPasswordToggleComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i1$1.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxPasswordToggleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxPasswordToggleComponent, selector: "nx-password-toggle", inputs: { control: "control", ariaLabel: "ariaLabel" }, host: { attributes: { "role": "button" }, listeners: { "click": "toggleInputType()", "keydown": "_onKeydown($event)" }, properties: { "attr.aria-label": "ariaLabel", "attr.tabindex": "tabindex", "attr.aria-pressed": "_pressed" } }, ngImport: i0, template: `<nx-icon aria-hidden="true" [name]="_currentIcon"> </nx-icon>`, isInline: true, styles: [":host{position:relative;display:inline-block;height:24px;width:24px;cursor:pointer}@media screen and (-ms-high-contrast: active){:host{color:buttonText!important}}:host:focus{outline:none}:host:hover{color:var(--hover-primary)}:host.cdk-keyboard-focused ::ng-deep nx-icon{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host.cdk-keyboard-focused ::ng-deep nx-icon{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host-context(.is-disabled){pointer-events:none}@media screen and (-ms-high-contrast: active){:host-context(.is-disabled){color:GrayText!important}}\n"], components: [{ type: i2$1.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPasswordToggleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-password-toggle', template: `<nx-icon aria-hidden="true" [name]="_currentIcon"> </nx-icon>`, host: {
                        '[attr.aria-label]': 'ariaLabel',
                        '[attr.tabindex]': 'tabindex',
                        '[attr.aria-pressed]': '_pressed',
                        role: 'button',
                        '(click)': 'toggleInputType()',
                        '(keydown)': '_onKeydown($event)',
                    }, changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{position:relative;display:inline-block;height:24px;width:24px;cursor:pointer}@media screen and (-ms-high-contrast: active){:host{color:buttonText!important}}:host:focus{outline:none}:host:hover{color:var(--hover-primary)}:host.cdk-keyboard-focused ::ng-deep nx-icon{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host.cdk-keyboard-focused ::ng-deep nx-icon{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host-context(.is-disabled){pointer-events:none}@media screen and (-ms-high-contrast: active){:host-context(.is-disabled){color:GrayText!important}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i1$1.FocusMonitor }]; }, propDecorators: { control: [{
                type: Input
            }], ariaLabel: [{
                type: Input
            }] } });

class NxInputModule {
}
NxInputModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxInputModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxInputModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxInputModule, declarations: [NxInputDirective, NxPasswordToggleComponent], imports: [CommonModule, NxFormfieldModule, NxIconModule], exports: [NxFormfieldModule, NxInputDirective, NxPasswordToggleComponent] });
NxInputModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxInputModule, imports: [[CommonModule, NxFormfieldModule, NxIconModule], NxFormfieldModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxInputModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NxFormfieldModule, NxIconModule],
                    declarations: [NxInputDirective, NxPasswordToggleComponent],
                    exports: [NxFormfieldModule, NxInputDirective, NxPasswordToggleComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NX_INPUT_VALUE_ACCESSOR, NxInputDirective, NxInputModule, NxPasswordToggleComponent };
//# sourceMappingURL=aposin-ng-aquila-input.mjs.map
