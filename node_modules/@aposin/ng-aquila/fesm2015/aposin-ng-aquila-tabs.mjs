import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import * as i0 from '@angular/core';
import { Directive, TemplateRef, Component, ChangeDetectionStrategy, Inject, Optional, Host, ContentChild, ViewChild, Input, ViewContainerRef, InjectionToken, EventEmitter, Output, ContentChildren, ViewChildren, forwardRef, SkipSelf, NgModule } from '@angular/core';
import { Subject, Subscription, merge } from 'rxjs';
import { CdkPortal, PortalModule } from '@angular/cdk/portal';
import { takeUntil } from 'rxjs/operators';
import * as i2 from '@angular/cdk/a11y';
import { FocusKeyManager } from '@angular/cdk/a11y';
import * as i6 from '@aposin/ng-aquila/accordion';
import { NxAccordionDirective, NxExpansionPanelComponent, NxAccordionModule } from '@aposin/ng-aquila/accordion';
import * as i1$1 from '@aposin/ng-aquila/utils';
import { NxBreakpoints } from '@aposin/ng-aquila/utils';
import { SPACE, ENTER, END, HOME } from '@angular/cdk/keycodes';
import * as i1 from '@angular/cdk/bidi';
import * as i3 from '@aposin/ng-aquila/button';
import { NxButtonModule } from '@aposin/ng-aquila/button';
import * as i4 from '@aposin/ng-aquila/icon';
import { NxIconModule } from '@aposin/ng-aquila/icon';
import * as i7 from '@angular/common';
import { CommonModule } from '@angular/common';

/** Decorates the `ng-template` tags and reads out the template from it. */
class NxTabContentDirective {
    constructor(/** @docs-private */ template) {
        this.template = template;
    }
}
NxTabContentDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabContentDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
NxTabContentDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTabContentDirective, selector: "[nxTabContent]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabContentDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[nxTabContent]' }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; } });

/** @docs-private */
class NxTabGroupBase {
}
NxTabGroupBase.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabGroupBase, deps: [], target: i0.ɵɵFactoryTarget.Directive });
NxTabGroupBase.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTabGroupBase, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabGroupBase, decorators: [{
            type: Directive
        }] });

/** @docs-private */
class NxTabLabelDirective extends CdkPortal {
}
NxTabLabelDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabLabelDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NxTabLabelDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTabLabelDirective, selector: "[nxTabLabel]", usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabLabelDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[nxTabLabel]' }]
        }] });

class NxTabComponent {
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._disabled = false;
        /** Emits whenever the internal state of the tab changes. */
        this._stateChanges = new Subject();
        /**
         * Whether the tab is currently active.
         */
        this.isActive = false;
        if (!this._tabGroup) {
            throw Error(`The nx-tab element has to be wrapped in a nx-tab-group to work.
      Please provide a nx-tab-group element and place your tabs inside it.`);
        }
    }
    /**
     * Content for the tab label given by `<ng-template nxTabLabel>`.
     * @docs-private
     * */
    get templateLabel() {
        return this._templateLabel;
    }
    set templateLabel(value) {
        // Only update the templateLabel via query if there is actually
        // a nxTabLabel found. This works around an issue where a user may have
        // manually set `templateLabel` during creation mode, which would then get clobbered
        // by `undefined` when this query resolves.
        if (value) {
            this._templateLabel = value;
        }
    }
    /** Sets the label of the tab shown in the tablist. */
    get label() {
        return this._label;
    }
    set label(value) {
        if (this._label !== value) {
            this._label = value;
        }
    }
    /** Sets the tab to disabled. */
    get disabled() {
        var _a;
        return ((_a = this._tabGroup) === null || _a === void 0 ? void 0 : _a.disabled) || this._disabled;
    }
    set disabled(value) {
        const coercedValue = coerceBooleanProperty(value);
        if (this._disabled !== coercedValue) {
            this._disabled = coercedValue;
        }
    }
    /** @docs-private */
    get headerViewRef() {
        return this._headerViewRef;
    }
    /** @docs-private */
    get contentViewRef() {
        // for lazy loading we only create the viewref when it is asked for
        if (!this._contentViewRef) {
            const contentTemplate = this._explicitContent || this._implicitContent;
            this._contentViewRef = contentTemplate.createEmbeddedView({});
        }
        return this._contentViewRef;
    }
    ngOnChanges(changes) {
        if ({}.hasOwnProperty.call(changes, 'label') || {}.hasOwnProperty.call(changes, 'disabled')) {
            this._stateChanges.next();
        }
    }
    ngAfterContentInit() {
        if (this.templateLabel) {
            this._headerViewRef = this.templateLabel.createEmbeddedView({});
        }
    }
    ngOnDestroy() {
        this._stateChanges.complete();
        this._contentViewRef.destroy();
        if (this._headerViewRef) {
            this._headerViewRef.destroy();
        }
    }
}
NxTabComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabComponent, deps: [{ token: NxTabGroupBase, host: true, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxTabComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTabComponent, selector: "nx-tab", inputs: { label: "label", disabled: "disabled" }, queries: [{ propertyName: "templateLabel", first: true, predicate: NxTabLabelDirective, descendants: true, read: TemplateRef, static: true }, { propertyName: "_explicitContent", first: true, predicate: NxTabContentDirective, descendants: true, read: TemplateRef, static: true }], viewQueries: [{ propertyName: "_implicitContent", first: true, predicate: TemplateRef, descendants: true, static: true }], exportAs: ["nxTab"], usesOnChanges: true, ngImport: i0, template: "<ng-template><ng-content></ng-content></ng-template>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tab', exportAs: 'nxTab', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-template><ng-content></ng-content></ng-template>\n" }]
        }], ctorParameters: function () {
        return [{ type: NxTabGroupBase, decorators: [{
                        type: Inject,
                        args: [NxTabGroupBase]
                    }, {
                        type: Optional
                    }, {
                        type: Host
                    }] }];
    }, propDecorators: { templateLabel: [{
                type: ContentChild,
                args: [NxTabLabelDirective, { read: TemplateRef, static: true }]
            }], _implicitContent: [{
                type: ViewChild,
                args: [TemplateRef, { static: true }]
            }], _explicitContent: [{
                type: ContentChild,
                args: [NxTabContentDirective, { read: TemplateRef, static: true }]
            }], label: [{
                type: Input
            }], disabled: [{
                type: Input
            }] } });

/** @docs-private */
class NxTabBodyComponent {
    constructor(_tabGroup, _focusMonitor, _elementRef) {
        this._tabGroup = _tabGroup;
        this._focusMonitor = _focusMonitor;
        this._elementRef = _elementRef;
        this._active = false;
        this._destroyed = new Subject();
        this._focusMonitor.monitor(this._elementRef);
    }
    set active(value) {
        this._active = coerceBooleanProperty(value);
    }
    get active() {
        return this._active;
    }
    ngOnInit() {
        this._tabGroup._appearanceChange.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this.detach();
        });
    }
    ngOnChanges(changes) {
        if ('active' in changes) {
            const change = changes.active;
            if (change.currentValue) {
                this.attach();
            }
            else {
                this.detach();
            }
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    attach() {
        this._outlet.insert(this.tab.contentViewRef);
    }
    detach() {
        const index = this._outlet.indexOf(this.tab.contentViewRef);
        if (index !== -1) {
            this._outlet.detach(index);
        }
    }
}
NxTabBodyComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabBodyComponent, deps: [{ token: NxTabGroupBase }, { token: i2.FocusMonitor }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
NxTabBodyComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTabBodyComponent, selector: "nx-tab-body", inputs: { tab: "tab", active: "active" }, viewQueries: [{ propertyName: "_outlet", first: true, predicate: ["outlet"], descendants: true, read: ViewContainerRef, static: true }], usesOnChanges: true, ngImport: i0, template: "<ng-container #outlet></ng-container>\n", styles: [":host{display:block}:host:focus{outline:none}:host.cdk-keyboard-focused{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabBodyComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tab-body', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container #outlet></ng-container>\n", styles: [":host{display:block}:host:focus{outline:none}:host.cdk-keyboard-focused{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}\n"] }]
        }], ctorParameters: function () { return [{ type: NxTabGroupBase }, { type: i2.FocusMonitor }, { type: i0.ElementRef }]; }, propDecorators: { _outlet: [{
                type: ViewChild,
                args: ['outlet', { static: true, read: ViewContainerRef }]
            }], tab: [{
                type: Input
            }], active: [{
                type: Input
            }] } });

const TAB_GROUP_DEFAULT_OPTIONS = new InjectionToken('TAB_GROUP_DEFAULT_OPTIONS');
const TAB_NAV_BAR_DEFAULT_OPTIONS = new InjectionToken('TAB_NAV_BAR_DEFAULT_OPTIONS');

const SPACE_BETWEEN_TABS = 32;
const START_BUTTON_WIDTH = 40;
/** @docs-private */
class NxScrollableTabBar {
    constructor(_cdr, _dir, _element) {
        var _a;
        this._cdr = _cdr;
        this._dir = _dir;
        this._element = _element;
        this._isScrolledToStart = true;
        this._isScrolledToEnd = true;
        this._destroyed = new Subject();
        this._scrollHandler = (event) => {
            this._updateScrollButtons();
        };
        (_a = this._dir) === null || _a === void 0 ? void 0 : _a.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
            var _a, _b;
            if (((_a = this.scrollableTabsList) === null || _a === void 0 ? void 0 : _a.nativeElement.scrollLeft) !== 0) {
                const absoluteScrollLeft = Math.abs((_b = this.scrollableTabsList) === null || _b === void 0 ? void 0 : _b.nativeElement.scrollLeft);
                setTimeout(() => {
                    this.scrollableTabsList.nativeElement.scrollLeft = this.direction === 'ltr' ? absoluteScrollLeft : -absoluteScrollLeft;
                });
            }
        });
    }
    ngAfterContentInit() {
        this.tabButtons.changes.pipe(takeUntil(this._destroyed)).subscribe(() => setTimeout(() => this._updateScrollButtons()));
        setTimeout(() => {
            this.scrollableTabsList.nativeElement.addEventListener('scroll', this._scrollHandler);
            this._updateScrollButtons();
        });
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    get direction() {
        var _a;
        return ((_a = this._dir) === null || _a === void 0 ? void 0 : _a.value) || 'ltr';
    }
    get scrollable() {
        return !this._isScrolledToStart || !this._isScrolledToEnd;
    }
    scrollToStart() {
        const scrollListElement = this.scrollableTabsList.nativeElement;
        const tabsListWidth = scrollListElement.getBoundingClientRect().width;
        const headerScrollPosition = Math.abs(scrollListElement.scrollLeft);
        let lastVisiblePosition = 0;
        let itemToScrollTo;
        for (let i = 0; i < scrollListElement.children.length; i++) {
            const currentChildWidth = scrollListElement.children[i].getBoundingClientRect().width;
            const currentChildStartsBeforeLeftEdge = lastVisiblePosition < headerScrollPosition;
            const currentChildFullyVisible = currentChildStartsBeforeLeftEdge && lastVisiblePosition + currentChildWidth >= headerScrollPosition;
            const currentChildNotFullyVisible = currentChildStartsBeforeLeftEdge && lastVisiblePosition + currentChildWidth < headerScrollPosition;
            const nextChildFullyVisible = lastVisiblePosition + currentChildWidth + SPACE_BETWEEN_TABS >= headerScrollPosition;
            if (currentChildFullyVisible || (currentChildNotFullyVisible && nextChildFullyVisible)) {
                // add width of current child. This is now the point which has to be visible on the right side:
                lastVisiblePosition += currentChildWidth;
                itemToScrollTo = i;
                break;
            }
            else {
                // current and next child are fully visible: continue
                lastVisiblePosition += currentChildWidth + SPACE_BETWEEN_TABS;
            }
        }
        // now go back to start one by one and find the item most to the start where the lastVisibleItem is still fully visible
        let newPosition = lastVisiblePosition;
        for (let i = itemToScrollTo; i >= 0; i--) {
            const currentChildWidth = scrollListElement.children[i].getBoundingClientRect().width;
            const previousChildWidth = i > 0 ? scrollListElement.children[i - 1].getBoundingClientRect().width : 0;
            const currentChildFitsInWidth = lastVisiblePosition - (newPosition - currentChildWidth) <= tabsListWidth;
            const previousChildFitsInWidth = lastVisiblePosition - (newPosition - currentChildWidth - SPACE_BETWEEN_TABS - previousChildWidth) <= tabsListWidth;
            if (!previousChildWidth) {
                this._scrollTabListTo(0);
                return;
            }
            else if (currentChildWidth > tabsListWidth || (currentChildFitsInWidth && !previousChildFitsInWidth)) {
                // found item where scrolling should be starting: beginning of currentChild
                newPosition -= currentChildWidth;
                this._scrollTabListTo(this.direction === 'ltr' ? newPosition : -newPosition);
                return;
            }
            // current and previous child fit: continue
            newPosition -= currentChildWidth + SPACE_BETWEEN_TABS;
        }
    }
    scrollToEnd() {
        const scrollListElement = this.scrollableTabsList.nativeElement;
        const tabsListWidth = scrollListElement.getBoundingClientRect().width;
        const headerScrollPosition = Math.abs(scrollListElement.scrollLeft);
        let newPosition = 0;
        for (let i = 0; i < scrollListElement.children.length; i++) {
            const currentChildWidth = scrollListElement.children[i].getBoundingClientRect().width;
            const nextChildWidth = i < scrollListElement.children.length - 1 ? scrollListElement.children[i + 1].getBoundingClientRect().width : 0;
            const currentChildFullyVisible = newPosition + currentChildWidth <= headerScrollPosition + tabsListWidth;
            const nextChildFullyVisible = newPosition + currentChildWidth + SPACE_BETWEEN_TABS + nextChildWidth <= headerScrollPosition + tabsListWidth;
            const currentChildHalfVisible = currentChildWidth - START_BUTTON_WIDTH + SPACE_BETWEEN_TABS + nextChildWidth > tabsListWidth;
            if (currentChildFullyVisible && !nextChildFullyVisible) {
                // current item is the one to scroll to (minus space for scrollStartButton)
                // calculate: if nextChild is too long and does not fit fully in header, then the next child should be the first one visible
                if (Math.abs(headerScrollPosition - Math.round(newPosition + currentChildWidth + SPACE_BETWEEN_TABS)) <= 2) {
                    // it is already scrolled to the nextChild, but nextChild is longer than whole tabsListWidth => scroll to nextNextChild
                    // this is done if the current scrollLeft Position is ~ the start of nextChild
                    newPosition += currentChildWidth + SPACE_BETWEEN_TABS + nextChildWidth + SPACE_BETWEEN_TABS;
                }
                else if (currentChildHalfVisible) {
                    // if currentItem is half visible, the nextItem would be not fully visible
                    // => new scroll position: show nextItem right after scrollToStart button
                    newPosition += currentChildWidth + SPACE_BETWEEN_TABS;
                }
                else {
                    // else: currentItem should be half visible, scrollToStart button is covering half of it
                    newPosition += START_BUTTON_WIDTH;
                }
                this._scrollTabListTo(this.direction === 'ltr' ? newPosition : -newPosition);
                return;
            }
            // current and next element are fully visible: add width of current element and continue
            newPosition += currentChildWidth + SPACE_BETWEEN_TABS;
        }
    }
    _updateScrollButtons() {
        var _a, _b;
        const scrollListElement = this.scrollableTabsList.nativeElement;
        if (Math.round(this._element.nativeElement.getBoundingClientRect().width) >= scrollListElement.scrollWidth) {
            // not scrollable
            if (!this._isScrolledToStart || !this._isScrolledToEnd) {
                this._isScrolledToStart = true;
                this._isScrolledToEnd = true;
                this._cdr.markForCheck();
            }
            return;
        }
        // scrollable
        if (((_a = this.scrollableTabsList) === null || _a === void 0 ? void 0 : _a.nativeElement.scrollLeft) === 0 && !this._isScrolledToStart) {
            this._isScrolledToStart = true;
            this._cdr.markForCheck();
        }
        else if (((_b = this.scrollableTabsList) === null || _b === void 0 ? void 0 : _b.nativeElement.scrollLeft) !== 0 && this._isScrolledToStart) {
            this._isScrolledToStart = false;
            this._cdr.markForCheck();
        }
        const scrollRight = Math.round(Math.abs(scrollListElement.scrollLeft) + scrollListElement.getBoundingClientRect().width);
        if (scrollRight === scrollListElement.scrollWidth && !this._isScrolledToEnd) {
            this._isScrolledToEnd = true;
            this._cdr.markForCheck();
        }
        else if (scrollRight !== scrollListElement.scrollWidth && this._isScrolledToEnd) {
            this._isScrolledToEnd = false;
            this._cdr.markForCheck();
        }
    }
    _scrollTabListTo(scrollLeft) {
        var _a, _b;
        if (typeof ((_a = this.scrollableTabsList) === null || _a === void 0 ? void 0 : _a.nativeElement.scrollTo) === 'function') {
            (_b = this.scrollableTabsList) === null || _b === void 0 ? void 0 : _b.nativeElement.scrollTo({ left: scrollLeft, behavior: 'smooth' });
        }
        else {
            // scrollTo() is not defined on IE
            this.scrollableTabsList.nativeElement.scrollLeft = scrollLeft;
        }
    }
}
NxScrollableTabBar.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxScrollableTabBar, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.Directionality, optional: true }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NxScrollableTabBar.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxScrollableTabBar, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxScrollableTabBar, decorators: [{
            type: Directive
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i1.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: i0.ElementRef }];
    } });

/** @docs-private */
class NxTabLabelWrapperDirective {
    constructor(elementRef) {
        this.elementRef = elementRef;
        this._disabled = false;
    }
    /** Whether the tab group is disabled. Default: false. */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (this.disabled !== newValue) {
            this._disabled = newValue;
        }
    }
    focus() {
        this.elementRef.nativeElement.focus();
    }
}
NxTabLabelWrapperDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabLabelWrapperDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NxTabLabelWrapperDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTabLabelWrapperDirective, selector: "[nxTabLabelWrapper]", inputs: { disabled: "disabled" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabLabelWrapperDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[nxTabLabelWrapper]' }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { disabled: [{
                type: Input
            }] } });

class NxTabScrollIndicator {
    constructor(_cdr, _viewportService, _dir) {
        var _a;
        this._cdr = _cdr;
        this._viewportService = _viewportService;
        this._dir = _dir;
        this._view = 'desktop';
        this.buttonClicked = new EventEmitter();
        this._destroyed = new Subject();
        this._viewportService
            .min(NxBreakpoints.BREAKPOINT_MEDIUM)
            .pipe(takeUntil(this._destroyed))
            .subscribe(isGreaterThanMedium => {
            if (isGreaterThanMedium) {
                this._view = 'desktop';
            }
            else if (!isGreaterThanMedium) {
                this._view = 'mobile';
            }
            this._cdr.markForCheck();
        });
        (_a = this._dir) === null || _a === void 0 ? void 0 : _a.change.pipe(takeUntil(this._destroyed)).subscribe(() => this._cdr.markForCheck());
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    get direction() {
        var _a;
        return ((_a = this._dir) === null || _a === void 0 ? void 0 : _a.value) || 'ltr';
    }
    getChevronName() {
        if ((this.scrollDirection === 'start' && this.direction === 'ltr') || (this.scrollDirection === 'end' && this.direction === 'rtl')) {
            return 'chevron-left';
        }
        return 'chevron-right';
    }
    scroll() {
        this.buttonClicked.emit();
    }
}
NxTabScrollIndicator.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabScrollIndicator, deps: [{ token: i0.ChangeDetectorRef }, { token: i1$1.NxViewportService }, { token: i1.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxTabScrollIndicator.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTabScrollIndicator, selector: "nx-tab-scroll-indicator", inputs: { scrollDirection: "scrollDirection", isScrolledToStart: "isScrolledToStart", isScrolledToEnd: "isScrolledToEnd" }, outputs: { buttonClicked: "buttonClicked" }, host: { properties: { "class.start-button": "scrollDirection === \"start\"", "class.end-button": "scrollDirection === \"end\"", "class.is-desktop-button": "_view === \"desktop\"", "class.is-mobile": "_view === \"mobile\"", "class.is-scrolled-to-start": "isScrolledToStart", "class.is-scrolled-to-end": "isScrolledToEnd" } }, ngImport: i0, template: "<div class=\"nx-tab-scroll-indicator__divider\"></div>\n<button nxPlainButton aria-hidden=\"true\" type=\"button\" *ngIf=\"_view === 'desktop'\" (click)=\"scroll()\">\n    <nx-icon [name]=\"getChevronName()\"></nx-icon>\n</button>\n", styles: [":host{position:relative;border-color:var(--tab-item-border-color);border-bottom-width:1px;border-bottom-style:solid;flex:0 0 auto;height:44px}:host .nx-tab-scroll-indicator__divider{width:1px;height:32px;background:var(--tab-item-border-color);position:absolute;top:4px}:host.start-button.is-scrolled-to-start .nx-tab-scroll-indicator__divider,:host.end-button.is-scrolled-to-end .nx-tab-scroll-indicator__divider{display:none}:host.start-button.is-scrolled-to-start button,:host.end-button.is-scrolled-to-end button{display:none}:host.is-desktop-button{padding:8px 8px 10px;width:40px}:host.is-desktop-button.start-button.is-scrolled-to-start{display:none}:host.is-desktop-button button{vertical-align:bottom}:host.is-desktop-button.start-button .nx-tab-scroll-indicator__divider{right:0}[dir=rtl] :host.is-desktop-button.start-button .nx-tab-scroll-indicator__divider{right:auto;right:initial;left:0}:host.is-desktop-button.end-button .nx-tab-scroll-indicator__divider{left:0}[dir=rtl] :host.is-desktop-button.end-button .nx-tab-scroll-indicator__divider{left:auto;left:initial;right:0}:host.is-mobile{width:16px}:host.is-mobile.start-button:not(.is-scrolled-to-start) .nx-tab-scroll-indicator__divider{right:0}[dir=rtl] :host.is-mobile.start-button:not(.is-scrolled-to-start) .nx-tab-scroll-indicator__divider{right:auto;right:initial;left:0}:host.is-mobile.end-button:not(.is-scrolled-to-end) .nx-tab-scroll-indicator__divider{left:0}[dir=rtl] :host.is-mobile.end-button:not(.is-scrolled-to-end) .nx-tab-scroll-indicator__divider{left:auto;left:initial;right:0}:host-context(nx-tab-group.is-expert),:host-context(nx-tab-nav-bar.is-expert){border-bottom:none;height:40px}:host-context(nx-tab-group.is-expert) .nx-tab-scroll-indicator__divider,:host-context(nx-tab-nav-bar.is-expert) .nx-tab-scroll-indicator__divider{height:24px;top:8px}:host-context(nx-tab-group.is-negative) button,:host-context(nx-tab-nav-bar.is-negative) button{color:var(--negative)}\n"], components: [{ type: i3.NxPlainButtonComponent, selector: "button[nxPlainButton]", inputs: ["nxPlainButton", "disabled"] }, { type: i4.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabScrollIndicator, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tab-scroll-indicator', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class.start-button]': 'scrollDirection === "start"',
                        '[class.end-button]': 'scrollDirection === "end"',
                        '[class.is-desktop-button]': '_view === "desktop"',
                        '[class.is-mobile]': '_view === "mobile"',
                        '[class.is-scrolled-to-start]': 'isScrolledToStart',
                        '[class.is-scrolled-to-end]': 'isScrolledToEnd',
                    }, template: "<div class=\"nx-tab-scroll-indicator__divider\"></div>\n<button nxPlainButton aria-hidden=\"true\" type=\"button\" *ngIf=\"_view === 'desktop'\" (click)=\"scroll()\">\n    <nx-icon [name]=\"getChevronName()\"></nx-icon>\n</button>\n", styles: [":host{position:relative;border-color:var(--tab-item-border-color);border-bottom-width:1px;border-bottom-style:solid;flex:0 0 auto;height:44px}:host .nx-tab-scroll-indicator__divider{width:1px;height:32px;background:var(--tab-item-border-color);position:absolute;top:4px}:host.start-button.is-scrolled-to-start .nx-tab-scroll-indicator__divider,:host.end-button.is-scrolled-to-end .nx-tab-scroll-indicator__divider{display:none}:host.start-button.is-scrolled-to-start button,:host.end-button.is-scrolled-to-end button{display:none}:host.is-desktop-button{padding:8px 8px 10px;width:40px}:host.is-desktop-button.start-button.is-scrolled-to-start{display:none}:host.is-desktop-button button{vertical-align:bottom}:host.is-desktop-button.start-button .nx-tab-scroll-indicator__divider{right:0}[dir=rtl] :host.is-desktop-button.start-button .nx-tab-scroll-indicator__divider{right:auto;right:initial;left:0}:host.is-desktop-button.end-button .nx-tab-scroll-indicator__divider{left:0}[dir=rtl] :host.is-desktop-button.end-button .nx-tab-scroll-indicator__divider{left:auto;left:initial;right:0}:host.is-mobile{width:16px}:host.is-mobile.start-button:not(.is-scrolled-to-start) .nx-tab-scroll-indicator__divider{right:0}[dir=rtl] :host.is-mobile.start-button:not(.is-scrolled-to-start) .nx-tab-scroll-indicator__divider{right:auto;right:initial;left:0}:host.is-mobile.end-button:not(.is-scrolled-to-end) .nx-tab-scroll-indicator__divider{left:0}[dir=rtl] :host.is-mobile.end-button:not(.is-scrolled-to-end) .nx-tab-scroll-indicator__divider{left:auto;left:initial;right:0}:host-context(nx-tab-group.is-expert),:host-context(nx-tab-nav-bar.is-expert){border-bottom:none;height:40px}:host-context(nx-tab-group.is-expert) .nx-tab-scroll-indicator__divider,:host-context(nx-tab-nav-bar.is-expert) .nx-tab-scroll-indicator__divider{height:24px;top:8px}:host-context(nx-tab-group.is-negative) button,:host-context(nx-tab-nav-bar.is-negative) button{color:var(--negative)}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i1$1.NxViewportService }, { type: i1.Directionality, decorators: [{
                        type: Optional
                    }] }];
    }, propDecorators: { scrollDirection: [{
                type: Input
            }], isScrolledToStart: [{
                type: Input
            }], isScrolledToEnd: [{
                type: Input
            }], buttonClicked: [{
                type: Output
            }] } });

/** @docs-private */
class NxTabHeaderComponent extends NxScrollableTabBar {
    constructor(_cdr, _dir, _tabGroup, _element) {
        super(_cdr, _dir, _element);
        this._cdr = _cdr;
        this._tabGroup = _tabGroup;
        this._selectedIndex = 0;
        this._autoselect = true;
        this.selectFocusedIndex = new EventEmitter();
        this.indexFocused = new EventEmitter();
    }
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(value) {
        this._selectedIndex = value;
        if (this._keyManager) {
            this._keyManager.updateActiveItem(value);
        }
    }
    get focusIndex() {
        return this._keyManager ? this._keyManager.activeItemIndex : 0;
    }
    set focusIndex(value) {
        if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {
            return;
        }
        this._keyManager.setActiveItem(value);
    }
    get autoselect() {
        return this._autoselect;
    }
    set autoselect(value) {
        this._autoselect = value;
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        this._keyManager = new FocusKeyManager(this.labels).withHorizontalOrientation('ltr').withWrap();
        this._keyManager.updateActiveItem(0);
        this._cdr.markForCheck();
    }
    _isValidIndex(idx) {
        if (!this.labels) {
            return true;
        }
        const tab = this.labels.toArray()[idx] || null;
        return !!tab && !tab.disabled;
    }
    /**
     * Handles keyboard inputs on the labels
     * If autoselect is enabled the tab gets changed immediately
     * If autoselect is disabled only the focus changes but the user still has to select the item
     * by himself
     */
    handleKeydown(event) {
        switch (event.keyCode) {
            case HOME:
                this._keyManager.setFirstItemActive();
                event.preventDefault();
                break;
            case END:
                this._keyManager.setLastItemActive();
                event.preventDefault();
                break;
            case ENTER:
            case SPACE:
                this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
                event.preventDefault();
                break;
            default:
                this._keyManager.onKeydown(event);
        }
        if (this.autoselect) {
            this.selectFocusedIndex.emit(this._keyManager.activeItemIndex);
        }
        else if (event.keyCode !== ENTER && event.keyCode !== SPACE) {
            this.indexFocused.emit(this._keyManager.activeItemIndex);
        }
    }
}
NxTabHeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabHeaderComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.Directionality, optional: true }, { token: NxTabGroupBase, optional: true }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
NxTabHeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTabHeaderComponent, selector: "nx-tab-header", inputs: { selectedIndex: "selectedIndex", autoselect: "autoselect" }, outputs: { selectFocusedIndex: "selectFocusedIndex", indexFocused: "indexFocused" }, host: { properties: { "class.at-start": "_isScrolledToStart", "class.scrollable": "scrollable" } }, queries: [{ propertyName: "tabButtons", predicate: ["tabButton"] }, { propertyName: "labels", predicate: NxTabLabelWrapperDirective }], viewQueries: [{ propertyName: "scrollableTabsList", first: true, predicate: ["tabsList"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<nx-tab-scroll-indicator *ngIf=\"scrollable\" scrollDirection=\"start\" [isScrolledToStart]=\"_isScrolledToStart\" (buttonClicked)=\"scrollToStart()\">\n</nx-tab-scroll-indicator>\n<div #tabsList class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\" tabindex=\"-1\">\n    <ng-content></ng-content>\n</div>\n<nx-tab-scroll-indicator *ngIf=\"scrollable\" scrollDirection=\"end\" [isScrolledToEnd]=\"_isScrolledToEnd\" (buttonClicked)=\"scrollToEnd()\">\n</nx-tab-scroll-indicator>\n", styles: [":host{display:flex;justify-content:center}:host .nx-tab-header{display:flex;align-items:flex-end;overflow-x:scroll;position:relative;outline:none;-ms-overflow-style:none;scrollbar-width:none}:host .nx-tab-header::-webkit-scrollbar{display:none}:host.at-start .nx-tab-header{margin-left:-8px;padding-left:8px}[dir=rtl] :host.at-start .nx-tab-header{margin-left:0;padding-left:0;margin-right:-8px;padding-right:8px}:host:not(.scrollable) .nx-tab-header{margin-right:-8px;padding-right:8px}[dir=rtl] :host:not(.scrollable) .nx-tab-header{margin-right:0;padding-right:0;margin-left:-8px;padding-left:8px}:host-context(nx-tab-group.is-expert){justify-content:flex-start;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:var(--tab-expert-bottom-border-color)}:host-context(nx-tab-group.is-expert) .nx-tab-header{width:100%}\n"], components: [{ type: NxTabScrollIndicator, selector: "nx-tab-scroll-indicator", inputs: ["scrollDirection", "isScrolledToStart", "isScrolledToEnd"], outputs: ["buttonClicked"] }], directives: [{ type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabHeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tab-header', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class.at-start]': '_isScrolledToStart',
                        '[class.scrollable]': 'scrollable',
                    }, template: "<nx-tab-scroll-indicator *ngIf=\"scrollable\" scrollDirection=\"start\" [isScrolledToStart]=\"_isScrolledToStart\" (buttonClicked)=\"scrollToStart()\">\n</nx-tab-scroll-indicator>\n<div #tabsList class=\"nx-tab-header\" (keydown)=\"handleKeydown($event)\" role=\"tablist\" tabindex=\"-1\">\n    <ng-content></ng-content>\n</div>\n<nx-tab-scroll-indicator *ngIf=\"scrollable\" scrollDirection=\"end\" [isScrolledToEnd]=\"_isScrolledToEnd\" (buttonClicked)=\"scrollToEnd()\">\n</nx-tab-scroll-indicator>\n", styles: [":host{display:flex;justify-content:center}:host .nx-tab-header{display:flex;align-items:flex-end;overflow-x:scroll;position:relative;outline:none;-ms-overflow-style:none;scrollbar-width:none}:host .nx-tab-header::-webkit-scrollbar{display:none}:host.at-start .nx-tab-header{margin-left:-8px;padding-left:8px}[dir=rtl] :host.at-start .nx-tab-header{margin-left:0;padding-left:0;margin-right:-8px;padding-right:8px}:host:not(.scrollable) .nx-tab-header{margin-right:-8px;padding-right:8px}[dir=rtl] :host:not(.scrollable) .nx-tab-header{margin-right:0;padding-right:0;margin-left:-8px;padding-left:8px}:host-context(nx-tab-group.is-expert){justify-content:flex-start;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:var(--tab-expert-bottom-border-color)}:host-context(nx-tab-group.is-expert) .nx-tab-header{width:100%}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i1.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: NxTabGroupBase, decorators: [{
                        type: Optional
                    }] }, { type: i0.ElementRef }];
    }, propDecorators: { scrollableTabsList: [{
                type: ViewChild,
                args: ['tabsList']
            }], tabButtons: [{
                type: ContentChildren,
                args: ['tabButton']
            }], selectedIndex: [{
                type: Input
            }], autoselect: [{
                type: Input
            }], selectFocusedIndex: [{
                type: Output
            }], indexFocused: [{
                type: Output
            }], labels: [{
                type: ContentChildren,
                args: [NxTabLabelWrapperDirective]
            }] } });

/** @docs-private */
class NxTabHeaderOutletComponent {
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._destroyed = new Subject();
    }
    ngOnInit() {
        this._tabGroup._appearanceChange.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this.detach();
        });
        this.attach();
    }
    attach() {
        this._outlet.insert(this.content);
    }
    detach() {
        const index = this._outlet.indexOf(this.content);
        if (index !== -1) {
            this._outlet.detach(index);
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
}
NxTabHeaderOutletComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabHeaderOutletComponent, deps: [{ token: NxTabGroupBase }], target: i0.ɵɵFactoryTarget.Component });
NxTabHeaderOutletComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTabHeaderOutletComponent, selector: "nx-tab-header-outlet", inputs: { content: "content" }, viewQueries: [{ propertyName: "_outlet", first: true, predicate: ["outlet"], descendants: true, read: ViewContainerRef, static: true }], ngImport: i0, template: '<ng-container #outlet></ng-container>', isInline: true });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabHeaderOutletComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nx-tab-header-outlet',
                    template: '<ng-container #outlet></ng-container>',
                }]
        }], ctorParameters: function () { return [{ type: NxTabGroupBase }]; }, propDecorators: { _outlet: [{
                type: ViewChild,
                args: ['outlet', { static: true, read: ViewContainerRef }]
            }], content: [{
                type: Input
            }] } });

class NxTabChangeEvent {
}
let nextId = 0;
class NxTabGroupComponent {
    constructor(viewportService, _cdr, _defaultOptions, _focusMonitor) {
        this.viewportService = viewportService;
        this._cdr = _cdr;
        this._defaultOptions = _defaultOptions;
        this._focusMonitor = _focusMonitor;
        this._selectedIndex = null;
        this._negative = false;
        this._disabled = false;
        this._indexToSelect = 0;
        this._autoselect = true;
        this._mobileAccordion = true;
        this._showAccordion = false;
        /** An event emitted when the selected tab has changed. */
        this.selectedIndexChange = new EventEmitter();
        /** An event emitted when the selected tab has changed. */
        this.selectedTabChange = new EventEmitter();
        /**
         * An event emitted when focus has changed within a tab group.
         *
         * **Note:** is not supported in mobile view.
         */
        this.focusChange = new EventEmitter();
        /** Subscription to changes in the tab labels. */
        this._tabLabelSubscription = Subscription.EMPTY;
        this._disabledTabsCache = [];
        this._appearanceChange = new Subject();
        this._destroyed = new Subject();
        this._groupId = nextId++;
        this.viewportService
            .max(NxBreakpoints.BREAKPOINT_MEDIUM)
            .pipe(takeUntil(this._destroyed))
            .subscribe(isSmallTablet => this._switchAppearance(isSmallTablet));
    }
    /** Sets the selected tab. */
    get selectedIndex() {
        return this._selectedIndex;
    }
    set selectedIndex(value) {
        this._indexToSelect = coerceNumberProperty(value, null);
    }
    /** Whether the negative set of styling should be used. */
    get negative() {
        return this._negative;
    }
    set negative(value) {
        if (value !== this._negative) {
            this._negative = coerceBooleanProperty(value);
            this._cdr.markForCheck();
        }
    }
    /** Whether the tab group is disabled. Default: false. */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (value !== this._disabled) {
            this._disabled = coerceBooleanProperty(value);
            this._cdr.markForCheck();
        }
    }
    /** Whether the tab should be immediately selected on focus. */
    get autoselect() {
        return this._autoselect;
    }
    set autoselect(value) {
        this._autoselect = coerceBooleanProperty(value);
    }
    /** Whether the tabs should to accordion on mobile viewports. */
    get mobileAccordion() {
        return this._mobileAccordion;
    }
    set mobileAccordion(value) {
        this._mobileAccordion = coerceBooleanProperty(value);
    }
    /**
     * **Expert option**
     *
     * Sets the appearance of the tab group. Default: 'default'.
     */
    set appearance(value) {
        if (this._appearance !== value) {
            this._appearance = value;
            this._cdr.markForCheck();
        }
    }
    get appearance() {
        var _a;
        return this._appearance || ((_a = this._defaultOptions) === null || _a === void 0 ? void 0 : _a.appearance) || 'default';
    }
    ngAfterContentInit() {
        this._subscribeToTabLabels();
        // Subscribe to changes in the amount of tabs, in order to be
        // able to re-render the content as new tabs are added or removed.
        this.tabs.changes.pipe(takeUntil(this._destroyed)).subscribe(() => {
            const indexToSelect = this._clampTabIndex(this._indexToSelect);
            // Maintain the previously-selected tab if a new tab is added or removed and there is no
            // explicit change that selects a different tab.
            if (indexToSelect === this._selectedIndex) {
                const tabs = this.tabs.toArray();
                for (let i = 0; i < tabs.length; i++) {
                    if (tabs[i].isActive) {
                        // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed
                        // event, otherwise the consumer may end up in an infinite loop in some edge cases like
                        // adding a tab within the `selectedIndexChange` event.
                        this._indexToSelect = this._selectedIndex = i;
                        break;
                    }
                }
            }
            this._cdr.markForCheck();
        });
    }
    /**
     * After the content is checked, this component knows what tabs have been defined
     * and what the selected index should be.
     */
    ngAfterContentChecked() {
        // Don't clamp the `indexToSelect` immediately in the setter because it can happen that
        // the amount of tabs changes before the actual change detection runs.
        let indexToSelect = (this._indexToSelect = this._clampTabIndex(this._indexToSelect));
        // If the active tab is disabled select the next focusable tab
        // if all tabs are disabled, allow selection of disabled active tab.
        if (!this.disabled && this.tabs.toArray()[indexToSelect].disabled) {
            const nextFocusable = this.tabs
                .toArray()
                .map((tab, index) => ({ tab, index }))
                .find(item => !item.tab.disabled);
            indexToSelect = nextFocusable ? nextFocusable.index : indexToSelect;
        }
        // If the index to select was disabled previously leave the selection on the current
        // so that the selection does not jump from one to another tab.
        if (this._disabledTabsCache[this._indexToSelect]) {
            this._indexToSelect = this.selectedIndex;
        }
        // If there is a change in selected index, emit a change event. Should not trigger if
        // the selected index has not yet been initialized.
        if (this._selectedIndex !== indexToSelect) {
            const isFirstRun = this._selectedIndex == null;
            if (!isFirstRun) {
                this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));
            }
            // Changing these values after change detection has run
            // since the checked content may contain references to them.
            Promise.resolve().then(() => {
                this.tabs.forEach((tab, index) => (tab.isActive = index === indexToSelect));
                if (!isFirstRun) {
                    this.selectedIndexChange.emit(indexToSelect);
                }
            });
        }
        if (this._selectedIndex !== indexToSelect) {
            this._selectedIndex = indexToSelect;
            this._cdr.markForCheck();
        }
        // cache the previous disabled status of all tabs
        if (!this.disabled) {
            this.tabs.toArray().forEach((tab, index) => (this._disabledTabsCache[index] = tab.disabled));
        }
    }
    ngAfterViewInit() {
        this._tabButtons.forEach(button => this._focusMonitor.monitor(button));
        this._tabButtonsPrevious = this._tabButtons;
        this._tabButtons.changes.subscribe(tabButtons => {
            this._tabButtonsPrevious.forEach(button => this._focusMonitor.stopMonitoring(button));
            this._tabButtonsPrevious = tabButtons;
            tabButtons.forEach((button) => this._focusMonitor.monitor(button));
        });
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._tabLabelSubscription.unsubscribe();
        this._tabButtons.forEach(button => {
            this._focusMonitor.stopMonitoring(button);
        });
    }
    /**
     * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is
     * on the NxTab component, whereas the data binding is inside the NxTabGroup. In order for the
     * binding to be updated, we need to subscribe to changes in it and trigger change detection
     * manually.
     */
    _subscribeToTabLabels() {
        if (this._tabLabelSubscription) {
            this._tabLabelSubscription.unsubscribe();
        }
        this._tabLabelSubscription = merge(...this.tabs.map(tab => tab._stateChanges)).subscribe(() => this._cdr.markForCheck());
    }
    /** Clamps the given index to the bounds of 0 and the tabs length. */
    _clampTabIndex(index) {
        // Note the `|| 0`, which ensures that values like NaN can't get through
        // and which would otherwise throw the component into an infinite loop
        // (since Math.max(NaN, 0) === NaN).
        return Math.min(this.tabs.length - 1, Math.max(index || 0, 0));
    }
    /** @docs-private */
    focusChanged(index) {
        this.focusChange.emit(this._createChangeEvent(index));
    }
    _createChangeEvent(index) {
        var _a;
        const event = new NxTabChangeEvent();
        event.index = index;
        if ((_a = this.tabs) === null || _a === void 0 ? void 0 : _a.length) {
            event.tab = this.tabs.toArray()[index];
        }
        return event;
    }
    /** @docs-private */
    handleClick(index) {
        const clickedTab = this.tabs.toArray()[index];
        if (!this.disabled && !clickedTab.disabled) {
            this.selectedIndex = this.tabHeader.focusIndex = index;
        }
    }
    /**
     * @docs-private
     * Returns the tabindex for a tab label
     */
    getTabIndex(tab, idx) {
        return this.selectedIndex === idx && !tab.disabled && !this.disabled ? 0 : -1;
    }
    /** Returns a unique id for each tab label element */
    _getTabLabelId(i) {
        return `nx-tab-label-${this._groupId}-${i}`;
    }
    /** Returns a unique id for each tab content element */
    _getTabContentId(i) {
        return `nx-tab-content-${this._groupId}-${i}`;
    }
    _switchAppearance(isSmallTablet) {
        if (!this._mobileAccordion) {
            return;
        }
        // trigger a change only when there is value difference
        // otherwise a switch is triggered by tablet <-> desktop change
        if (this._showAccordion !== isSmallTablet) {
            // notify the outlets to detach the viewrefs for header and body before
            // we switch the appearance. this way we only instantiate the templates
            // once so that they do not get destroyed during the switch
            this._appearanceChange.next();
            this._showAccordion = isSmallTablet;
            this._cdr.markForCheck();
        }
    }
    /**
     * Emulate the tab change event when an accordion panel is opened in
     * mobile viewports.
     */
    _panelOpened(index) {
        this.selectedIndex = index;
    }
}
NxTabGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabGroupComponent, deps: [{ token: i1$1.NxViewportService }, { token: i0.ChangeDetectorRef }, { token: TAB_GROUP_DEFAULT_OPTIONS, optional: true }, { token: i2.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxTabGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTabGroupComponent, selector: "nx-tab-group", inputs: { selectedIndex: "selectedIndex", negative: "negative", disabled: "disabled", autoselect: "autoselect", mobileAccordion: "mobileAccordion", appearance: "appearance" }, outputs: { selectedIndexChange: "selectedIndexChange", selectedTabChange: "selectedTabChange", focusChange: "focusChange" }, host: { properties: { "class.is-negative": "negative", "class.is-disabled": "disabled", "class.is-expert": "appearance === \"expert\"" } }, providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }], queries: [{ propertyName: "tabs", predicate: NxTabComponent }], viewQueries: [{ propertyName: "tabHeader", first: true, predicate: ["tabHeader"], descendants: true }, { propertyName: "accordion", first: true, predicate: ["accordion"], descendants: true, read: NxAccordionDirective }, { propertyName: "tabBodyChildren", predicate: NxTabBodyComponent, descendants: true }, { propertyName: "panels", predicate: NxExpansionPanelComponent, descendants: true }, { propertyName: "_tabButtons", predicate: ["tabButton"], descendants: true }], ngImport: i0, template: "<ng-container *ngIf=\"!_showAccordion\">\n    <nx-tab-header\n        #tabHeader\n        [selectedIndex]=\"selectedIndex\"\n        (selectFocusedIndex)=\"selectedIndex = $event\"\n        (indexFocused)=\"focusChanged($event)\"\n        [autoselect]=\"autoselect\"\n    >\n        <button\n            #tabButton\n            type=\"button\"\n            nxTabLabelWrapper\n            *ngFor=\"let tab of tabs; let i = index\"\n            role=\"tab\"\n            (click)=\"handleClick(i)\"\n            class=\"nx-tab-header__item\"\n            [id]=\"_getTabLabelId(i)\"\n            [attr.aria-controls]=\"_getTabContentId(i)\"\n            [attr.aria-selected]=\"selectedIndex === i\"\n            [attr.tabindex]=\"getTabIndex(tab, i)\"\n            [disabled]=\"tab.disabled\"\n            [class.nx-tab-header__item--disabled]=\"tab.disabled\"\n            [class.nx-tab-header__item--active]=\"selectedIndex === i\"\n        >\n            <div class=\"nx-tab-label__content\">\n                <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n                <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n            </div>\n        </button>\n    </nx-tab-header>\n\n    <div class=\"nx-tab-body__container\">\n        <nx-tab-body\n            *ngFor=\"let tab of tabs; let i = index\"\n            [id]=\"_getTabContentId(i)\"\n            role=\"tabpanel\"\n            class=\"nx-tab__body\"\n            [attr.aria-labelledby]=\"_getTabContentId(i)\"\n            [class.nx-tab__body--active]=\"selectedIndex === i\"\n            [tab]=\"tab\"\n            [active]=\"selectedIndex === i\"\n        ></nx-tab-body>\n    </div>\n</ng-container>\n\n<ng-template [ngIf]=\"_showAccordion\">\n    <nx-accordion #accordion [negative]=\"negative\">\n        <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\" [expanded]=\"selectedIndex === i\" (opened)=\"_panelOpened(i)\" [disabled]=\"tab.disabled\">\n            <nx-expansion-panel-header>\n                <nx-expansion-panel-title>\n                    <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n                    <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n                </nx-expansion-panel-title>\n            </nx-expansion-panel-header>\n            <!-- this is not lazy loading this is a trick because the portal gets added here -->\n            <!-- so we could rewrite the tab-body component that it takes care of \"lazy loading\" and the\n    accordion wouldn't know about it -->\n            <!-- active=true is a trick because we want to keep the content attached for better user experience along with expansion panel animation.  -->\n            <nx-tab-body [active]=\"true\" [tab]=\"tab\"></nx-tab-body>\n        </nx-expansion-panel>\n    </nx-accordion>\n</ng-template>\n", styles: [":host{display:block}.nx-tab-header__item{font-size:var(--tab-item-font-size);line-height:var(--tab-item-line-height);font-weight:var(--tab-item-font-weight);letter-spacing:var(--tab-item-letter-spacing);text-decoration:none;border:none;background:transparent;color:var(--tab-item-color);padding:4px 0 12px;margin:4px 16px 0;outline:none;position:relative;cursor:pointer;flex:0 0 auto}@media screen and (-ms-high-contrast: active){.nx-tab-header__item{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}}.nx-tab-header__item:hover{color:var(--tab-item-hover-color)}.nx-tab-header__item:active{color:var(--tab-item-active-color)}.nx-tab-header__item::-moz-focus-inner{border:0}:host .nx-tab-header__item{overflow:visible}:host .nx-tab-header__item:first-child{margin-left:0}[dir=rtl] :host .nx-tab-header__item:first-child{margin-right:0;margin-left:16px}:host .nx-tab-header__item:last-child{margin-right:0}[dir=rtl] :host .nx-tab-header__item:last-child{margin-right:16px;margin-left:0}.nx-tab-header__item:before{content:\"\";position:absolute;width:calc(100% + 64px);height:1px;bottom:0;left:-32px;background-color:var(--tab-item-border-color)}.nx-tab-header__item:first-child:before{left:0;width:calc(100% + 32px)}[dir=rtl] .nx-tab-header__item:first-child:before{left:auto;left:initial;right:0}.nx-tab-header__item:last-child:before{width:calc(100% + 32px)}[dir=rtl] .nx-tab-header__item:last-child:before{left:auto;left:initial;right:-32px}:host(.is-expert) .nx-tab-header__item:before{display:none}:host(.is-expert) .nx-tab-header__item:not(.nx-tab-header__item--active){border-color:transparent}:host(.is-expert) .nx-tab-header__item{padding-bottom:8px}:host(.is-expert) .nx-tab-header__item.nx-tab-header__item--active{padding-bottom:4px}:host(.is-expert):not(.is-negative) .nx-tab-header__item:not(.nx-tab-header__item--active):not(.nx-tab-header__item--disabled){color:var(--tab-expert-color)}:host(.is-expert):not(.is-negative) .nx-tab-header__item:not(.nx-tab-header__item--active):not(.nx-tab-header__item--disabled):hover{color:var(--tab-item-hover-color)}:host(.is-expert):not(.is-negative) .nx-tab-header__item:not(.nx-tab-header__item--active):not(.nx-tab-header__item--disabled):active{color:var(--tab-item-active-color)}@media screen and (-ms-high-contrast: active){:host(.is-expert):not(.is-negative) .nx-tab-header__item:not(.nx-tab-header__item--active):not(.nx-tab-header__item--disabled){color:buttonText}}.nx-tab-header__item--active{border-width:4px;font-weight:700;border-bottom-style:solid;border-color:var(--tab-item-active-border-color);padding-bottom:8px;cursor:default}.nx-tab-header__item--active:hover,.nx-tab-header__item--active:active{color:var(--tab-item-color)}@media screen and (-ms-high-contrast: active){.nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight}}.nx-tab-header__item--active:before{display:none}.nx-tab-header__item--disabled{border-color:var(--tab-item-disabled-border-color);color:var(--tab-item-disabled-color);cursor:not-allowed}.nx-tab-header__item--disabled:hover,.nx-tab-header__item--disabled:active{color:var(--tab-item-disabled-color)}@media screen and (-ms-high-contrast: active){.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}.nx-tab-label__content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.nx-tab-header__item.cdk-keyboard-focused .nx-tab-label__content{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-tab-header__item.cdk-keyboard-focused .nx-tab-label__content{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host(.is-negative){color:var(--negative)}:host(.is-negative) .nx-tab-header__item{color:var(--negative);border-bottom-color:var(--negative)}:host(.is-negative) .nx-tab-header__item:hover,:host(.is-negative) .nx-tab-header__item:active{font-weight:700}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:var(--tab-item-disabled-border-color);color:var(--tab-item-disabled-color);cursor:not-allowed;color:var(--tab-item-disabled-negative-color);border-color:var(--tab-item-disabled-negative-color)}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled:hover,:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled:active{color:var(--tab-item-disabled-color)}@media screen and (-ms-high-contrast: active){:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-negative.is-expert) .nx-tab-header__item.nx-tab-header__item--disabled:not(.nx-tab-header__item--active){border-bottom-color:transparent}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) .nx-tab-header__item{color:var(--tab-item-disabled-negative-color);border-color:var(--tab-item-disabled-negative-color)}@media screen and (-ms-high-contrast: active){:host(.is-negative){color:buttonText}:host(.is-negative) .nx-tab-header__item{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) .nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight;-ms-high-contrast-adjust:none}:host(.is-disabled.is-negative) .nx-tab-header__item{color:GrayText;border-bottom-color:GrayText}}\n"], components: [{ type: NxTabHeaderComponent, selector: "nx-tab-header", inputs: ["selectedIndex", "autoselect"], outputs: ["selectFocusedIndex", "indexFocused"] }, { type: NxTabHeaderOutletComponent, selector: "nx-tab-header-outlet", inputs: ["content"] }, { type: NxTabBodyComponent, selector: "nx-tab-body", inputs: ["tab", "active"] }, { type: i6.NxExpansionPanelComponent, selector: "nx-expansion-panel", inputs: ["negative", "nxStyle"], exportAs: ["NxExpansionPanelComponent"] }, { type: i6.NxExpansionPanelHeaderComponent, selector: "nx-expansion-panel-header" }], directives: [{ type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i7.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: NxTabLabelWrapperDirective, selector: "[nxTabLabelWrapper]", inputs: ["disabled"] }, { type: i6.NxAccordionDirective, selector: "nx-accordion", inputs: ["nxStyle", "negative"] }, { type: i6.NxExpansionPanelTitleDirective, selector: "nx-expansion-panel-title" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabGroupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tab-group', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class.is-negative]': 'negative',
                        '[class.is-disabled]': 'disabled',
                        '[class.is-expert]': 'appearance === "expert"',
                    }, providers: [{ provide: NxTabGroupBase, useExisting: NxTabGroupComponent }], template: "<ng-container *ngIf=\"!_showAccordion\">\n    <nx-tab-header\n        #tabHeader\n        [selectedIndex]=\"selectedIndex\"\n        (selectFocusedIndex)=\"selectedIndex = $event\"\n        (indexFocused)=\"focusChanged($event)\"\n        [autoselect]=\"autoselect\"\n    >\n        <button\n            #tabButton\n            type=\"button\"\n            nxTabLabelWrapper\n            *ngFor=\"let tab of tabs; let i = index\"\n            role=\"tab\"\n            (click)=\"handleClick(i)\"\n            class=\"nx-tab-header__item\"\n            [id]=\"_getTabLabelId(i)\"\n            [attr.aria-controls]=\"_getTabContentId(i)\"\n            [attr.aria-selected]=\"selectedIndex === i\"\n            [attr.tabindex]=\"getTabIndex(tab, i)\"\n            [disabled]=\"tab.disabled\"\n            [class.nx-tab-header__item--disabled]=\"tab.disabled\"\n            [class.nx-tab-header__item--active]=\"selectedIndex === i\"\n        >\n            <div class=\"nx-tab-label__content\">\n                <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n                <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n            </div>\n        </button>\n    </nx-tab-header>\n\n    <div class=\"nx-tab-body__container\">\n        <nx-tab-body\n            *ngFor=\"let tab of tabs; let i = index\"\n            [id]=\"_getTabContentId(i)\"\n            role=\"tabpanel\"\n            class=\"nx-tab__body\"\n            [attr.aria-labelledby]=\"_getTabContentId(i)\"\n            [class.nx-tab__body--active]=\"selectedIndex === i\"\n            [tab]=\"tab\"\n            [active]=\"selectedIndex === i\"\n        ></nx-tab-body>\n    </div>\n</ng-container>\n\n<ng-template [ngIf]=\"_showAccordion\">\n    <nx-accordion #accordion [negative]=\"negative\">\n        <nx-expansion-panel *ngFor=\"let tab of tabs; let i = index\" [expanded]=\"selectedIndex === i\" (opened)=\"_panelOpened(i)\" [disabled]=\"tab.disabled\">\n            <nx-expansion-panel-header>\n                <nx-expansion-panel-title>\n                    <nx-tab-header-outlet *ngIf=\"tab.templateLabel\" [content]=\"tab.headerViewRef\"></nx-tab-header-outlet>\n                    <ng-container *ngIf=\"!tab.templateLabel\">{{tab.label}}</ng-container>\n                </nx-expansion-panel-title>\n            </nx-expansion-panel-header>\n            <!-- this is not lazy loading this is a trick because the portal gets added here -->\n            <!-- so we could rewrite the tab-body component that it takes care of \"lazy loading\" and the\n    accordion wouldn't know about it -->\n            <!-- active=true is a trick because we want to keep the content attached for better user experience along with expansion panel animation.  -->\n            <nx-tab-body [active]=\"true\" [tab]=\"tab\"></nx-tab-body>\n        </nx-expansion-panel>\n    </nx-accordion>\n</ng-template>\n", styles: [":host{display:block}.nx-tab-header__item{font-size:var(--tab-item-font-size);line-height:var(--tab-item-line-height);font-weight:var(--tab-item-font-weight);letter-spacing:var(--tab-item-letter-spacing);text-decoration:none;border:none;background:transparent;color:var(--tab-item-color);padding:4px 0 12px;margin:4px 16px 0;outline:none;position:relative;cursor:pointer;flex:0 0 auto}@media screen and (-ms-high-contrast: active){.nx-tab-header__item{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}}.nx-tab-header__item:hover{color:var(--tab-item-hover-color)}.nx-tab-header__item:active{color:var(--tab-item-active-color)}.nx-tab-header__item::-moz-focus-inner{border:0}:host .nx-tab-header__item{overflow:visible}:host .nx-tab-header__item:first-child{margin-left:0}[dir=rtl] :host .nx-tab-header__item:first-child{margin-right:0;margin-left:16px}:host .nx-tab-header__item:last-child{margin-right:0}[dir=rtl] :host .nx-tab-header__item:last-child{margin-right:16px;margin-left:0}.nx-tab-header__item:before{content:\"\";position:absolute;width:calc(100% + 64px);height:1px;bottom:0;left:-32px;background-color:var(--tab-item-border-color)}.nx-tab-header__item:first-child:before{left:0;width:calc(100% + 32px)}[dir=rtl] .nx-tab-header__item:first-child:before{left:auto;left:initial;right:0}.nx-tab-header__item:last-child:before{width:calc(100% + 32px)}[dir=rtl] .nx-tab-header__item:last-child:before{left:auto;left:initial;right:-32px}:host(.is-expert) .nx-tab-header__item:before{display:none}:host(.is-expert) .nx-tab-header__item:not(.nx-tab-header__item--active){border-color:transparent}:host(.is-expert) .nx-tab-header__item{padding-bottom:8px}:host(.is-expert) .nx-tab-header__item.nx-tab-header__item--active{padding-bottom:4px}:host(.is-expert):not(.is-negative) .nx-tab-header__item:not(.nx-tab-header__item--active):not(.nx-tab-header__item--disabled){color:var(--tab-expert-color)}:host(.is-expert):not(.is-negative) .nx-tab-header__item:not(.nx-tab-header__item--active):not(.nx-tab-header__item--disabled):hover{color:var(--tab-item-hover-color)}:host(.is-expert):not(.is-negative) .nx-tab-header__item:not(.nx-tab-header__item--active):not(.nx-tab-header__item--disabled):active{color:var(--tab-item-active-color)}@media screen and (-ms-high-contrast: active){:host(.is-expert):not(.is-negative) .nx-tab-header__item:not(.nx-tab-header__item--active):not(.nx-tab-header__item--disabled){color:buttonText}}.nx-tab-header__item--active{border-width:4px;font-weight:700;border-bottom-style:solid;border-color:var(--tab-item-active-border-color);padding-bottom:8px;cursor:default}.nx-tab-header__item--active:hover,.nx-tab-header__item--active:active{color:var(--tab-item-color)}@media screen and (-ms-high-contrast: active){.nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight}}.nx-tab-header__item--active:before{display:none}.nx-tab-header__item--disabled{border-color:var(--tab-item-disabled-border-color);color:var(--tab-item-disabled-color);cursor:not-allowed}.nx-tab-header__item--disabled:hover,.nx-tab-header__item--disabled:active{color:var(--tab-item-disabled-color)}@media screen and (-ms-high-contrast: active){.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}.nx-tab-label__content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.nx-tab-header__item.cdk-keyboard-focused .nx-tab-label__content{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-tab-header__item.cdk-keyboard-focused .nx-tab-label__content{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}:host(.is-negative){color:var(--negative)}:host(.is-negative) .nx-tab-header__item{color:var(--negative);border-bottom-color:var(--negative)}:host(.is-negative) .nx-tab-header__item:hover,:host(.is-negative) .nx-tab-header__item:active{font-weight:700}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:var(--tab-item-disabled-border-color);color:var(--tab-item-disabled-color);cursor:not-allowed;color:var(--tab-item-disabled-negative-color);border-color:var(--tab-item-disabled-negative-color)}:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled:hover,:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled:active{color:var(--tab-item-disabled-color)}@media screen and (-ms-high-contrast: active){:host(.is-negative) .nx-tab-header__item.nx-tab-header__item--disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-negative.is-expert) .nx-tab-header__item.nx-tab-header__item--disabled:not(.nx-tab-header__item--active){border-bottom-color:transparent}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) .nx-tab-header__item{color:var(--tab-item-disabled-negative-color);border-color:var(--tab-item-disabled-negative-color)}@media screen and (-ms-high-contrast: active){:host(.is-negative){color:buttonText}:host(.is-negative) .nx-tab-header__item{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) .nx-tab-header__item--active{background-color:highlight;color:highlightText;border-color:highlight;-ms-high-contrast-adjust:none}:host(.is-disabled.is-negative) .nx-tab-header__item{color:GrayText;border-bottom-color:GrayText}}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i1$1.NxViewportService }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [TAB_GROUP_DEFAULT_OPTIONS]
                    }] }, { type: i2.FocusMonitor }];
    }, propDecorators: { tabs: [{
                type: ContentChildren,
                args: [NxTabComponent]
            }], tabBodyChildren: [{
                type: ViewChildren,
                args: [NxTabBodyComponent]
            }], tabHeader: [{
                type: ViewChild,
                args: ['tabHeader']
            }], panels: [{
                type: ViewChildren,
                args: [NxExpansionPanelComponent]
            }], accordion: [{
                type: ViewChild,
                args: ['accordion', { read: NxAccordionDirective }]
            }], _tabButtons: [{
                type: ViewChildren,
                args: ['tabButton']
            }], selectedIndex: [{
                type: Input
            }], negative: [{
                type: Input
            }], disabled: [{
                type: Input
            }], autoselect: [{
                type: Input
            }], mobileAccordion: [{
                type: Input
            }], appearance: [{
                type: Input
            }], selectedIndexChange: [{
                type: Output
            }], selectedTabChange: [{
                type: Output
            }], focusChange: [{
                type: Output
            }] } });

class NxTabNavBarComponent extends NxScrollableTabBar {
    constructor(_cdr, _dir, _defaultOptions, _element) {
        super(_cdr, _dir, _element);
        this._cdr = _cdr;
        this._defaultOptions = _defaultOptions;
        this._negative = false;
        this._disabled = false;
    }
    /** Whether the tab nav bar has negative styling. */
    set negative(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.negative) {
            this._negative = newValue;
            this._cdr.markForCheck();
        }
    }
    get negative() {
        return this._negative;
    }
    /** Whether the tab nav bar has disabled styling. */
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.disabled) {
            this._disabled = newValue;
            this._cdr.markForCheck();
        }
    }
    get disabled() {
        return this._disabled;
    }
    /**
     * **Expert option**
     *
     * Sets the appearance of the tab nav bar. Default: 'default'.
     */
    set appearance(value) {
        if (this._appearance !== value) {
            this._appearance = value;
            this._cdr.markForCheck();
        }
    }
    get appearance() {
        var _a;
        return this._appearance || ((_a = this._defaultOptions) === null || _a === void 0 ? void 0 : _a.appearance) || 'default';
    }
}
NxTabNavBarComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabNavBarComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.Directionality, optional: true }, { token: TAB_NAV_BAR_DEFAULT_OPTIONS, optional: true }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component });
NxTabNavBarComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTabNavBarComponent, selector: "nx-tab-nav-bar", inputs: { negative: "negative", disabled: "disabled", appearance: "appearance" }, host: { attributes: { "role": "navigation" }, properties: { "class.is-negative": "negative", "class.is-disabled": "disabled", "class.is-expert": "appearance === \"expert\"", "class.at-start": "_isScrolledToStart", "class.scrollable": "scrollable" } }, queries: [{ propertyName: "tabButtons", predicate: i0.forwardRef(function () { return NxTabLinkDirective; }) }], viewQueries: [{ propertyName: "scrollableTabsList", first: true, predicate: ["tabsList"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<nx-tab-scroll-indicator *ngIf=\"scrollable\" scrollDirection=\"start\" [isScrolledToStart]=\"_isScrolledToStart\" (buttonClicked)=\"scrollToStart()\">\n</nx-tab-scroll-indicator>\n<div #tabsList class=\"nx-tab-nav-bar\" tabindex=\"-1\">\n    <ng-content></ng-content>\n</div>\n<nx-tab-scroll-indicator *ngIf=\"scrollable\" scrollDirection=\"end\" [isScrolledToEnd]=\"_isScrolledToEnd\" (buttonClicked)=\"scrollToEnd()\">\n</nx-tab-scroll-indicator>\n", styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host.is-expert{justify-content:flex-start;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:var(--tab-expert-bottom-border-color)}:host.is-expert .nx-tab-nav-bar{width:100%}:host .nx-tab-nav-bar{display:flex;position:relative;overflow-x:scroll;outline:none;-ms-overflow-style:none;scrollbar-width:none}:host .nx-tab-nav-bar::-webkit-scrollbar{display:none}:host.at-start .nx-tab-nav-bar{margin-left:-8px;padding-left:8px}[dir=rtl] :host.at-start .nx-tab-nav-bar{margin-left:0;padding-left:0;margin-right:-8px;padding-right:8px}:host:not(.scrollable) .nx-tab-nav-bar{margin-right:-8px;padding-right:8px}[dir=rtl] :host:not(.scrollable) .nx-tab-nav-bar{margin-right:0;padding-right:0;margin-left:-8px;padding-left:8px}:host ::ng-deep a.nx-tab-link{font-size:var(--tab-item-font-size);line-height:var(--tab-item-line-height);font-weight:var(--tab-item-font-weight);letter-spacing:var(--tab-item-letter-spacing);text-decoration:none;border:none;background:transparent;color:var(--tab-item-color);padding:4px 0 12px;margin:4px 16px 0;outline:none;position:relative;cursor:pointer;white-space:nowrap}@media screen and (-ms-high-contrast: active){:host ::ng-deep a.nx-tab-link{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}}:host ::ng-deep a.nx-tab-link:hover{color:var(--tab-item-hover-color)}:host ::ng-deep a.nx-tab-link:active{color:var(--tab-item-active-color)}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;border-bottom-style:solid;border-color:var(--tab-item-active-border-color);padding-bottom:8px;cursor:default}:host ::ng-deep a.nx-tab-link.is-active:hover,:host ::ng-deep a.nx-tab-link.is-active:active{color:var(--tab-item-color)}@media screen and (-ms-high-contrast: active){:host ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}}:host:not(.is-expert) ::ng-deep a.nx-tab-link:not(.is-active):before{content:\"\";position:absolute;width:calc(100% + 64px);height:1px;background-color:var(--tab-item-border-color);bottom:0;left:-32px}:host:not(.is-expert) ::ng-deep a.nx-tab-link:first-child:before{left:0px;width:calc(100% + 32px)}[dir=rtl] :host:not(.is-expert) ::ng-deep a.nx-tab-link:first-child:before{left:auto;left:initial;right:0}:host:not(.is-expert) ::ng-deep a.nx-tab-link:last-child:before{width:calc(100% + 32px)}[dir=rtl] :host:not(.is-expert) ::ng-deep a.nx-tab-link:last-child:before{left:auto;left:initial;right:-32px}:host ::ng-deep a.nx-tab-link:first-child{margin-left:0}[dir=rtl] :host ::ng-deep a.nx-tab-link:first-child{margin-right:0;margin-left:16px}:host ::ng-deep a.nx-tab-link:last-child{margin-right:0}[dir=rtl] :host ::ng-deep a.nx-tab-link:last-child{margin-right:16px;margin-left:0}:host.is-expert ::ng-deep a.nx-tab-link{padding:4px 0}:host.is-expert ::ng-deep a.nx-tab-link.is-disabled:not(.is-active){border-bottom-color:transparent}:host.is-expert:not(.is-negative) ::ng-deep a.nx-tab-link:not(.is-disabled):not(.is-active){color:var(--tab-expert-color)}@media screen and (-ms-high-contrast: active){:host.is-expert:not(.is-negative) ::ng-deep a.nx-tab-link:not(.is-disabled):not(.is-active){color:buttonText}}:host.is-expert:not(.is-negative) ::ng-deep a.nx-tab-link.is-active{border-color:var(--tab-item-active-border-color)}:host(.is-negative){color:var(--negative)}:host(.is-negative) ::ng-deep a.nx-tab-link{color:var(--negative);border-bottom-color:var(--negative)}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:var(--tab-item-disabled-negative-color);border-color:var(--tab-item-disabled-negative-color)}@media screen and (-ms-high-contrast: active){:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:windowFrame}}:host.is-expert.is-negative ::ng-deep a.nx-tab-link:not(.is-active){border-bottom-color:transparent}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:var(--tab-item-disabled-border-color);color:var(--tab-item-disabled-color);cursor:not-allowed}:host ::ng-deep a.nx-tab-link.is-disabled:hover,:host ::ng-deep a.nx-tab-link.is-disabled:active{color:var(--tab-item-disabled-color)}@media screen and (-ms-high-contrast: active){:host ::ng-deep a.nx-tab-link.is-disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) ::ng-deep a.nx-tab-link{color:var(--tab-item-disabled-negative-color);border-color:var(--tab-item-disabled-negative-color)}:host ::ng-deep .nx-tab-link:not(.is-disabled).cdk-keyboard-focused:after{content:\"\";display:block;position:absolute;height:var(--tab-item-line-height);width:100%;top:4px;box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host ::ng-deep .nx-tab-link:not(.is-disabled).cdk-keyboard-focused:after{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}@media screen and (-ms-high-contrast: active){:host(.is-negative){color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:GrayText;border-bottom-color:GrayText}}\n"], components: [{ type: NxTabScrollIndicator, selector: "nx-tab-scroll-indicator", inputs: ["scrollDirection", "isScrolledToStart", "isScrolledToEnd"], outputs: ["buttonClicked"] }], directives: [{ type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabNavBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tab-nav-bar', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class.is-negative]': 'negative',
                        '[class.is-disabled]': 'disabled',
                        '[class.is-expert]': 'appearance === "expert"',
                        role: 'navigation',
                        '[class.at-start]': '_isScrolledToStart',
                        '[class.scrollable]': 'scrollable',
                    }, template: "<nx-tab-scroll-indicator *ngIf=\"scrollable\" scrollDirection=\"start\" [isScrolledToStart]=\"_isScrolledToStart\" (buttonClicked)=\"scrollToStart()\">\n</nx-tab-scroll-indicator>\n<div #tabsList class=\"nx-tab-nav-bar\" tabindex=\"-1\">\n    <ng-content></ng-content>\n</div>\n<nx-tab-scroll-indicator *ngIf=\"scrollable\" scrollDirection=\"end\" [isScrolledToEnd]=\"_isScrolledToEnd\" (buttonClicked)=\"scrollToEnd()\">\n</nx-tab-scroll-indicator>\n", styles: [":host{display:flex;align-items:flex-end;justify-content:center}:host.is-expert{justify-content:flex-start;border-bottom-width:1px;border-bottom-style:solid;border-bottom-color:var(--tab-expert-bottom-border-color)}:host.is-expert .nx-tab-nav-bar{width:100%}:host .nx-tab-nav-bar{display:flex;position:relative;overflow-x:scroll;outline:none;-ms-overflow-style:none;scrollbar-width:none}:host .nx-tab-nav-bar::-webkit-scrollbar{display:none}:host.at-start .nx-tab-nav-bar{margin-left:-8px;padding-left:8px}[dir=rtl] :host.at-start .nx-tab-nav-bar{margin-left:0;padding-left:0;margin-right:-8px;padding-right:8px}:host:not(.scrollable) .nx-tab-nav-bar{margin-right:-8px;padding-right:8px}[dir=rtl] :host:not(.scrollable) .nx-tab-nav-bar{margin-right:0;padding-right:0;margin-left:-8px;padding-left:8px}:host ::ng-deep a.nx-tab-link{font-size:var(--tab-item-font-size);line-height:var(--tab-item-line-height);font-weight:var(--tab-item-font-weight);letter-spacing:var(--tab-item-letter-spacing);text-decoration:none;border:none;background:transparent;color:var(--tab-item-color);padding:4px 0 12px;margin:4px 16px 0;outline:none;position:relative;cursor:pointer;white-space:nowrap}@media screen and (-ms-high-contrast: active){:host ::ng-deep a.nx-tab-link{background-color:buttonFace;border-color:buttonText;color:buttonText;-ms-high-contrast-adjust:none}}:host ::ng-deep a.nx-tab-link:hover{color:var(--tab-item-hover-color)}:host ::ng-deep a.nx-tab-link:active{color:var(--tab-item-active-color)}:host ::ng-deep a.nx-tab-link.is-active{border-width:4px;font-weight:700;border-bottom-style:solid;border-color:var(--tab-item-active-border-color);padding-bottom:8px;cursor:default}:host ::ng-deep a.nx-tab-link.is-active:hover,:host ::ng-deep a.nx-tab-link.is-active:active{color:var(--tab-item-color)}@media screen and (-ms-high-contrast: active){:host ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}}:host:not(.is-expert) ::ng-deep a.nx-tab-link:not(.is-active):before{content:\"\";position:absolute;width:calc(100% + 64px);height:1px;background-color:var(--tab-item-border-color);bottom:0;left:-32px}:host:not(.is-expert) ::ng-deep a.nx-tab-link:first-child:before{left:0px;width:calc(100% + 32px)}[dir=rtl] :host:not(.is-expert) ::ng-deep a.nx-tab-link:first-child:before{left:auto;left:initial;right:0}:host:not(.is-expert) ::ng-deep a.nx-tab-link:last-child:before{width:calc(100% + 32px)}[dir=rtl] :host:not(.is-expert) ::ng-deep a.nx-tab-link:last-child:before{left:auto;left:initial;right:-32px}:host ::ng-deep a.nx-tab-link:first-child{margin-left:0}[dir=rtl] :host ::ng-deep a.nx-tab-link:first-child{margin-right:0;margin-left:16px}:host ::ng-deep a.nx-tab-link:last-child{margin-right:0}[dir=rtl] :host ::ng-deep a.nx-tab-link:last-child{margin-right:16px;margin-left:0}:host.is-expert ::ng-deep a.nx-tab-link{padding:4px 0}:host.is-expert ::ng-deep a.nx-tab-link.is-disabled:not(.is-active){border-bottom-color:transparent}:host.is-expert:not(.is-negative) ::ng-deep a.nx-tab-link:not(.is-disabled):not(.is-active){color:var(--tab-expert-color)}@media screen and (-ms-high-contrast: active){:host.is-expert:not(.is-negative) ::ng-deep a.nx-tab-link:not(.is-disabled):not(.is-active){color:buttonText}}:host.is-expert:not(.is-negative) ::ng-deep a.nx-tab-link.is-active{border-color:var(--tab-item-active-border-color)}:host(.is-negative){color:var(--negative)}:host(.is-negative) ::ng-deep a.nx-tab-link{color:var(--negative);border-bottom-color:var(--negative)}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:var(--tab-item-disabled-negative-color);border-color:var(--tab-item-disabled-negative-color)}@media screen and (-ms-high-contrast: active){:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:windowFrame}}:host.is-expert.is-negative ::ng-deep a.nx-tab-link:not(.is-active){border-bottom-color:transparent}:host ::ng-deep a.nx-tab-link.is-disabled{border-color:var(--tab-item-disabled-border-color);color:var(--tab-item-disabled-color);cursor:not-allowed}:host ::ng-deep a.nx-tab-link.is-disabled:hover,:host ::ng-deep a.nx-tab-link.is-disabled:active{color:var(--tab-item-disabled-color)}@media screen and (-ms-high-contrast: active){:host ::ng-deep a.nx-tab-link.is-disabled{border-color:GrayText;background-color:buttonFace;color:GrayText}}:host(.is-disabled){cursor:not-allowed}:host(.is-disabled.is-negative) ::ng-deep a.nx-tab-link{color:var(--tab-item-disabled-negative-color);border-color:var(--tab-item-disabled-negative-color)}:host ::ng-deep .nx-tab-link:not(.is-disabled).cdk-keyboard-focused:after{content:\"\";display:block;position:absolute;height:var(--tab-item-line-height);width:100%;top:4px;box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host ::ng-deep .nx-tab-link:not(.is-disabled).cdk-keyboard-focused:after{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}@media screen and (-ms-high-contrast: active){:host(.is-negative){color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link{color:buttonText;border-bottom-color:buttonText}:host(.is-negative) ::ng-deep a.nx-tab-link.is-active{background-color:highlight;color:highlightText;border-color:highlight}:host(.is-negative) ::ng-deep a.nx-tab-link.is-disabled{color:GrayText;border-bottom-color:GrayText}}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.ChangeDetectorRef }, { type: i1.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: undefined, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [TAB_NAV_BAR_DEFAULT_OPTIONS]
                    }] }, { type: i0.ElementRef }];
    }, propDecorators: { scrollableTabsList: [{
                type: ViewChild,
                args: ['tabsList']
            }], tabButtons: [{
                type: ContentChildren,
                args: [forwardRef(() => NxTabLinkDirective)]
            }], negative: [{
                type: Input
            }], disabled: [{
                type: Input
            }], appearance: [{
                type: Input
            }] } });
class NxTabLinkDirective {
    constructor(_tabNavBar, _elementRef, _focusMonitor) {
        this._tabNavBar = _tabNavBar;
        this._elementRef = _elementRef;
        this._focusMonitor = _focusMonitor;
        this._active = false;
        this._disabled = false;
        if (!this._tabNavBar) {
            throw Error(`The nx-tab-link element has to be wrapped in a nx-tab-nav-bar to work.`);
        }
        this._focusMonitor.monitor(this._elementRef);
    }
    /** Whether the tab link is active and has the active styling. */
    get active() {
        return this._active;
    }
    set active(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._active) {
            this._active = newValue;
        }
    }
    /** Whether the tab link is disabled. Default: false. */
    get disabled() {
        var _a;
        return ((_a = this._tabNavBar) === null || _a === void 0 ? void 0 : _a.disabled) || this._disabled;
    }
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._disabled) {
            this._disabled = newValue;
        }
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    _getTabIndex() {
        return this.disabled ? '-1' : '0';
    }
}
NxTabLinkDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabLinkDirective, deps: [{ token: NxTabNavBarComponent, optional: true, skipSelf: true }, { token: i0.ElementRef }, { token: i2.FocusMonitor }], target: i0.ɵɵFactoryTarget.Directive });
NxTabLinkDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTabLinkDirective, selector: "[nxTabLink]", inputs: { active: "active", disabled: "disabled" }, host: { properties: { "class.nx-tab-link": "true", "class.is-active": "active", "class.is-disabled": "disabled", "attr.aria-current": "active", "attr.tabindex": "_getTabIndex()", "attr.aria-disabled": "disabled.toString()" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxTabLink]',
                    host: {
                        '[class.nx-tab-link]': 'true',
                        '[class.is-active]': 'active',
                        '[class.is-disabled]': 'disabled',
                        '[attr.aria-current]': 'active',
                        '[attr.tabindex]': '_getTabIndex()',
                        '[attr.aria-disabled]': 'disabled.toString()',
                    },
                }]
        }], ctorParameters: function () {
        return [{ type: NxTabNavBarComponent, decorators: [{
                        type: Optional
                    }, {
                        type: SkipSelf
                    }] }, { type: i0.ElementRef }, { type: i2.FocusMonitor }];
    }, propDecorators: { active: [{
                type: Input
            }], disabled: [{
                type: Input
            }] } });

class NxTabsModule {
}
NxTabsModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabsModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxTabsModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabsModule, declarations: [NxTabComponent,
        NxTabGroupComponent,
        NxTabLabelDirective,
        NxTabLabelWrapperDirective,
        NxTabHeaderComponent,
        NxTabBodyComponent,
        NxTabNavBarComponent,
        NxTabLinkDirective,
        NxTabContentDirective,
        NxTabHeaderOutletComponent,
        NxTabScrollIndicator], imports: [CommonModule, PortalModule, NxAccordionModule, NxIconModule, NxButtonModule], exports: [NxTabComponent,
        NxTabGroupComponent,
        NxTabLabelDirective,
        NxTabLabelWrapperDirective,
        NxTabHeaderComponent,
        NxTabBodyComponent,
        NxTabNavBarComponent,
        NxTabLinkDirective,
        NxTabContentDirective] });
NxTabsModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabsModule, imports: [[CommonModule, PortalModule, NxAccordionModule, NxIconModule, NxButtonModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabsModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, PortalModule, NxAccordionModule, NxIconModule, NxButtonModule],
                    exports: [
                        NxTabComponent,
                        NxTabGroupComponent,
                        NxTabLabelDirective,
                        NxTabLabelWrapperDirective,
                        NxTabHeaderComponent,
                        NxTabBodyComponent,
                        NxTabNavBarComponent,
                        NxTabLinkDirective,
                        NxTabContentDirective,
                    ],
                    declarations: [
                        NxTabComponent,
                        NxTabGroupComponent,
                        NxTabLabelDirective,
                        NxTabLabelWrapperDirective,
                        NxTabHeaderComponent,
                        NxTabBodyComponent,
                        NxTabNavBarComponent,
                        NxTabLinkDirective,
                        NxTabContentDirective,
                        NxTabHeaderOutletComponent,
                        NxTabScrollIndicator,
                    ],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NxTabBodyComponent, NxTabChangeEvent, NxTabComponent, NxTabContentDirective, NxTabGroupComponent, NxTabHeaderComponent, NxTabLabelDirective, NxTabLabelWrapperDirective, NxTabLinkDirective, NxTabNavBarComponent, NxTabsModule, TAB_GROUP_DEFAULT_OPTIONS, TAB_NAV_BAR_DEFAULT_OPTIONS };
//# sourceMappingURL=aposin-ng-aquila-tabs.mjs.map
