import * as i1 from '@angular/cdk/a11y';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { END, hasModifierKey, HOME, RIGHT_ARROW, LEFT_ARROW, ESCAPE } from '@angular/cdk/keycodes';
import * as i0 from '@angular/core';
import { Directive, Inject, Component, ChangeDetectionStrategy, Optional, Input, ContentChildren, EventEmitter, TemplateRef, ContentChild, ViewChild, Output, HostListener, InjectionToken, Self, NgModule } from '@angular/core';
import { Subject, ReplaySubject, merge, Subscription, fromEvent, of, asapScheduler } from 'rxjs';
import { takeUntil, switchMap, startWith, take, filter, map, delay } from 'rxjs/operators';
import { trigger, state, style, transition, group, query, animate } from '@angular/animations';
import { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';
import * as i3 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import * as i2 from '@aposin/ng-aquila/icon';
import { NxIconModule } from '@aposin/ng-aquila/icon';
import * as i1$1 from '@angular/cdk/overlay';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { __classPrivateFieldGet, __classPrivateFieldSet } from 'tslib';
import { _getEventTarget } from '@angular/cdk/platform';
import * as i4 from '@angular/cdk/bidi';
import * as i5 from '@aposin/ng-aquila/overlay';

/**
 * Animations used by the NxContextMenuComponent.
 * @docs-private
 */
const nxContextMenuAnimations = {
    /**
     * This animation controls the context menu panel's entry and exit from the page.
     * When the context menu panel is added to the DOM, it scales in and fades in its border.
     * When the context menu panel is removed from the DOM, it simply fades out.
     */
    transformContextMenu: trigger('transformContextMenu', [
        state('void', style({
            opacity: 0,
            transform: 'scale(0.8)',
        })),
        transition('void => enter', group([
            query('.nx-context-menu__content', animate('100ms linear', style({
                opacity: 1,
            }))),
            animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)' })),
        ])),
        transition('* => void', animate('100ms linear', style({ opacity: 0 }))),
    ]),
};

/**
 * Context menu content that will be rendered lazily once the menu is opened.
 */
class NxContextMenuContentDirective {
    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document) {
        this._template = _template;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this._viewContainerRef = _viewContainerRef;
        this._document = _document;
        /** Emits when the menu content has been attached. */
        this._attached = new Subject();
    }
    /**
     * Attaches the content with a particular context.
     * @docs-private
     */
    attach(context = {}) {
        if (!this._portal) {
            this._portal = new TemplatePortal(this._template, this._viewContainerRef);
        }
        this.detach();
        if (!this._outlet) {
            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);
        }
        const element = this._template.elementRef.nativeElement;
        // Because we support opening the same menu from different triggers (which in turn have their
        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we
        // risk it staying attached to a pane that's no longer in the DOM.
        if (element.parentNode) {
            element.parentNode.insertBefore(this._outlet.outletElement, element);
        }
        this._portal.attach(this._outlet, context);
        this._attached.next();
    }
    /**
     * Detaches the content.
     * @docs-private
     */
    detach() {
        if (this._portal.isAttached) {
            this._portal.detach();
        }
    }
    ngOnDestroy() {
        if (this._outlet) {
            this._outlet.dispose();
        }
    }
}
NxContextMenuContentDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuContentDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ComponentFactoryResolver }, { token: i0.ApplicationRef }, { token: i0.Injector }, { token: i0.ViewContainerRef }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive });
NxContextMenuContentDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxContextMenuContentDirective, selector: "ng-template[nxContextMenuContent]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ng-template[nxContextMenuContent]',
                }]
        }], ctorParameters: function () {
        return [{ type: i0.TemplateRef }, { type: i0.ComponentFactoryResolver }, { type: i0.ApplicationRef }, { type: i0.Injector }, { type: i0.ViewContainerRef }, { type: Document, decorators: [{
                        type: Inject,
                        args: [DOCUMENT]
                    }] }];
    } });

/**
 * This directive is intended to be used inside an nx-context-menu tag.
 * It exists mostly to set the role attribute, disabled state and styling.
 */
class NxContextMenuItemComponent {
    constructor(_elementRef, _document, _cdr, _focusMonitor) {
        this._elementRef = _elementRef;
        this._document = _document;
        this._cdr = _cdr;
        this._focusMonitor = _focusMonitor;
        /** Stream that emits when the context menu item is hovered. */
        this._hovered = new Subject();
        this._disabled = false;
        this._disableCloseOnSelect = false;
        /** Whether the context menu item is highlighted. */
        this._highlighted = false;
        /** Whether the context menu item acts as a trigger for a sub-menu. */
        this._triggersSubmenu = false;
        this._focusMonitor.monitor(this._elementRef);
    }
    /** Whether the context menu item is disabled. */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get disabled() {
        return this._disabled;
    }
    /** Whether the context menu close on select. */
    set disableCloseOnSelect(value) {
        this._disableCloseOnSelect = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get disableCloseOnSelect() {
        return this._disableCloseOnSelect;
    }
    /** Focuses this context menu item. */
    focus(origin) {
        if (origin) {
            this._focusMonitor.focusVia(this._getHostElement(), origin);
        }
        else {
            this._getHostElement().focus();
        }
    }
    ngOnDestroy() {
        this._hovered.complete();
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    /** Used to set the `tabindex`. */
    _getTabIndex() {
        return this.disabled ? '-1' : '0';
    }
    /** Returns the host DOM element. */
    _getHostElement() {
        return this._elementRef.nativeElement;
    }
    /** Prevents the default element actions if it is disabled. */
    _checkDisabled(event) {
        if (this.disableCloseOnSelect) {
            event.stopPropagation();
        }
        if (this.disabled) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /** Emits to the hover stream. */
    _handleMouseEnter() {
        this._hovered.next(this);
    }
    /** Gets the label to be used when determining whether the option should be focused. */
    getLabel() {
        const element = this._elementRef.nativeElement.childNodes[0];
        const textNodeType = this._document ? this._document.TEXT_NODE : 3;
        let output = '';
        if (element.childNodes) {
            const length = element.childNodes.length;
            // Go through all the top-level text nodes and extract their text.
            // We skip anything that's not a text node to prevent the text from
            // being thrown off by something like an icon.
            for (let i = 0; i < length; i++) {
                if (element.childNodes[i].nodeType === textNodeType) {
                    output += element.childNodes[i].textContent;
                }
            }
        }
        return output.trim();
    }
}
NxContextMenuItemComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuItemComponent, deps: [{ token: i0.ElementRef }, { token: DOCUMENT, optional: true }, { token: i0.ChangeDetectorRef }, { token: i1.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxContextMenuItemComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxContextMenuItemComponent, selector: "[nxContextMenuItem]", inputs: { disabled: "disabled", disableCloseOnSelect: "disableCloseOnSelect" }, host: { attributes: { "role": "menuitem" }, listeners: { "mouseenter": "_handleMouseEnter()", "click": "_checkDisabled($event)" }, properties: { "class.is-highlighted": "_highlighted", "attr.tabindex": "_getTabIndex()", "attr.aria-disabled": "disabled.toString()", "attr.disabled": "disabled || null" }, classAttribute: "nx-context-menu-item" }, exportAs: ["nxContextMenuItem"], ngImport: i0, template: `
        <div class="nx-context-menu-item__content-wrapper" [class.has-submenu]="_triggersSubmenu">
            <ng-content></ng-content>
            <nx-icon *ngIf="_triggersSubmenu" class="nx-context-menu-item__expand" name="chevron-right-small"> </nx-icon>
        </div>
    `, isInline: true, styles: [":host{font-size:var(--context-menu-font-size);line-height:var(--context-menu-line-height);font-weight:var(--context-menu-font-weight);letter-spacing:var(--context-menu-letter-spacing);display:flex;align-items:center;cursor:pointer;text-align:left;width:100%;-webkit-appearance:none;appearance:none;border:none;outline:none;background:transparent;padding:8px 32px;color:var(--context-menu-item-text-color)}[dir=rtl] :host{padding:8px 32px}@media screen and (-ms-high-contrast: active){:host{-ms-high-contrast-adjust:none;background-color:buttonFace;color:buttonText}}:host:not(:disabled):hover,:host:not(:disabled):active,:host:not(:disabled).is-highlighted{color:var(--context-menu-item-active-color)}@media screen and (-ms-high-contrast: active){:host:not(:disabled):hover,:host:not(:disabled):active,:host:not(:disabled).is-highlighted{background-color:highlight;color:highlightText}}:host:disabled{cursor:not-allowed;color:var(--context-menu-item-disabled-color)}@media screen and (-ms-high-contrast: active){:host:disabled{color:GrayText}}:host::-moz-focus-inner{border:0}:host .nx-context-menu-item__content-wrapper{display:flex;align-items:center}:host .nx-context-menu-item__content-wrapper.has-submenu{width:100%}:host .nx-context-menu-item__content-wrapper ::ng-deep>nx-icon:not(.nx-context-menu-item__expand){margin-right:8px;font-size:var(--context-menu-item-icon-size)}[dir=rtl] :host .nx-context-menu-item__content-wrapper ::ng-deep>nx-icon:not(.nx-context-menu-item__expand){margin-right:0;margin-right:initial;margin-left:8px}:host .nx-context-menu-item__expand{font-size:var(--context-menu-item-expand-icon-size);padding-left:8px;margin-left:auto;margin-right:0;width:1em}[dir=rtl] :host .nx-context-menu-item__expand{margin-right:auto;margin-left:0;transform:rotate(180deg)}:host.cdk-keyboard-focused:focus .nx-context-menu-item__content-wrapper{border-radius:4px;outline:0;box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host.cdk-keyboard-focused:focus .nx-context-menu-item__content-wrapper{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}\n"], components: [{ type: i2.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuItemComponent, decorators: [{
            type: Component,
            args: [{ selector: '[nxContextMenuItem]', exportAs: 'nxContextMenuItem', host: {
                        class: 'nx-context-menu-item',
                        role: 'menuitem',
                        '[class.is-highlighted]': '_highlighted',
                        '[attr.tabindex]': '_getTabIndex()',
                        '[attr.aria-disabled]': 'disabled.toString()',
                        '[attr.disabled]': 'disabled || null',
                        '(mouseenter)': '_handleMouseEnter()',
                        '(click)': '_checkDisabled($event)',
                    }, changeDetection: ChangeDetectionStrategy.OnPush, template: `
        <div class="nx-context-menu-item__content-wrapper" [class.has-submenu]="_triggersSubmenu">
            <ng-content></ng-content>
            <nx-icon *ngIf="_triggersSubmenu" class="nx-context-menu-item__expand" name="chevron-right-small"> </nx-icon>
        </div>
    `, styles: [":host{font-size:var(--context-menu-font-size);line-height:var(--context-menu-line-height);font-weight:var(--context-menu-font-weight);letter-spacing:var(--context-menu-letter-spacing);display:flex;align-items:center;cursor:pointer;text-align:left;width:100%;-webkit-appearance:none;appearance:none;border:none;outline:none;background:transparent;padding:8px 32px;color:var(--context-menu-item-text-color)}[dir=rtl] :host{padding:8px 32px}@media screen and (-ms-high-contrast: active){:host{-ms-high-contrast-adjust:none;background-color:buttonFace;color:buttonText}}:host:not(:disabled):hover,:host:not(:disabled):active,:host:not(:disabled).is-highlighted{color:var(--context-menu-item-active-color)}@media screen and (-ms-high-contrast: active){:host:not(:disabled):hover,:host:not(:disabled):active,:host:not(:disabled).is-highlighted{background-color:highlight;color:highlightText}}:host:disabled{cursor:not-allowed;color:var(--context-menu-item-disabled-color)}@media screen and (-ms-high-contrast: active){:host:disabled{color:GrayText}}:host::-moz-focus-inner{border:0}:host .nx-context-menu-item__content-wrapper{display:flex;align-items:center}:host .nx-context-menu-item__content-wrapper.has-submenu{width:100%}:host .nx-context-menu-item__content-wrapper ::ng-deep>nx-icon:not(.nx-context-menu-item__expand){margin-right:8px;font-size:var(--context-menu-item-icon-size)}[dir=rtl] :host .nx-context-menu-item__content-wrapper ::ng-deep>nx-icon:not(.nx-context-menu-item__expand){margin-right:0;margin-right:initial;margin-left:8px}:host .nx-context-menu-item__expand{font-size:var(--context-menu-item-expand-icon-size);padding-left:8px;margin-left:auto;margin-right:0;width:1em}[dir=rtl] :host .nx-context-menu-item__expand{margin-right:auto;margin-left:0;transform:rotate(180deg)}:host.cdk-keyboard-focused:focus .nx-context-menu-item__content-wrapper{border-radius:4px;outline:0;box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){:host.cdk-keyboard-focused:focus .nx-context-menu-item__content-wrapper{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}\n"] }]
        }], ctorParameters: function () {
        return [{ type: i0.ElementRef }, { type: Document, decorators: [{
                        type: Optional
                    }, {
                        type: Inject,
                        args: [DOCUMENT]
                    }] }, { type: i0.ChangeDetectorRef }, { type: i1.FocusMonitor }];
    }, propDecorators: { disabled: [{
                type: Input
            }], disableCloseOnSelect: [{
                type: Input
            }] } });
/**
 * This directive is need when [nx-context-menu-item] is not directly under [nx-context-menu].
 *
 * <nx-context-menu>
 *      <something else> // blocker
 *        <nx-context-menu-item-wrap> // come to rescue
 *          <nx-context-menu-item/>
 *          <nx-context-menu-item/>
 *        </nx-context-menu-item-wrap>
 *      </something else>
 * </nx-context-menu>
 */
class NxContextMenuItemWrapComponent {
}
NxContextMenuItemWrapComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuItemWrapComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
NxContextMenuItemWrapComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxContextMenuItemWrapComponent, selector: "nx-context-menu-item-wrap", queries: [{ propertyName: "_items", predicate: NxContextMenuItemComponent }], ngImport: i0, template: `<ng-content></ng-content> `, isInline: true, changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuItemWrapComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'nx-context-menu-item-wrap',
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    template: `<ng-content></ng-content> `,
                }]
        }], propDecorators: { _items: [{
                type: ContentChildren,
                args: [NxContextMenuItemComponent]
            }] } });

class NxContextMenuComponent {
    constructor(_ngZone) {
        this._ngZone = _ngZone;
        this._init = new ReplaySubject(1);
        /** Config object to be passed into the menu's ngClass */
        this._classList = {};
        /** Current state of the panel animation. */
        this._panelAnimationState = 'void';
        /** Emits whenever an animation on the menu completes. */
        this._animationDone = new Subject();
        /** Whether the menu is animating. */
        this._isAnimating = false;
        /**
         * @docs-private
         * Layout direction of the menu.
         */
        this.direction = 'ltr';
        /** Event emitted when the menu is closed. */
        this.closed = new EventEmitter();
        this._destroyed = new Subject();
    }
    _onClick(event) {
        event.preventDefault();
    }
    ngAfterContentInit() {
        var _a;
        this._items = this._wrap ? (_a = this._wrap) === null || _a === void 0 ? void 0 : _a._items : this._items;
        this._keyManager = new FocusKeyManager(this._items).withWrap().withTypeAhead().setFocusOrigin('keyboard');
        this._keyManager.tabOut.pipe(takeUntil(this._destroyed)).subscribe(() => this.closed.emit('tab'));
        this._init.next();
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this.closed.complete();
        this._init.complete();
    }
    /** Stream that emits whenever the hovered menu item changes. */
    _hovered() {
        return this._init.pipe(switchMap(() => this._items.changes.pipe(startWith(this._items))), switchMap((items) => merge(...items.map(item => item._hovered))));
    }
    /** Handle a keyboard event from the menu, delegating to the appropriate action. */
    _handleKeydown(event) {
        const keyCode = event.keyCode;
        const manager = this._keyManager;
        switch (keyCode) {
            case ESCAPE:
                if (!hasModifierKey(event)) {
                    event.preventDefault();
                    this.closed.emit('keydown');
                }
                break;
            case LEFT_ARROW:
                if (this.parentMenu && this.direction === 'ltr') {
                    this.closed.emit('keydown');
                }
                break;
            case RIGHT_ARROW:
                if (this.parentMenu && this.direction === 'rtl') {
                    this.closed.emit('keydown');
                }
                break;
            case HOME:
            case END:
                if (!hasModifierKey(event)) {
                    keyCode === HOME ? manager.setFirstItemActive() : manager.setLastItemActive();
                    event.preventDefault();
                }
                break;
            default:
                manager.onKeydown(event);
        }
    }
    /**
     * Focus the first item in the menu.
     */
    focusFirstItem(origin) {
        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.
        this._ngZone.onStable
            .asObservable()
            .pipe(take(1))
            .subscribe(() => {
            var _a;
            this._keyManager.setFirstItemActive();
            (_a = this._keyManager.activeItem) === null || _a === void 0 ? void 0 : _a.focus(origin);
        });
    }
    /**
     * Resets the active item in the menu. This is used when the menu is opened, allowing
     * the user to start from the first option when pressing the down arrow.
     */
    resetActiveItem() {
        this._keyManager.setActiveItem(-1);
    }
    /** Starts the enter animation. */
    _startAnimation() {
        this._panelAnimationState = 'enter';
    }
    /** Resets the panel animation to its initial state. */
    _resetAnimation() {
        this._panelAnimationState = 'void';
    }
    /** Callback that is invoked when the panel animation completes. */
    _onAnimationDone(event) {
        this._animationDone.next(event);
        this._isAnimating = false;
    }
    _onAnimationStart(event) {
        this._isAnimating = true;
        // Scroll the content element to the top as soon as the animation starts. This is necessary,
        // because we move focus to the first item while it's still being animated, which can throw
        // the browser off when it determines the scroll position. Alternatively we can move focus
        // when the animation is done, however moving focus asynchronously will interrupt screen
        // readers which are in the process of reading out the menu already. We take the `element`
        // from the `event` since we can't use a `ViewChild` to access the pane.
        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {
            event.element.scrollTop = 0;
        }
    }
}
NxContextMenuComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuComponent, deps: [{ token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
NxContextMenuComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxContextMenuComponent, selector: "nx-context-menu", outputs: { closed: "closed" }, host: { listeners: { "click": "_onClick()" } }, queries: [{ propertyName: "_wrap", first: true, predicate: NxContextMenuItemWrapComponent, descendants: true }, { propertyName: "lazyContent", first: true, predicate: NxContextMenuContentDirective, descendants: true }, { propertyName: "_items", predicate: NxContextMenuItemComponent }], viewQueries: [{ propertyName: "templateRef", first: true, predicate: TemplateRef, descendants: true }], exportAs: ["nxContextMenu"], ngImport: i0, template: "<ng-template>\n    <div\n        class=\"nx-context-menu\"\n        [ngClass]=\"_classList\"\n        (keydown)=\"_handleKeydown($event)\"\n        (click)=\"closed.emit('click')\"\n        [@transformContextMenu]=\"_panelAnimationState\"\n        (@transformContextMenu.start)=\"_onAnimationStart($event)\"\n        (@transformContextMenu.done)=\"_onAnimationDone($event)\"\n        tabindex=\"-1\"\n        role=\"menu\"\n    >\n        <div class=\"nx-context-menu__content\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</ng-template>\n", styles: [".nx-context-menu{border-radius:4px;background:var(--context-menu-background-color);min-height:56px;box-shadow:var(--shadow-small);outline:none;overflow-y:auto}@media screen and (-ms-high-contrast: active){.nx-context-menu{border:1px solid windowText}}.nx-context-menu.ng-animating{pointer-events:none}.nx-context-menu__content:not(:empty){padding-top:8px;padding-bottom:8px;display:flex;flex-direction:column}@media screen and (-ms-high-contrast: active){.nx-context-menu__content:not(:empty){background-color:buttonFace}}\n"], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], animations: [nxContextMenuAnimations.transformContextMenu], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-context-menu', changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'nxContextMenu', animations: [nxContextMenuAnimations.transformContextMenu], template: "<ng-template>\n    <div\n        class=\"nx-context-menu\"\n        [ngClass]=\"_classList\"\n        (keydown)=\"_handleKeydown($event)\"\n        (click)=\"closed.emit('click')\"\n        [@transformContextMenu]=\"_panelAnimationState\"\n        (@transformContextMenu.start)=\"_onAnimationStart($event)\"\n        (@transformContextMenu.done)=\"_onAnimationDone($event)\"\n        tabindex=\"-1\"\n        role=\"menu\"\n    >\n        <div class=\"nx-context-menu__content\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</ng-template>\n", styles: [".nx-context-menu{border-radius:4px;background:var(--context-menu-background-color);min-height:56px;box-shadow:var(--shadow-small);outline:none;overflow-y:auto}@media screen and (-ms-high-contrast: active){.nx-context-menu{border:1px solid windowText}}.nx-context-menu.ng-animating{pointer-events:none}.nx-context-menu__content:not(:empty){padding-top:8px;padding-bottom:8px;display:flex;flex-direction:column}@media screen and (-ms-high-contrast: active){.nx-context-menu__content:not(:empty){background-color:buttonFace}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.NgZone }]; }, propDecorators: { _items: [{
                type: ContentChildren,
                args: [NxContextMenuItemComponent]
            }], _wrap: [{
                type: ContentChild,
                args: [NxContextMenuItemWrapComponent]
            }], templateRef: [{
                type: ViewChild,
                args: [TemplateRef]
            }], lazyContent: [{
                type: ContentChild,
                args: [NxContextMenuContentDirective]
            }], closed: [{
                type: Output
            }], _onClick: [{
                type: HostListener,
                args: ['click']
            }] } });

class NxContextMenuHeaderComponent {
}
NxContextMenuHeaderComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuHeaderComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
NxContextMenuHeaderComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxContextMenuHeaderComponent, selector: "nx-context-menu-header", host: { classAttribute: "nx-context-menu-header" }, ngImport: i0, template: '<ng-content></ng-content>', isInline: true, styles: [":host{font-size:var(--formfield-label-font-size);line-height:var(--formfield-label-line-height);font-weight:var(--formfield-label-font-weight);letter-spacing:var(--formfield-label-letter-spacing);color:var(--dropdown-panel-header-text-color);background-color:var(--dropdown-panel-header-background-color);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;position:relative;top:-8px;font-weight:700}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuHeaderComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-context-menu-header', template: '<ng-content></ng-content>', host: {
                        class: 'nx-context-menu-header',
                    }, changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{font-size:var(--formfield-label-font-size);line-height:var(--formfield-label-line-height);font-weight:var(--formfield-label-font-weight);letter-spacing:var(--formfield-label-letter-spacing);color:var(--dropdown-panel-header-text-color);background-color:var(--dropdown-panel-header-background-color);padding:8px 32px;border-top-left-radius:4px;border-top-right-radius:4px;z-index:1;position:relative;top:-8px;font-weight:700}\n"] }]
        }] });

/**
 * Throws an exception for the case when menu trigger doesn't have a valid nx-context-menu instance
 * @docs-private
 */
function throwNxContextMenuMissingError() {
    throw Error(`nxContextMenuTriggerFor: must pass in an nx-context-menu instance.
    Example:
      <nx-context-menu #contextMenu="nxContextMenu"></nx-context-menu>
      <button [nxContextMenuTriggerFor]="contextMenu"></button>`);
}

var _NxContextMenuTriggerDirective_scrollStrategy;
/** Default top padding of the menu panel. */
const MENU_PANEL_TOP_PADDING = 8;
const MENU_PANEL_OFFSET_Y = 8;
const MENU_PANEL_OFFSET_X = 8;
/** Injection token that determines the scroll handling while a context-menu is open. */
const NX_CONTEXT_MENU_SCROLL_STRATEGY = new InjectionToken('nx-context-menu-scroll-strategy');
/** @docs-private */
function NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/** @docs-private */
const NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_CONTEXT_MENU_SCROLL_STRATEGY,
    useFactory: NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
/**
 * This directive is intended to be used in conjunction with an nx-context-menu tag.
 * It is responsible for toggling the display of the provided context menu instance.
 */
class NxContextMenuTriggerDirective {
    constructor(_overlay, _element, _viewContainerRef, _parentMenu, _contextMenuItemInstance, _dir, _triggerButton, _defaultScrollStrategyFactory, _cdr) {
        var _a;
        this._overlay = _overlay;
        this._element = _element;
        this._viewContainerRef = _viewContainerRef;
        this._parentMenu = _parentMenu;
        this._contextMenuItemInstance = _contextMenuItemInstance;
        this._dir = _dir;
        this._triggerButton = _triggerButton;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this._cdr = _cdr;
        this._overlayRef = null;
        this._contextMenuOpen = false;
        this._closingActionsSubscription = Subscription.EMPTY;
        this._contextMenuCloseSubscription = Subscription.EMPTY;
        /** Strategy factory that will be used to handle scrolling while the context-menu panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
        _NxContextMenuTriggerDirective_scrollStrategy.set(this, void 0);
        /**
         * Sets the mode of this context menu trigger.
         * 'button' (default): Opens by clicking the trigger
         * 'cursor': Opens at the cursor position by right clicking anywhere on the trigger.
         */
        this.mode = 'button';
        /** Event emitted when the associated context menu is opened. */
        this.contextMenuOpened = new EventEmitter();
        /** Event emitted when the associated context menu is closed. */
        this.contextMenuClosed = new EventEmitter();
        this._destroyed = new Subject();
        this._rightClicked = false;
        if (_contextMenuItemInstance) {
            _contextMenuItemInstance._triggersSubmenu = this.triggersSubmenu();
        }
        this._documentClickObservable = fromEvent(document, 'click');
        (_a = this._dir) === null || _a === void 0 ? void 0 : _a.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
            if (this.contextMenuOpen) {
                // HINT: closing menu on direction change.
                // When user re-opens it, the overlay and menu will be initialized properly, based on new direction.
                this.closeContextMenu();
            }
        });
    }
    /** References the context menu instance that the trigger is associated with. */
    get contextMenu() {
        return this._contextMenu;
    }
    set contextMenu(contextMenu) {
        if (contextMenu === this._contextMenu) {
            return;
        }
        this._contextMenu = contextMenu;
        this._contextMenuCloseSubscription.unsubscribe();
        if (contextMenu) {
            this._contextMenuCloseSubscription = contextMenu.closed.asObservable().subscribe(reason => {
                this._destroyMenu();
                // If a click closed the menu, we should close the entire chain of nested menus.
                if ((reason === 'click' || reason === 'tab') && this._parentMenu) {
                    this._parentMenu.closed.emit(reason);
                }
            });
        }
    }
    set scrollStrategy(value) {
        if (__classPrivateFieldGet(this, _NxContextMenuTriggerDirective_scrollStrategy, "f") !== value) {
            __classPrivateFieldSet(this, _NxContextMenuTriggerDirective_scrollStrategy, value, "f");
            this._scrollStrategyFactory = value ? this.getScrollStrtegyFactory(value) : this._defaultScrollStrategyFactory;
            this._cdr.markForCheck();
        }
    }
    get scrollStrategy() {
        return __classPrivateFieldGet(this, _NxContextMenuTriggerDirective_scrollStrategy, "f");
    }
    /** Whether the context menu is open. */
    get contextMenuOpen() {
        return this._contextMenuOpen;
    }
    /** The text direction of the containing app. */
    get dir() {
        var _a;
        return ((_a = this._dir) === null || _a === void 0 ? void 0 : _a.value) === 'rtl' ? 'rtl' : 'ltr';
    }
    ngAfterContentInit() {
        this._checkContextMenu();
        this._handleHover();
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
        this._contextMenuCloseSubscription.unsubscribe();
        this._closingActionsSubscription.unsubscribe();
    }
    /** Whether the context menu triggers a sub-menu or a top-level one. */
    triggersSubmenu() {
        return !!(this._contextMenuItemInstance && this._parentMenu);
    }
    /** Toggles the context menu between the open and closed states. */
    toggleContextMenu(origin) {
        return this.contextMenuOpen ? this.closeContextMenu() : this.openContextMenu(origin);
    }
    /** Opens the context menu. */
    openContextMenu(origin, position) {
        if (this.contextMenuOpen) {
            return;
        }
        this._checkContextMenu();
        const overlayRef = this._createOverlay();
        const overlayConfig = overlayRef.getConfig();
        if (position) {
            this._setPositionToCursor(overlayConfig.positionStrategy, position);
        }
        else {
            this._setPosition(overlayConfig.positionStrategy);
        }
        overlayRef.attach(this._getPortal());
        if (this.contextMenu.lazyContent) {
            this.contextMenu.lazyContent.attach(this.contextMenuData);
        }
        this._closingActionsSubscription = this._contextMenuClosingActions().subscribe(() => this.closeContextMenu());
        this._initContextMenu(origin);
        if (this.contextMenu instanceof NxContextMenuComponent) {
            this.contextMenu._startAnimation();
        }
        if (this._triggerButton) {
            this._triggerButton.setTriggerActive();
            this.contextMenu.closed.pipe(take(1)).subscribe(() => { var _a; return (_a = this._triggerButton) === null || _a === void 0 ? void 0 : _a.setTriggerInactive(); });
        }
        this._waitForClose();
    }
    /** Closes the context menu. */
    closeContextMenu() {
        this._rightClicked = false;
        this.contextMenu.closed.emit();
    }
    getScrollStrtegyFactory(scrollStrategy) {
        switch (scrollStrategy) {
            case 'close':
                return this._overlay.scrollStrategies.close;
            default:
                return this._overlay.scrollStrategies.reposition;
        }
    }
    /** Closes the context menu and does the necessary cleanup. */
    _destroyMenu() {
        if (!this._overlayRef || !this.contextMenuOpen) {
            return;
        }
        const contextMenu = this.contextMenu;
        this._closingActionsSubscription.unsubscribe();
        this._overlayRef.detach();
        contextMenu._resetAnimation();
        if (contextMenu.lazyContent) {
            // Wait for the exit animation to finish before detaching the content.
            contextMenu._animationDone
                .pipe(filter(event => event.toState === 'void'), take(1), 
            // Interrupt if the content got re-attached.
            takeUntil(contextMenu.lazyContent._attached))
                .subscribe({
                next: () => { var _a; return (_a = contextMenu.lazyContent) === null || _a === void 0 ? void 0 : _a.detach(); },
                // No matter whether the content got re-attached, reset the menu.
                complete: () => this._resetContextMenu(),
            });
        }
        else {
            this._resetContextMenu();
        }
    }
    /**
     * This method sets the context menu state to open and focuses the first item if
     * the context menu was opened via the keyboard.
     */
    _initContextMenu(origin) {
        var _a;
        this.contextMenu.parentMenu = this.triggersSubmenu() ? (_a = this._parentMenu) !== null && _a !== void 0 ? _a : undefined : undefined;
        this.contextMenu.direction = this.dir;
        this._setIsContextMenuOpen(true);
        this.contextMenu.focusFirstItem(origin);
    }
    /**
     * Focuses the context menu trigger.
     */
    focus() {
        this._element.nativeElement.focus();
    }
    /**
     * This method resets the context menu when it's closed, most importantly restoring
     * focus to the context menu trigger if the context menu was opened via the keyboard.
     */
    _resetContextMenu() {
        this._setIsContextMenuOpen(false);
        this.focus();
    }
    /** Set state rather than toggle to support triggers sharing a menu. */
    _setIsContextMenuOpen(isOpen) {
        this._contextMenuOpen = isOpen;
        this._contextMenuOpen ? this.contextMenuOpened.emit() : this.contextMenuClosed.emit();
        if (this.triggersSubmenu()) {
            this._contextMenuItemInstance._highlighted = isOpen;
        }
    }
    /**
     * This method checks that a valid instance of NxContextMenuComponent has been passed into
     * nxContextMenuTriggerFor. If not, an exception is thrown.
     */
    _checkContextMenu() {
        if (!this.contextMenu) {
            throwNxContextMenuMissingError();
        }
    }
    /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
     */
    _createOverlay() {
        if (!this._overlayRef) {
            const config = this._getOverlayConfig();
            this._overlayRef = this._overlay.create(config);
            // Consume the `keydownEvents` in order to prevent them from going to another overlay.
            this._overlayRef.keydownEvents().pipe(takeUntil(this._destroyed)).subscribe();
        }
        return this._overlayRef;
    }
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @returns OverlayConfig
     */
    _getOverlayConfig() {
        var _a;
        return new OverlayConfig({
            positionStrategy: this._overlay
                .position()
                .flexibleConnectedTo(this._element)
                .withLockedPosition()
                .withFlexibleDimensions(false)
                .withTransformOriginOn('.nx-context-menu'),
            scrollStrategy: this._scrollStrategyFactory(),
            direction: (_a = this._dir) !== null && _a !== void 0 ? _a : undefined,
        });
    }
    /**
     * Sets the position on a position strategy so the overlay is placed at the cursor.
     * @param positionStrategy Strategy whose position to update.
     * @param position Position of the cursor.
     */
    _setPositionToCursor(positionStrategy, cursorPosition) {
        positionStrategy.setOrigin(cursorPosition);
        positionStrategy.withPositions([
            {
                overlayX: 'start',
                overlayY: 'top',
                originX: 'center',
                originY: 'center',
            },
            {
                overlayX: 'start',
                overlayY: 'bottom',
                originX: 'center',
                originY: 'center',
            },
            {
                overlayX: 'end',
                overlayY: 'top',
                originX: 'center',
                originY: 'center',
            },
            {
                overlayX: 'end',
                overlayY: 'bottom',
                originX: 'center',
                originY: 'center',
            },
        ]);
    }
    /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @param positionStrategy Strategy whose position to update.
     */
    _setPosition(positionStrategy) {
        let originX = 'start';
        let originFallbackX = 'end';
        const overlayY = 'top';
        const overlayFallbackY = 'bottom';
        let originY = overlayY;
        let originFallbackY = overlayFallbackY;
        let overlayX = originX;
        let overlayFallbackX = originFallbackX;
        let offsetX = 0;
        let offsetY = 0;
        if (this.triggersSubmenu()) {
            // When the menu is a sub-menu, it should always align itself
            // to the edges of the trigger, instead of overlapping it.
            overlayFallbackX = originX = 'end';
            originFallbackX = overlayX = 'start';
            offsetX = this.dir === 'rtl' ? -MENU_PANEL_OFFSET_X : MENU_PANEL_OFFSET_X;
            offsetY = -MENU_PANEL_TOP_PADDING;
        }
        else {
            offsetY = MENU_PANEL_OFFSET_Y;
            originY = 'bottom';
            originFallbackY = 'top';
        }
        positionStrategy.withPositions([
            { originX, originY, overlayX, overlayY, offsetX, offsetY },
            {
                originX: originFallbackX,
                originY,
                overlayX: overlayFallbackX,
                overlayY,
                offsetX: -offsetX,
                offsetY,
            },
            {
                originX,
                originY: originFallbackY,
                overlayX,
                overlayY: overlayFallbackY,
                offsetX,
                offsetY: -offsetY,
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetX: -offsetX,
                offsetY: -offsetY,
            },
        ]);
    }
    /**
     * Returns a stream that emits whenever an action that should close the context menu occurs. */
    _contextMenuClosingActions() {
        let backdrop;
        let detachments;
        if (this._overlayRef) {
            backdrop = this._overlayRef.backdropClick();
            detachments = this._overlayRef.detachments();
        }
        const parentClose = this._parentMenu ? this._parentMenu.closed : of();
        const hover = this._parentMenu
            ? this._parentMenu._hovered().pipe(filter(active => active !== this._contextMenuItemInstance), filter(() => this._contextMenuOpen))
            : of();
        return merge(backdrop, parentClose, hover, detachments);
    }
    /** Handles mouse presses on the trigger. */
    _handleMousedown(event) {
        // Since right or middle button clicks won't trigger the `click` event,
        // we shouldn't consider the menu as opened by mouse in those cases.
        // this._openedBy = event.button === 0 ? 'mouse' : null;
        // Since clicking on the trigger won't close the menu if it opens a sub-menu,
        // we should prevent focus from moving onto it via click to avoid the
        // highlight from lingering on the menu item.
        if (this.triggersSubmenu()) {
            event.preventDefault();
        }
    }
    _handleRightClick(event) {
        if (this.mode !== 'cursor') {
            return;
        }
        this._rightClicked = true;
        event.preventDefault();
        if (this._contextMenuOpen) {
            this.closeContextMenu();
        }
        const position = {
            x: event.clientX,
            y: event.clientY,
        };
        this.openContextMenu('mouse', position);
    }
    /** Handles key presses on the trigger. */
    _handleKeydown(event) {
        if (this.mode !== 'button') {
            return;
        }
        const keyCode = event.keyCode;
        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') || (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {
            this.openContextMenu('keyboard');
        }
    }
    /** Handles click events on the trigger. */
    _handleClick(event) {
        if (this.mode !== 'button') {
            return;
        }
        event.preventDefault();
        const origin = event.detail ? 'program' : 'keyboard';
        if (this.triggersSubmenu()) {
            // Stop event propagation to avoid closing the parent menu.
            event.stopPropagation();
            this.openContextMenu(origin);
        }
        else {
            this.toggleContextMenu(origin);
        }
    }
    /* Subscribes to document clicks to close the context menu on clicks on the background. */
    _waitForClose() {
        if (this._rightClicked) {
            return this._documentClickObservable
                .pipe(filter(event => !event.defaultPrevented), takeUntil(this.contextMenu.closed))
                .subscribe(() => {
                this.closeContextMenu();
            });
        }
        return this._documentClickObservable
            .pipe(map(event => _getEventTarget(event)), filter(target => !this._element.nativeElement.contains(target)), takeUntil(this.contextMenu.closed))
            .subscribe(() => {
            this.closeContextMenu();
        });
    }
    /** Handles the cases where the user hovers over the trigger. */
    _handleHover() {
        // Subscribe to changes in the hovered item in order to toggle the panel.
        if (!this.triggersSubmenu()) {
            return;
        }
        this._parentMenu._hovered()
            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
            // with different data and triggers), we have to delay it by a tick to ensure that
            // it won't be closed immediately after it is opened.
            .pipe(filter(active => active === this._contextMenuItemInstance && !active.disabled), delay(0, asapScheduler), takeUntil(this._destroyed))
            .subscribe(() => {
            // If the same menu is used between multiple triggers, it might still be animating
            // while the new trigger tries to re-open it. Wait for the animation to finish
            // before doing so. Also interrupt if the user moves to another item.
            if (this.contextMenu._isAnimating) {
                // We need the `delay(0)` here in order to avoid
                // 'changed after checked' errors in some cases.
                this.contextMenu._animationDone
                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))
                    .subscribe(() => this.openContextMenu('mouse'));
            }
            else {
                this.openContextMenu('mouse');
            }
        });
    }
    /** Gets the portal that should be attached to the overlay. */
    _getPortal() {
        // Note that we can avoid this check by keeping the portal on the context menu panel.
        // While it would be cleaner, we'd have to introduce another required method on
        // `NxContextMenuPanelComponent`, making it harder to consume.
        if (!this._portal || this._portal.templateRef !== this.contextMenu.templateRef) {
            this._portal = new TemplatePortal(this.contextMenu.templateRef, this._viewContainerRef);
        }
        return this._portal;
    }
}
_NxContextMenuTriggerDirective_scrollStrategy = new WeakMap();
NxContextMenuTriggerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuTriggerDirective, deps: [{ token: i1$1.Overlay }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: NxContextMenuComponent, optional: true }, { token: NxContextMenuItemComponent, optional: true, self: true }, { token: i4.Directionality, optional: true }, { token: i5.NxTriggerButton, optional: true, self: true }, { token: NX_CONTEXT_MENU_SCROLL_STRATEGY }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
NxContextMenuTriggerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxContextMenuTriggerDirective, selector: "[nxContextMenuTriggerFor]", inputs: { contextMenu: ["nxContextMenuTriggerFor", "contextMenu"], scrollStrategy: "scrollStrategy", contextMenuData: ["nxContextMenuTriggerData", "contextMenuData"], mode: ["nxContextMenuTriggerMode", "mode"] }, outputs: { contextMenuOpened: "contextMenuOpened", contextMenuClosed: "contextMenuClosed" }, host: { attributes: { "aria-haspopup": "true" }, listeners: { "mousedown": "_handleMousedown($event)", "keydown": "_handleKeydown($event)", "click": "_handleClick($event)", "contextmenu": "_handleRightClick($event)" }, properties: { "attr.aria-expanded": "contextMenuOpen || null" } }, exportAs: ["nxContextMenuTrigger"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `[nxContextMenuTriggerFor]`,
                    host: {
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'contextMenuOpen || null',
                        '(mousedown)': '_handleMousedown($event)',
                        '(keydown)': '_handleKeydown($event)',
                        '(click)': '_handleClick($event)',
                        '(contextmenu)': '_handleRightClick($event)',
                    },
                    exportAs: 'nxContextMenuTrigger',
                }]
        }], ctorParameters: function () {
        return [{ type: i1$1.Overlay }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: NxContextMenuComponent, decorators: [{
                        type: Optional
                    }] }, { type: NxContextMenuItemComponent, decorators: [{
                        type: Optional
                    }, {
                        type: Self
                    }] }, { type: i4.Directionality, decorators: [{
                        type: Optional
                    }] }, { type: i5.NxTriggerButton, decorators: [{
                        type: Optional
                    }, {
                        type: Self
                    }] }, { type: undefined, decorators: [{
                        type: Inject,
                        args: [NX_CONTEXT_MENU_SCROLL_STRATEGY]
                    }] }, { type: i0.ChangeDetectorRef }];
    }, propDecorators: { contextMenu: [{
                type: Input,
                args: ['nxContextMenuTriggerFor']
            }], scrollStrategy: [{
                type: Input
            }], contextMenuData: [{
                type: Input,
                args: ['nxContextMenuTriggerData']
            }], mode: [{
                type: Input,
                args: ['nxContextMenuTriggerMode']
            }], contextMenuOpened: [{
                type: Output
            }], contextMenuClosed: [{
                type: Output
            }] } });

const EXPORTED_MODULES = [
    NxContextMenuComponent,
    NxContextMenuContentDirective,
    NxContextMenuItemComponent,
    NxContextMenuItemWrapComponent,
    NxContextMenuTriggerDirective,
    NxContextMenuHeaderComponent,
];
class NxContextMenuModule {
}
NxContextMenuModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxContextMenuModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuModule, declarations: [NxContextMenuComponent,
        NxContextMenuContentDirective,
        NxContextMenuItemComponent,
        NxContextMenuItemWrapComponent,
        NxContextMenuTriggerDirective,
        NxContextMenuHeaderComponent], imports: [CommonModule, OverlayModule, NxIconModule], exports: [NxContextMenuComponent,
        NxContextMenuContentDirective,
        NxContextMenuItemComponent,
        NxContextMenuItemWrapComponent,
        NxContextMenuTriggerDirective,
        NxContextMenuHeaderComponent] });
NxContextMenuModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuModule, providers: [NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER], imports: [[CommonModule, OverlayModule, NxIconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OverlayModule, NxIconModule],
                    exports: EXPORTED_MODULES,
                    declarations: EXPORTED_MODULES,
                    providers: [NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { MENU_PANEL_OFFSET_X, MENU_PANEL_OFFSET_Y, MENU_PANEL_TOP_PADDING, NX_CONTEXT_MENU_SCROLL_STRATEGY, NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER, NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER_FACTORY, NxContextMenuComponent, NxContextMenuContentDirective, NxContextMenuHeaderComponent, NxContextMenuItemComponent, NxContextMenuItemWrapComponent, NxContextMenuModule, NxContextMenuTriggerDirective };
//# sourceMappingURL=aposin-ng-aquila-context-menu.mjs.map
