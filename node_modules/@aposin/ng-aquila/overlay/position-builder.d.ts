import { Directionality } from '@angular/cdk/bidi';
import { FlexibleConnectedPositionStrategyOrigin, OriginConnectionPosition, Overlay, OverlayConnectionPosition } from '@angular/cdk/overlay';
import { NxOverlayConfig, NxOverlayDirection } from './overlay-config';
import * as i0 from "@angular/core";
/**
 * Creates an error to be thrown if the user provided an invalid popover direction.
 * @docs-private
 */
export declare function getNxOverlayInvalidDirectionError(direction: string): Error;
export declare const OVERLAY_POSITIONS: {
    [key in NxOverlayDirection]: (isRtl: boolean) => OverlayConnectionPosition;
};
export declare const ORIGIN_POSITIONS: {
    [key in NxOverlayDirection]: (arg0: boolean) => OriginConnectionPosition;
};
export declare class NxOverlayPositionBuilder {
    private _overlay;
    private _dir;
    constructor(_overlay: Overlay, _dir: Directionality | null);
    createPositionStrategy(element: FlexibleConnectedPositionStrategyOrigin, config: NxOverlayConfig): import("@angular/cdk/overlay").FlexibleConnectedPositionStrategy;
    /**
     * Returns the origin position based on the user's direction preference.
     */
    getOrigin(direction: NxOverlayDirection | undefined): OriginConnectionPosition;
    /** Returns the overlay position based on the user's direction preference */
    getOverlayPosition(direction: NxOverlayDirection | undefined): OverlayConnectionPosition;
    /** Returns the overlay offset required by the user's direction preference */
    getOffset(direction: NxOverlayDirection | undefined, config: NxOverlayConfig): {
        offsetY: number;
        offsetX?: undefined;
    } | {
        offsetX: number;
        offsetY?: undefined;
    };
    /** Returns an array of fallback positions for popover, following the algoritm:
     * 1) Slightly alternate preferred position if applicable. I.e. for 'top' try 'top-start' and 'top-end' positioning.
     * 2) Try the opposite position, i.e. for 'top' try 'bottom'.
     * 3) Slightly alternate opposite position, i.e. 'bottom-start', 'bottom-end'
     * 4) All remaining positions from positions list
     */
    private _getFallbackPositions;
    /** Takes the defined fallback orders and adjusts it for the requested direction */
    private _getFallbackOrder;
    private _splitDirection;
    get isRtl(): boolean;
    /** Returns the opposite position, using angular position naming: top, bottom, start, end, center */
    private _getInversePosition;
    /** Resolve the fallback order to all possible direction. For top and bottom we want to add the start and end positions. */
    private _resolveFallbacks;
    static ɵfac: i0.ɵɵFactoryDeclaration<NxOverlayPositionBuilder, [null, { optional: true; }]>;
    static ɵprov: i0.ɵɵInjectableDeclaration<NxOverlayPositionBuilder>;
}
