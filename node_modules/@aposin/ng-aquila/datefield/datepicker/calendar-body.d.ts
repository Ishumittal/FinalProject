/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { FocusMonitor } from '@angular/cdk/a11y';
import { AfterViewInit, ElementRef, EventEmitter, NgZone, OnDestroy, QueryList } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * An internal class that represents the data corresponding to a single calendar cell.
 * @docs-private
 */
export declare class NxCalendarCell {
    value: number;
    displayValue: string;
    ariaLabel?: string | undefined;
    enabled?: boolean | undefined;
    constructor(value: number, displayValue: string, ariaLabel?: string | undefined, enabled?: boolean | undefined);
}
/**
 * An internal component used to display calendar data in a table.
 * @docs-private
 */
export declare class NxCalendarBodyComponent implements AfterViewInit, OnDestroy {
    private _elementRef;
    private _ngZone;
    private _focusMonitor;
    /** The label for the table. (e.g. "Jan 2017"). */
    label: string;
    /** The cells to display in the table. */
    rows: NxCalendarCell[][];
    /** The value in the table that corresponds to today. */
    todayValue: number;
    /** The value in the table that is currently selected. */
    selectedValue: number;
    /** The number of columns in the table. */
    numCols: number;
    /** Whether to allow selection of disabled cells. */
    allowDisabledSelection: boolean;
    /** The cell number of the active cell in the table. */
    activeCell: number;
    /** The items to display in the first row in the offset space. */
    previousItems: NxCalendarCell[];
    /** The items to display in the last row in the offset space. */
    followingItems: NxCalendarCell[][];
    /** Emits when a new value out of rows is selected. */
    readonly selectedValueChange: EventEmitter<number>;
    /** Emits when a new value out of previousItems is selected. */
    readonly selectedValueChangeToPrevious: EventEmitter<number>;
    /** Emits when a new value out of followingItems is selected. */
    readonly selectedValueChangeToFollowing: EventEmitter<number>;
    _cells: QueryList<ElementRef<HTMLElement>>;
    /** Preserves the current value of the _cells ViewChildren in case _cells changes. */
    private _cellsPrevious;
    private readonly _destroyed;
    constructor(_elementRef: ElementRef, _ngZone: NgZone, _focusMonitor: FocusMonitor);
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    _previousCellClicked(cell: NxCalendarCell): void;
    _cellClicked(cell: NxCalendarCell): void;
    _followingCellClicked(cell: NxCalendarCell): void;
    /** The number of blank cells to put at the beginning for the first row. */
    get _firstRowOffset(): number;
    /** The number of blank cells to put at the end of the last filled row. */
    get _lastRowOffset(): number;
    /** The index of the last row. */
    get _lastRowIndex(): number;
    /**
     * The following full rows to display and fill up the calendar.
     */
    get _followingRows(): NxCalendarCell[][];
    _isActiveCell(rowIndex: number, colIndex: number): boolean;
    /** Focuses the active cell after the microtask queue is empty. */
    _focusActiveCell(): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NxCalendarBodyComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<NxCalendarBodyComponent, "[nx-calendar-body]", ["nxCalendarBody"], { "label": "label"; "rows": "rows"; "todayValue": "todayValue"; "selectedValue": "selectedValue"; "numCols": "numCols"; "allowDisabledSelection": "allowDisabledSelection"; "activeCell": "activeCell"; "previousItems": "previousItems"; "followingItems": "followingItems"; }, { "selectedValueChange": "selectedValueChange"; "selectedValueChangeToPrevious": "selectedValueChangeToPrevious"; "selectedValueChangeToFollowing": "selectedValueChangeToFollowing"; }, never, never>;
}
