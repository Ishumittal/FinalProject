import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, BACKSPACE, SPACE } from '@angular/cdk/keycodes';
import * as i0 from '@angular/core';
import { Injectable, Component, ChangeDetectionStrategy, Optional, Self, Input, NgModule } from '@angular/core';
import * as i1 from '@angular/forms';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';
import { Subject } from 'rxjs';
import * as i3 from '@aposin/ng-aquila/utils';
import * as i4 from '@angular/common';
import { CommonModule } from '@angular/common';

class NxCodeInputIntl {
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        /** Label that should replace the 'Enter key' of the aria-label. */
        this.inputFieldAriaLabel = 'Enter Key';
        /** Label that should replace the 'of' of the aria-label. */
        this.ofLabel = 'of';
    }
}
NxCodeInputIntl.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputIntl, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NxCodeInputIntl.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputIntl });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputIntl, decorators: [{
            type: Injectable
        }] });

const DEFAULT_INPUT_LENGTH = 6;
const TAG_NAME_INPUT = 'INPUT';
const AUTO_UPPERCASE = 'upper';
const AUTO_LOWERCASE = 'lower';
const INPUT_FIELD_GAP = 'nx-code-input--field-with-gap';
class NxCodeInputComponent {
    constructor(_cdr, _el, _control, _intl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this._cdr = _cdr;
        this._el = _el;
        this._control = _control;
        this._intl = _intl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        /** Whether the current input of the component has an error. */
        this.errorState = false;
        this._codeLength = DEFAULT_INPUT_LENGTH;
        this._type = 'text';
        this._isUpDown = false;
        this._tabindex = 0;
        /** The user input in array form */
        this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
        this._focused = false;
        this._negative = false;
        this._disabled = false;
        /** @docs-private */
        this.propagateChange = (_) => { };
        /** @docs-private */
        this.propagateTouch = (_) => { };
        if (this._control) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this._control.valueAccessor = this;
        }
    }
    /** The length of the code input. Default: 6. */
    set codeLength(value) {
        this._codeLength = value;
        this.setInputLength();
        this._cdr.markForCheck();
    }
    get codeLength() {
        return this._codeLength;
    }
    /** The type of HTML input */
    set type(value) {
        this._type = value;
        this._cdr.markForCheck();
    }
    get type() {
        return this._type;
    }
    /** Sets the tabindex of the contained input elements. */
    set tabindex(value) {
        this._tabindex = value;
        this._cdr.markForCheck();
    }
    get tabindex() {
        return this._tabindex;
    }
    /** Whether the form should auto capitalize or lowercase (optional). */
    set convertTo(value) {
        this._convertTo = value;
        this._cdr.markForCheck();
    }
    get convertTo() {
        return this._convertTo;
    }
    /** Whether the code input uses the negative set of styling. */
    set negative(value) {
        const newValue = coerceBooleanProperty(value);
        if (this._negative !== newValue) {
            this._negative = newValue;
            this._cdr.markForCheck();
        }
    }
    get negative() {
        return this._negative;
    }
    /** Whether the code input is disabled. */
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._cdr.markForCheck();
        }
    }
    get disabled() {
        return this._disabled;
    }
    ngDoCheck() {
        if (this._control) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    /** Sets the length of the input fields. */
    setInputLength() {
        if (this.codeLength) {
            this._keyCode = new Array(this.codeLength);
        }
        else {
            this._keyCode = new Array(DEFAULT_INPUT_LENGTH);
        }
    }
    /** Converts to upper or lowercase when enabled. */
    _convertLetterSize(value) {
        if (value === 'ß') {
            return value;
        }
        if (typeof value === 'string') {
            if (this.convertTo === AUTO_UPPERCASE) {
                return value.toUpperCase();
            }
            else if (this.convertTo === AUTO_LOWERCASE) {
                return value.toLowerCase();
            }
            return value;
        }
        return undefined;
    }
    /** Reacts to keydown event. */
    _keydownAction(event) {
        const targetElement = event.target;
        const previousInputField = targetElement.previousElementSibling;
        const nextInputField = targetElement.nextElementSibling;
        switch (event.keyCode) {
            case SPACE:
                return false;
            case BACKSPACE:
                if (targetElement.value === '') {
                    if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                        this.selectInput(previousInputField);
                    }
                }
                break;
            case LEFT_ARROW:
                if (previousInputField && previousInputField.tagName === TAG_NAME_INPUT) {
                    event.preventDefault();
                    this.selectInput(previousInputField);
                }
                break;
            case RIGHT_ARROW:
                if (nextInputField && nextInputField.tagName === TAG_NAME_INPUT) {
                    this.selectInput(nextInputField);
                }
                event.preventDefault();
                break;
            case DOWN_ARROW:
                this._isUpDown = true;
                if (this._type === 'number' && (targetElement.value === '' || targetElement.value === '0')) {
                    event.preventDefault();
                }
                break;
            case UP_ARROW:
                this._isUpDown = true;
                if (this._type === 'number' && targetElement.value === '9') {
                    event.preventDefault();
                }
                break;
            default:
                break;
        }
    }
    /** Selects the value on click of an input field. */
    _selectText(event) {
        this.selectInput(event.target);
    }
    /** Automatically focuses and selects the next input on key input. */
    _selectNextInput(event) {
        const eventTarget = event.target;
        eventTarget.value = this._convertLetterSize(eventTarget.value.slice(0, 1));
        const currentIndex = Number(this._getFocusedInputIndex(event));
        // save in model with uppercase if needed
        this._keyCode[currentIndex] = eventTarget.value;
        this.propagateChange(this._keyCode.join(''));
        // don't jump to next input if the user uses UP/DOWn arrow (native behaviour)
        const focusNextInput = !(this._isUpDown && this.type === 'number');
        if (eventTarget.value && focusNextInput) {
            const nextInputField = eventTarget.nextSibling;
            if (nextInputField !== null && nextInputField.tagName === TAG_NAME_INPUT) {
                nextInputField.focus();
                if (nextInputField.value !== '') {
                    this.selectInput(nextInputField);
                }
            }
        }
        this._isUpDown = false;
    }
    /** Paste event to distribute content in input fields. */
    _pasteClipboard(event) {
        let copiedText = (event.clipboardData || window.clipboardData).getData('text');
        let copiedTextIndex = 0;
        const inputIndex = Number(this._getFocusedInputIndex(event));
        copiedText = this.type === 'number' ? this._formatNumberInput(copiedText) : copiedText;
        for (let i = inputIndex; i < this.codeLength; i++) {
            this._keyCode[i] = this._convertLetterSize(copiedText[copiedTextIndex]);
            copiedTextIndex++;
        }
        this.propagateChange(this._keyCode.join(''));
        if (inputIndex + copiedText.length < this.codeLength) {
            this._el.nativeElement.children.item(inputIndex + copiedText.length).focus();
        }
        else {
            this._el.nativeElement.children.item(this.codeLength - 1).focus();
        }
        event.preventDefault();
    }
    /** Returns the index of the code input, which is currently focused. */
    _getFocusedInputIndex(event) {
        let inputIndex;
        for (let i = 0; i < this._el.nativeElement.children.length; i++) {
            if (event.srcElement === this._el.nativeElement.children.item(i)) {
                inputIndex = i;
            }
        }
        return inputIndex;
    }
    /** Removes all characters from the input except for numbers [0-9]. */
    _formatNumberInput(copiedText) {
        let formattedInput = '';
        for (let i = 0; i < copiedText.length; i++) {
            if (copiedText[i].match(/\d$/)) {
                formattedInput += copiedText[i];
            }
        }
        return formattedInput;
    }
    /** Triggers when an input field is blurred. */
    _onBlur() {
        this._focused = false;
        setTimeout(() => {
            if (!this._focused) {
                this.propagateTouch(this._keyCode.join(''));
            }
            this._cdr.markForCheck();
        });
    }
    /** Sets _focused state and makes valid. */
    _setFocusState() {
        this._focused = true;
    }
    /**
     * Disables the code input. Part of the ControlValueAccessor interface required
     * to integrate with Angular's core forms API.
     *
     * @param isDisabled Sets whether the component is disabled.
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this._cdr.markForCheck();
    }
    /** Sets initial value, used by ControlValueAccessor. */
    writeValue(value) {
        if (value) {
            const valueAsArray = value.split('').slice(0, this.codeLength);
            for (let i = 0; i < this.codeLength; i++) {
                this._keyCode[i] = valueAsArray[i];
            }
        }
        else {
            this.setInputLength();
        }
        this._cdr.markForCheck();
    }
    _trackByKeyCode(index, item) {
        return index;
    }
    /** Adds a gap to input fields when appropriate. */
    _inputGap(index) {
        switch (this.codeLength) {
            case 4:
            case 6:
            case 8:
                if (index === this.codeLength / 2) {
                    return INPUT_FIELD_GAP;
                }
                return '';
            default:
                return '';
        }
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched(fn) {
        this.propagateTouch = fn;
    }
    /** @docs-private */
    updateErrorState() {
        const oldState = this.errorState;
        const parent = this._parentFormGroup || this._parentForm;
        const control = this._control ? this._control.control : null;
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    }
    getAriaLabel(keyIndex) {
        return `${this._intl.inputFieldAriaLabel} ${keyIndex + 1} ${this._intl.ofLabel} ${this._keyCode.length}`;
    }
    /** @docs-private
     * Workaround preventing the selection error because the `setSelectionRange` is not supported on input['type=number']
     * */
    selectInput(input) {
        input.focus();
        try {
            input.setSelectionRange(0, input.value.length);
        }
        catch (err) {
            if (err instanceof DOMException && err.name === 'InvalidStateError') {
                // setSelectionRange does not apply
            }
            else {
                throw err;
            }
        }
    }
}
NxCodeInputComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i1.NgControl, optional: true, self: true }, { token: NxCodeInputIntl }, { token: i3.ErrorStateMatcher }, { token: i1.NgForm, optional: true }, { token: i1.FormGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxCodeInputComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxCodeInputComponent, selector: "nx-code-input", inputs: { codeLength: ["length", "codeLength"], type: "type", tabindex: "tabindex", convertTo: ["nxConvertTo", "convertTo"], negative: "negative", disabled: "disabled" }, host: { properties: { "class.nx-code-input": "true", "class.has-error": "errorState", "class.is-negative": "negative", "class.is-disabled": "disabled", "attr.tabindex": "-1" } }, ngImport: i0, template: "<input\n    class=\"nx-code-input__field\"\n    maxlength=\"1\"\n    *ngFor=\"let key of _keyCode; index as i; trackBy: _trackByKeyCode\"\n    [(ngModel)]=\"_keyCode[i]\"\n    [ngClass]=\"_inputGap(i)\"\n    [attr.aria-label]=\"getAriaLabel(i)\"\n    [attr.type]=\"type\"\n    (input)=\"_selectNextInput($event)\"\n    (paste)=\"_pasteClipboard($event)\"\n    (blur)=\"_onBlur()\"\n    (focus)=\"_setFocusState()\"\n    (click)=\"_selectText($event)\"\n    (keydown)=\"_keydownAction($event)\"\n    [attr.tabindex]=\"tabindex\"\n    [attr.disabled]=\"disabled ? '' : null\"\n/>\n", styles: [":host{display:block}:host .nx-code-input__field{font-size:var(--code-input-font-size);line-height:var(--code-input-line-height);font-weight:var(--code-input-font-weight);letter-spacing:var(--code-input-letter-spacing);color:var(--code-input-color);margin:0 4px;text-align:center;border:0;outline:0;caret-color:var(--code-input-active-color);box-shadow:inset 0 -1px 0 0 var(--code-input-color);-webkit-appearance:none;width:32px;border-radius:0;padding:0;background:transparent;box-sizing:border-box}:host .nx-code-input__field:focus{margin-bottom:-nx-border-size(xs);color:var(--code-input-active-color);box-shadow:inset 0 -2px 0 0 var(--code-input-active-color)}:host .nx-code-input__field:first-child{margin-left:0}:host .nx-code-input__field:last-child{margin-right:0}:host .nx-code-input--field-with-gap{margin-left:20px}:host:focus{outline:none}[dir=rtl] :host .nx-code-input__field:first-child{margin-right:0;margin-left:4px}[dir=rtl] :host .nx-code-input__field:last-child{margin-left:0;margin-right:4px}[dir=rtl] :host .nx-code-input--field-with-gap{margin-left:4px;margin-right:20px}:host.is-negative .nx-code-input__field{caret-color:var(--negative);box-shadow:inset 0 -1px 0 0 var(--negative);color:var(--negative)}:host.is-negative .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 var(--negative)}:host.has-error:not(.is-negative) .nx-code-input__field{margin-bottom:-nx-border-size(xs);font-weight:700;color:var(--code-input-error-color);box-shadow:inset 0 -1px 0 0 var(--code-input-error-color)}:host.has-error:not(.is-negative) .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 var(--code-input-error-color)}:host.has-error.is-negative .nx-code-input__field{font-weight:700}:host.is-disabled{cursor:not-allowed}:host.is-disabled .nx-code-input__field{cursor:not-allowed;color:var(--code-input-disabled-color);box-shadow:inset 0 -1px 0 0 nx-theme-color(code-input-disabled-color);box-shadow:inset 0 -1px 0 0 var(--code-input-disabled-color)}:host.is-disabled.is-negative .nx-code-input__field{color:var(--negative-02-dimmed);box-shadow:inset 0 -1px 0 0 var(--negative-02-dimmed)}input[type=number]::-webkit-outer-spin-button,input[type=number]::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}input[type=number],.nx-code-input__field[type=number]{-moz-appearance:textfield}@media screen and (forced-colors: active){.nx-code-input__field{border-bottom:1px solid buttonText!important}.nx-code-input__field:focus{border-bottom:2px solid highlight!important}:host.is-disabled .nx-code-input__field{border-bottom:1px solid GrayText!important}}@media screen and (-ms-high-contrast: active){.nx-code-input__field{box-shadow:inset 0 -1px 0 0 buttonText}.nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 buttonText}:host.is-disabled .nx-code-input__field{color:GrayText;box-shadow:inset 0 -1px 0 0 GrayText;opacity:1}}\n"], directives: [{ type: i4.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i1.MaxLengthValidator, selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]", inputs: ["maxlength"] }, { type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i4.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-code-input', host: {
                        '[class.nx-code-input]': 'true',
                        '[class.has-error]': 'errorState',
                        '[class.is-negative]': 'negative',
                        '[class.is-disabled]': 'disabled',
                        '[attr.tabindex]': '-1',
                    }, changeDetection: ChangeDetectionStrategy.OnPush, template: "<input\n    class=\"nx-code-input__field\"\n    maxlength=\"1\"\n    *ngFor=\"let key of _keyCode; index as i; trackBy: _trackByKeyCode\"\n    [(ngModel)]=\"_keyCode[i]\"\n    [ngClass]=\"_inputGap(i)\"\n    [attr.aria-label]=\"getAriaLabel(i)\"\n    [attr.type]=\"type\"\n    (input)=\"_selectNextInput($event)\"\n    (paste)=\"_pasteClipboard($event)\"\n    (blur)=\"_onBlur()\"\n    (focus)=\"_setFocusState()\"\n    (click)=\"_selectText($event)\"\n    (keydown)=\"_keydownAction($event)\"\n    [attr.tabindex]=\"tabindex\"\n    [attr.disabled]=\"disabled ? '' : null\"\n/>\n", styles: [":host{display:block}:host .nx-code-input__field{font-size:var(--code-input-font-size);line-height:var(--code-input-line-height);font-weight:var(--code-input-font-weight);letter-spacing:var(--code-input-letter-spacing);color:var(--code-input-color);margin:0 4px;text-align:center;border:0;outline:0;caret-color:var(--code-input-active-color);box-shadow:inset 0 -1px 0 0 var(--code-input-color);-webkit-appearance:none;width:32px;border-radius:0;padding:0;background:transparent;box-sizing:border-box}:host .nx-code-input__field:focus{margin-bottom:-nx-border-size(xs);color:var(--code-input-active-color);box-shadow:inset 0 -2px 0 0 var(--code-input-active-color)}:host .nx-code-input__field:first-child{margin-left:0}:host .nx-code-input__field:last-child{margin-right:0}:host .nx-code-input--field-with-gap{margin-left:20px}:host:focus{outline:none}[dir=rtl] :host .nx-code-input__field:first-child{margin-right:0;margin-left:4px}[dir=rtl] :host .nx-code-input__field:last-child{margin-left:0;margin-right:4px}[dir=rtl] :host .nx-code-input--field-with-gap{margin-left:4px;margin-right:20px}:host.is-negative .nx-code-input__field{caret-color:var(--negative);box-shadow:inset 0 -1px 0 0 var(--negative);color:var(--negative)}:host.is-negative .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 var(--negative)}:host.has-error:not(.is-negative) .nx-code-input__field{margin-bottom:-nx-border-size(xs);font-weight:700;color:var(--code-input-error-color);box-shadow:inset 0 -1px 0 0 var(--code-input-error-color)}:host.has-error:not(.is-negative) .nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 var(--code-input-error-color)}:host.has-error.is-negative .nx-code-input__field{font-weight:700}:host.is-disabled{cursor:not-allowed}:host.is-disabled .nx-code-input__field{cursor:not-allowed;color:var(--code-input-disabled-color);box-shadow:inset 0 -1px 0 0 nx-theme-color(code-input-disabled-color);box-shadow:inset 0 -1px 0 0 var(--code-input-disabled-color)}:host.is-disabled.is-negative .nx-code-input__field{color:var(--negative-02-dimmed);box-shadow:inset 0 -1px 0 0 var(--negative-02-dimmed)}input[type=number]::-webkit-outer-spin-button,input[type=number]::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}input[type=number],.nx-code-input__field[type=number]{-moz-appearance:textfield}@media screen and (forced-colors: active){.nx-code-input__field{border-bottom:1px solid buttonText!important}.nx-code-input__field:focus{border-bottom:2px solid highlight!important}:host.is-disabled .nx-code-input__field{border-bottom:1px solid GrayText!important}}@media screen and (-ms-high-contrast: active){.nx-code-input__field{box-shadow:inset 0 -1px 0 0 buttonText}.nx-code-input__field:focus{box-shadow:inset 0 -2px 0 0 buttonText}:host.is-disabled .nx-code-input__field{color:GrayText;box-shadow:inset 0 -1px 0 0 GrayText;opacity:1}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i1.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: NxCodeInputIntl }, { type: i3.ErrorStateMatcher }, { type: i1.NgForm, decorators: [{
                    type: Optional
                }] }, { type: i1.FormGroupDirective, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { codeLength: [{
                type: Input,
                args: ['length']
            }], type: [{
                type: Input
            }], tabindex: [{
                type: Input
            }], convertTo: [{
                type: Input,
                args: ['nxConvertTo']
            }], negative: [{
                type: Input
            }], disabled: [{
                type: Input
            }] } });

class NxCodeInputModule {
}
NxCodeInputModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxCodeInputModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputModule, declarations: [NxCodeInputComponent], imports: [CommonModule, FormsModule, ReactiveFormsModule], exports: [NxCodeInputComponent] });
NxCodeInputModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputModule, providers: [NxCodeInputIntl], imports: [[CommonModule, FormsModule, ReactiveFormsModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCodeInputModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, FormsModule, ReactiveFormsModule],
                    declarations: [NxCodeInputComponent],
                    exports: [NxCodeInputComponent],
                    providers: [NxCodeInputIntl],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NxCodeInputComponent, NxCodeInputIntl, NxCodeInputModule };
//# sourceMappingURL=aposin-ng-aquila-code-input.mjs.map
