import { coerceBooleanProperty } from '@angular/cdk/coercion';
import * as i0 from '@angular/core';
import { Component, ChangeDetectionStrategy, ContentChild, ContentChildren, ViewChild, HostBinding, Input, HostListener, NgModule } from '@angular/core';
import { Subject, merge } from 'rxjs';
import { startWith, takeUntil, throttleTime, delay } from 'rxjs/operators';
import * as i1 from '@angular/cdk/overlay';
import { OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { NxDropdownComponent } from '@aposin/ng-aquila/dropdown';
import { NxFormfieldControl, NxFormfieldErrorDirective } from '@aposin/ng-aquila/formfield';
import { getFontShorthand } from '@aposin/ng-aquila/utils';
import * as i2 from '@aposin/ng-aquila/popover';
import { NxPopoverModule } from '@aposin/ng-aquila/popover';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import { NxInputModule } from '@aposin/ng-aquila/input';

class NxWordComponent {
    constructor(
    /** @docs-private */ elementRef, _cdr, _renderer, _overlay, _viewContainerRef, _overlayPositionBuilder) {
        this.elementRef = elementRef;
        this._cdr = _cdr;
        this._renderer = _renderer;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._overlayPositionBuilder = _overlayPositionBuilder;
        /** @docs-private */
        this.inputChanges = new Subject();
        this._hasErrors = false;
        /** @docs-private */
        this.currentTextWidth = 0;
        // this will apply different min-widths to our component through our styles
        /** Provide a hint for a minimal width. The actual size will be determined for inputs for each change. */
        this.size = 'regular';
        /**
         * A word doesn't have a set place to show labels.
         * In order to be accessible, you have to provide a label with this property.
         * It will be attached to the given input through `aria-label`.
         */
        this.label = '';
        this._destroyed = new Subject();
    }
    ngOnInit() {
        this.setupErrorPopover();
    }
    ngAfterContentInit() {
        this._validateControlChild();
        this._control.stateChanges.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {
            this._hasErrors = this._control.errorState;
            this.updateErrorPopoverState();
            this._cdr.markForCheck();
        });
        // if we have a ngcontrol available stick to its valueChanges subject
        if (this._control.ngControl) {
            this._control.ngControl.valueChanges.pipe(takeUntil(this._destroyed)).subscribe(value => {
                this.updateCurrentTextWidth();
                this.inputChanges.next();
            });
            // in any other case it is a bre input and input changes are signaled through simple state changes
        }
        else {
            this._control.stateChanges.pipe(takeUntil(this._destroyed)).subscribe(value => {
                this.updateCurrentTextWidth();
                this.inputChanges.next();
            });
        }
        this._control.setAriaLabel(this.label);
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        if (this._overlayRef) {
            this._overlayRef.dispose();
        }
    }
    /**
    @docs-private
    Calculate the width of the full text given by the input,
    that value is bound to this component so it can grow.

    The involved input is known to have a width of 100% an will fit the additional space given
    which completes the auto growing behavior.
  */
    updateCurrentTextWidth() {
        // provide the canvas only lazy
        if (!this.measureCanvas) {
            this.measureCanvas = this._renderer.createElement('canvas');
        }
        const ctx = this.measureCanvas.getContext('2d');
        const inputRef = this._control.elementRef;
        const styles = window.getComputedStyle(inputRef.nativeElement);
        ctx.font = getFontShorthand(styles);
        const metrics = ctx.measureText(this._control.value);
        // add 1px (cursor width) to prevent jumping of the text on blur.
        const newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1;
        // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
        // Works as promised as long as there is not other tag around the word. Not expected but possible.
        const parent = this.elementRef.nativeElement.parentElement;
        const parentMeasurement = parent.getBoundingClientRect();
        // Limit to own given minimal width
        this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth);
        // Limit to container width
        this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    }
    /** @docs-private */
    repositionError() {
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    }
    // Fail if the required control is missing.
    _validateControlChild() {
        if (!this._control) {
            throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
        }
    }
    /** @docs-private */
    getConnectedOverlayOrigin() {
        return this.elementRef;
    }
    /** @docs-private */
    get isFocused() {
        return this._control.focused;
    }
    /** @docs-private */
    get isFilled() {
        return !this._control.empty;
    }
    /** @docs-private */
    get hasDropdown() {
        return Boolean(this._dropdown);
    }
    updateErrorPopoverState() {
        if (this._hasErrors && this._errorChildren.length > 0) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    }
    setupErrorPopover() {
        const positionStrategy = this._overlayPositionBuilder
            .flexibleConnectedTo(this.elementRef)
            .withLockedPosition(true)
            .withFlexibleDimensions(false)
            .withPush(true)
            .withPositions([
            {
                originX: 'center',
                originY: 'top',
                overlayX: 'center',
                overlayY: 'bottom',
            },
            {
                originX: 'center',
                originY: 'bottom',
                overlayX: 'center',
                overlayY: 'top',
            },
        ])
            .withDefaultOffsetY(-8);
        this._overlayState = new OverlayConfig();
        this._overlayState.positionStrategy = positionStrategy;
        this._overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        this._overlayRef = this._overlay.create(this._overlayState);
        this._overlayState.positionStrategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe(change => {
            const pair = change.connectionPair;
            this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        });
    }
    positionArrow(pair) {
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        const parentElementLeftOffset = this._overlayRef.overlayElement.parentElement.offsetLeft;
        const overlayElementLeftOffset = this._overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        const targetPosition = parentElementPositionX + parentElementWidth - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this._popover.direction = 'top';
        }
        else {
            this._popover.direction = 'bottom';
        }
        this._popover.arrowStyle = { left: targetPosition + 'px' };
    }
    showPopover() {
        if (!this._overlayRef.hasAttached()) {
            const tooltipPortal = new TemplatePortal(this._popover.templateRef, this._viewContainerRef);
            this._embeddedViewRef = this._overlayRef.attach(tooltipPortal);
        }
    }
    hidePopover() {
        this._overlayRef.detach();
    }
}
NxWordComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxWordComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }, { token: i1.Overlay }, { token: i0.ViewContainerRef }, { token: i1.OverlayPositionBuilder }], target: i0.ɵɵFactoryTarget.Component });
NxWordComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxWordComponent, selector: "nx-word", inputs: { size: ["nxSize", "size"], label: ["nxLabel", "label"] }, host: { properties: { "class.size-short": "size == \"short\"", "class.size-regular": "size == \"regular\"", "class.size-long": "size == \"long\"", "class.has-error": "_hasErrors", "class.is-focused": "isFocused", "class.is-filled": "isFilled", "class.has-dropdown": "hasDropdown", "style.width.px": "this.currentTextWidth" } }, queries: [{ propertyName: "_control", first: true, predicate: NxFormfieldControl, descendants: true }, { propertyName: "_dropdown", first: true, predicate: NxDropdownComponent, descendants: true }, { propertyName: "_errorChildren", predicate: NxFormfieldErrorDirective }], viewQueries: [{ propertyName: "_popover", first: true, predicate: ["popover"], descendants: true, static: true }], ngImport: i0, template: "<div>\n    <!-- We only allow formfield controls here -->\n    <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n        <ng-content select=\"[nxInput]\"></ng-content>\n    </div>\n    <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popover>\n    <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>\n", styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;hyphens:none;width:100%;margin:0 4px}:host .nx-word__inner-wrapper{border-bottom-width:2px;border-bottom-style:solid;border-bottom-color:var(--natural-language-form-border-color)}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width: 991px){:host.size-long{min-width:280px}}@media (max-width: 703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:none;box-shadow:none}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:var(--natural-language-form-active-color);font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom-width:2px;border-bottom-style:solid;border-bottom-color:var(--natural-language-form-border-color)}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-nx-spacer(4xs)}@media (max-width: 991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}}:host ::ng-deep nx-dropdown.is-filled,:host ::ng-deep nx-dropdown.has-focus{color:var(--natural-language-form-active-color);border-color:var(--natural-language-form-active-border-color)}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-focused) .nx-word__inner-wrapper,:host(.is-filled) .nx-word__inner-wrapper{border-color:var(--natural-language-form-active-border-color)}:host(.has-error) .nx-word__inner-wrapper{border-color:var(--natural-language-form-error-border-color)}:host.has-error ::ng-deep nx-dropdown{color:var(--natural-language-form-error-color);border-color:var(--natural-language-form-error-border-color)}:host.has-error ::ng-deep .c-input.has-error{color:var(--natural-language-form-error-color)}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:var(--negative);color:var(--negative)}:host-context(.is-negative) ::ng-deep .c-input,:host-context(.is-negative) ::ng-deep .c-input.has-error{color:var(--negative)}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:var(--negative)}.nx-word__inner-wrapper{height:var(--natural-language-form-large-line-height)}@media (max-width: 991px){.nx-word__inner-wrapper{height:var(--natural-language-form-small-line-height)}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:var(--natural-language-form-small-line-height)}@media screen and (-ms-high-contrast: active){.nx-word__inner-wrapper,::ng-deep nx-dropdown{border-bottom-color:buttonText!important}:host(.is-focused) .nx-word__inner-wrapper,:host(.is-focused) ::ng-deep nx-dropdown{border-bottom-color:highlight!important}}\n"], components: [{ type: i2.NxPopoverComponent, selector: "nx-popover", outputs: ["nxClosed"], exportAs: ["nxPopover"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxWordComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-word', host: {
                        '[class.size-short]': 'size == "short"',
                        '[class.size-regular]': 'size == "regular"',
                        '[class.size-long]': 'size == "long"',
                        '[class.has-error]': '_hasErrors',
                        '[class.is-focused]': 'isFocused',
                        '[class.is-filled]': 'isFilled',
                        '[class.has-dropdown]': 'hasDropdown',
                    }, changeDetection: ChangeDetectionStrategy.OnPush, template: "<div>\n    <!-- We only allow formfield controls here -->\n    <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n        <ng-content select=\"[nxInput]\"></ng-content>\n    </div>\n    <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popover>\n    <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>\n", styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;hyphens:none;width:100%;margin:0 4px}:host .nx-word__inner-wrapper{border-bottom-width:2px;border-bottom-style:solid;border-bottom-color:var(--natural-language-form-border-color)}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width: 991px){:host.size-long{min-width:280px}}@media (max-width: 703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:none;box-shadow:none}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:var(--natural-language-form-active-color);font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom-width:2px;border-bottom-style:solid;border-bottom-color:var(--natural-language-form-border-color)}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-nx-spacer(4xs)}@media (max-width: 991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}}:host ::ng-deep nx-dropdown.is-filled,:host ::ng-deep nx-dropdown.has-focus{color:var(--natural-language-form-active-color);border-color:var(--natural-language-form-active-border-color)}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-focused) .nx-word__inner-wrapper,:host(.is-filled) .nx-word__inner-wrapper{border-color:var(--natural-language-form-active-border-color)}:host(.has-error) .nx-word__inner-wrapper{border-color:var(--natural-language-form-error-border-color)}:host.has-error ::ng-deep nx-dropdown{color:var(--natural-language-form-error-color);border-color:var(--natural-language-form-error-border-color)}:host.has-error ::ng-deep .c-input.has-error{color:var(--natural-language-form-error-color)}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:var(--negative);color:var(--negative)}:host-context(.is-negative) ::ng-deep .c-input,:host-context(.is-negative) ::ng-deep .c-input.has-error{color:var(--negative)}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:var(--negative)}.nx-word__inner-wrapper{height:var(--natural-language-form-large-line-height)}@media (max-width: 991px){.nx-word__inner-wrapper{height:var(--natural-language-form-small-line-height)}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:var(--natural-language-form-small-line-height)}@media screen and (-ms-high-contrast: active){.nx-word__inner-wrapper,::ng-deep nx-dropdown{border-bottom-color:buttonText!important}:host(.is-focused) .nx-word__inner-wrapper,:host(.is-focused) ::ng-deep nx-dropdown{border-bottom-color:highlight!important}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: i1.Overlay }, { type: i0.ViewContainerRef }, { type: i1.OverlayPositionBuilder }]; }, propDecorators: { _control: [{
                type: ContentChild,
                args: [NxFormfieldControl]
            }], _errorChildren: [{
                type: ContentChildren,
                args: [NxFormfieldErrorDirective]
            }], _popover: [{
                type: ViewChild,
                args: ['popover', { static: true }]
            }], _dropdown: [{
                type: ContentChild,
                args: [NxDropdownComponent]
            }], currentTextWidth: [{
                type: HostBinding,
                args: ['style.width.px']
            }], size: [{
                type: Input,
                args: ['nxSize']
            }], label: [{
                type: Input,
                args: ['nxLabel']
            }] } });

const DEFAULT_SIZE = 'large';
class NxNaturalLanguageFormComponent {
    constructor(_cdr, _ngZone) {
        this._cdr = _cdr;
        this._ngZone = _ngZone;
        this._negative = false;
        /** @docs-private */
        this.resizeEvent$ = new Subject();
        /** @docs-private */
        this._size = DEFAULT_SIZE;
        this._destroyed = new Subject();
        // Normally we wouldn't have to explicitly run this outside the `NgZone`, however
        // if the consumer is using `zone-patch-rxjs`, the call throws `Maximum call stack size exceeded` error.
        this._ngZone.runOutsideAngular(() => {
            this._ngZone.onStable.pipe(takeUntil(this._destroyed)).subscribe(() => {
                // wait until all elements are stable for repositioning popovers
                this.updatePositionPopovers();
            });
        });
    }
    /** Whether the negative set of stylings should be used. */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
    }
    get negative() {
        return this._negative;
    }
    /**
     * Sets the size of the NLF. Default value: large
     */
    set size(value) {
        this._size = value;
        this._cdr.markForCheck();
    }
    get size() {
        return this._size;
    }
    /** @docs-private */
    onResize(event) {
        this.resizeEvent$.next();
    }
    ngAfterContentInit() {
        // Collect all words and listen for changes so we can update any open error popover
        // which would otherwise get wrongly positioned.
        const subjects = this._words.map((word) => word.inputChanges);
        const source = merge(...subjects);
        source.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this.updatePositionPopovers();
        });
        this.resizeObservable = this.resizeEvent$.pipe(throttleTime(500), delay(100));
        this.resizeObservable.pipe(takeUntil(this._destroyed)).subscribe(() => this.resizeWords());
    }
    /** @docs-private */
    resizeWords() {
        this._words.forEach((word) => {
            word.updateCurrentTextWidth();
        });
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    /** @docs-private */
    updatePositionPopovers() {
        if (this._words) {
            this._words.forEach((word) => {
                word.repositionError();
            });
        }
    }
}
NxNaturalLanguageFormComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxNaturalLanguageFormComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component });
NxNaturalLanguageFormComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxNaturalLanguageFormComponent, selector: "nx-natural-language-form", inputs: { negative: ["nxNegative", "negative"], size: "size" }, host: { listeners: { "window:orientationchange": "onResize($event)", "window:resize": "onResize($event)" }, properties: { "class.is-negative": "negative", "class.nx-natural-language-form--small": "size === \"small\"", "class.nx-natural-language-form--large": "size === \"large\"" } }, queries: [{ propertyName: "_words", predicate: NxWordComponent }], ngImport: i0, template: "<div class=\"nx-natural-language-form__wrapper\">\n    <ng-content></ng-content>\n</div>\n", styles: [":host{display:block;font-size:var(--natural-language-form-large-font-size);line-height:var(--natural-language-form-large-line-height);font-weight:var(--natural-language-form-large-font-weight);letter-spacing:var(--natural-language-form-large-letter-spacing);color:var(--natural-language-form-text-color);padding-top:72px;padding-bottom:80px}:host ::ng-deep .c-input{font-size:inherit;line-height:inherit}:host ::ng-deep nx-word+nx-word{margin-left:2px}[dir=rtl] :host ::ng-deep nx-word+nx-word{margin-right:2px;margin-left:0;margin-left:initial}:host.is-negative{color:var(--negative)}@media (max-width: 991px){:host{font-size:var(--natural-language-form-small-font-size);line-height:var(--natural-language-form-small-line-height);font-weight:var(--natural-language-form-small-font-weight);letter-spacing:var(--natural-language-form-small-letter-spacing)}}.nx-natural-language-form__wrapper{display:flex;flex-wrap:wrap}.nx-natural-language-form__wrapper>::ng-deep *{margin-bottom:8px}:host(.nx-natural-language-form--small){font-size:var(--natural-language-form-small-font-size);line-height:var(--natural-language-form-small-line-height);font-weight:var(--natural-language-form-small-font-weight);letter-spacing:var(--natural-language-form-small-letter-spacing)}:host(.nx-natural-language-form--small) ::ng-deep .c-input{font-size:inherit;line-height:inherit}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxNaturalLanguageFormComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-natural-language-form', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[class.is-negative]': 'negative',
                        '[class.nx-natural-language-form--small]': 'size === "small"',
                        '[class.nx-natural-language-form--large]': 'size === "large"',
                    }, template: "<div class=\"nx-natural-language-form__wrapper\">\n    <ng-content></ng-content>\n</div>\n", styles: [":host{display:block;font-size:var(--natural-language-form-large-font-size);line-height:var(--natural-language-form-large-line-height);font-weight:var(--natural-language-form-large-font-weight);letter-spacing:var(--natural-language-form-large-letter-spacing);color:var(--natural-language-form-text-color);padding-top:72px;padding-bottom:80px}:host ::ng-deep .c-input{font-size:inherit;line-height:inherit}:host ::ng-deep nx-word+nx-word{margin-left:2px}[dir=rtl] :host ::ng-deep nx-word+nx-word{margin-right:2px;margin-left:0;margin-left:initial}:host.is-negative{color:var(--negative)}@media (max-width: 991px){:host{font-size:var(--natural-language-form-small-font-size);line-height:var(--natural-language-form-small-line-height);font-weight:var(--natural-language-form-small-font-weight);letter-spacing:var(--natural-language-form-small-letter-spacing)}}.nx-natural-language-form__wrapper{display:flex;flex-wrap:wrap}.nx-natural-language-form__wrapper>::ng-deep *{margin-bottom:8px}:host(.nx-natural-language-form--small){font-size:var(--natural-language-form-small-font-size);line-height:var(--natural-language-form-small-line-height);font-weight:var(--natural-language-form-small-font-weight);letter-spacing:var(--natural-language-form-small-letter-spacing)}:host(.nx-natural-language-form--small) ::ng-deep .c-input{font-size:inherit;line-height:inherit}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.NgZone }]; }, propDecorators: { _words: [{
                type: ContentChildren,
                args: [NxWordComponent]
            }], negative: [{
                type: Input,
                args: ['nxNegative']
            }], size: [{
                type: Input
            }], onResize: [{
                type: HostListener,
                args: ['window:orientationchange', ['$event']]
            }, {
                type: HostListener,
                args: ['window:resize', ['$event']]
            }] } });

class NxNaturalLanguageFormModule {
}
NxNaturalLanguageFormModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxNaturalLanguageFormModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxNaturalLanguageFormModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxNaturalLanguageFormModule, declarations: [NxNaturalLanguageFormComponent, NxWordComponent], imports: [CommonModule, NxInputModule, NxPopoverModule], exports: [NxNaturalLanguageFormComponent, NxWordComponent] });
NxNaturalLanguageFormModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxNaturalLanguageFormModule, imports: [[CommonModule, NxInputModule, NxPopoverModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxNaturalLanguageFormModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NxInputModule, NxPopoverModule],
                    declarations: [NxNaturalLanguageFormComponent, NxWordComponent],
                    exports: [NxNaturalLanguageFormComponent, NxWordComponent],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NxNaturalLanguageFormComponent, NxNaturalLanguageFormModule, NxWordComponent };
//# sourceMappingURL=aposin-ng-aquila-natural-language-form.mjs.map
