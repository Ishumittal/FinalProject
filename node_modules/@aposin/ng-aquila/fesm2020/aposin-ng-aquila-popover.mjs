import { ENTER, SPACE } from '@angular/cdk/keycodes';
import * as i0 from '@angular/core';
import { Directive, Injectable, EventEmitter, TemplateRef, Component, ChangeDetectionStrategy, ViewChild, ContentChild, Output, InjectionToken, Optional, Inject, Input, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil, map, filter } from 'rxjs/operators';
import * as i2 from '@aposin/ng-aquila/icon';
import { NxIconModule } from '@aposin/ng-aquila/icon';
import * as i3 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i1 from '@angular/cdk/overlay';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import { __classPrivateFieldGet, __classPrivateFieldSet } from 'tslib';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { TemplatePortal } from '@angular/cdk/portal';
import * as i2$1 from '@angular/platform-browser';
import * as i3$1 from '@angular/cdk/a11y';
import * as i4 from '@angular/cdk/platform';
import * as i5 from '@angular/cdk/bidi';

/**
 * Popover content that will be rendered lazily
 * after the popover is opened for the first time.
 */
class NxPopoverContentDirective {
    constructor(_template) {
        this._template = _template;
    }
}
NxPopoverContentDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverContentDirective, deps: [{ token: i0.TemplateRef }], target: i0.ɵɵFactoryTarget.Directive });
NxPopoverContentDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxPopoverContentDirective, selector: "ng-template[nxPopoverContent]", ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'ng-template[nxPopoverContent]',
                }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }]; } });

/** Popover data that requires internationalization. */
class NxPopoverIntl {
    constructor() {
        /**
         * Stream that emits whenever the labels here are changed. Use this to notify
         * components if the labels have changed after initialization.
         */
        this.changes = new Subject();
        /** Aria-label for the delete icon. */
        this.closeIconLabel = 'close';
    }
}
NxPopoverIntl.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverIntl, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NxPopoverIntl.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverIntl, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverIntl, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

class NxPopoverComponent {
    constructor(_intl, _cdr) {
        this._intl = _intl;
        this._cdr = _cdr;
        /** Event emitted when the popover is closed. */
        this.closed = new EventEmitter();
        /** @docs-private */
        this.closeButtonClick = new Subject();
        /** @docs-private */
        this.showCloseButton = false;
        /** @docs-private */
        this.arrowStyle = {};
        this._destroyed = new Subject();
    }
    ngOnInit() {
        this._intl.changes.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this._cdr.markForCheck();
        });
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this.closed.complete();
    }
    /**
     * Emits event to notify the popover trigger directive that the close button was clicked.
     * @docs-private
     */
    emitCloseButtonClick() {
        this.closeButtonClick.next();
    }
    /** @docs-private */
    _onCloseKeyup($event) {
        if ($event && ($event.keyCode === ENTER || $event.keyCode === SPACE)) {
            this.emitCloseButtonClick();
        }
        $event.preventDefault();
    }
    /** @docs-private */
    emitClosedEvent() {
        this.closed.emit();
    }
    /** @docs-private */
    get classList() {
        if (this.direction) {
            // Returning an array here caused an error that the classes were not set
            // after a prod build. Couldn't reproduce it properly in an isolated way.
            // As it doesn't make sense to return an array for a single value anyway
            // changed it to a string and that seems to work.
            return `nx-popover--${this.direction}`;
        }
        return '';
    }
    /** Prevent the popover from closing when the user clicks on the popover content. */
    _onClick(event) {
        event.stopPropagation();
    }
}
NxPopoverComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverComponent, deps: [{ token: NxPopoverIntl }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
NxPopoverComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxPopoverComponent, selector: "nx-popover", outputs: { closed: "nxClosed" }, queries: [{ propertyName: "_lazyContent", first: true, predicate: NxPopoverContentDirective, descendants: true }], viewQueries: [{ propertyName: "templateRef", first: true, predicate: TemplateRef, descendants: true }], exportAs: ["nxPopover"], ngImport: i0, template: "<ng-template>\n    <div [ngClass]=\"classList\" class=\"nx-popover\" role=\"tooltip\" aria-hidden=\"false\" (click)=\"_onClick($event)\">\n        <div class=\"nx-popover__content\" tabindex=\"0\">\n            <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\"></div>\n            <span\n                [attr.aria-label]=\"_intl.closeIconLabel\"\n                tabindex=\"0\"\n                role=\"button\"\n                class=\"nx-popover__close-icon\"\n                (click)=\"emitCloseButtonClick()\"\n                (keyup)=\"_onCloseKeyup($event)\"\n                *ngIf=\"showCloseButton\"\n            >\n                <nx-icon aria-hidden=\"true\" name=\"close\"></nx-icon>\n            </span>\n\n            <span [id]=\"id\">\n                <ng-content></ng-content>\n                <ng-container [ngTemplateOutlet]=\"_lazyContent?._template ?? null\"></ng-container>\n            </span>\n        </div>\n    </div>\n</ng-template>\n", styles: [".nx-popover__content{font-size:var(--popover-content-font-size);line-height:var(--popover-content-line-height);font-weight:var(--popover-content-font-weight);letter-spacing:var(--popover-content-letter-spacing);background-color:var(--popover-background-color);color:var(--popover-text-color);border:1px solid var(--popover-border-color);border-radius:4px;box-shadow:var(--shadow-small);padding:23px;display:block}.nx-popover__content:focus{outline:none}.nx-popover__content::-moz-focus-inner{border:0}.nx-popover__close-icon{display:flex;position:absolute;top:4px;right:4px;cursor:pointer;font-size:var(--popover-close-icon-size);color:var(--popover-close-icon-color);border-radius:2px}[dir=rtl] .nx-popover__close-icon{right:auto;left:4px}.nx-popover__close-icon:focus{outline:none}.nx-popover__close-icon::-moz-focus-inner{border:0}@media screen and (-ms-high-contrast: active){.nx-popover__close-icon{color:buttonText}}.nx-popover__content.cdk-keyboard-focused,.nx-popover__close-icon.cdk-keyboard-focused{box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-popover__content.cdk-keyboard-focused,.nx-popover__close-icon.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;transform:translate(-50%);border-top:1px solid var(--popover-border-color);border-left:1px solid var(--popover-border-color)}.nx-popover--top .nx-popover__arrow{transform:translate(-50%) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px var(--popover-background-color),-2px -2px -4px var(--shadow-small-color)}.nx-popover--right .nx-popover__arrow{transform:translateY(-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{transform:translate(-50%) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{transform:translateY(-50%) rotate(135deg);right:-5px}\n"], components: [{ type: i2.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-popover', changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'nxPopover', template: "<ng-template>\n    <div [ngClass]=\"classList\" class=\"nx-popover\" role=\"tooltip\" aria-hidden=\"false\" (click)=\"_onClick($event)\">\n        <div class=\"nx-popover__content\" tabindex=\"0\">\n            <div class=\"nx-popover__arrow\" [ngStyle]=\"arrowStyle\"></div>\n            <span\n                [attr.aria-label]=\"_intl.closeIconLabel\"\n                tabindex=\"0\"\n                role=\"button\"\n                class=\"nx-popover__close-icon\"\n                (click)=\"emitCloseButtonClick()\"\n                (keyup)=\"_onCloseKeyup($event)\"\n                *ngIf=\"showCloseButton\"\n            >\n                <nx-icon aria-hidden=\"true\" name=\"close\"></nx-icon>\n            </span>\n\n            <span [id]=\"id\">\n                <ng-content></ng-content>\n                <ng-container [ngTemplateOutlet]=\"_lazyContent?._template ?? null\"></ng-container>\n            </span>\n        </div>\n    </div>\n</ng-template>\n", styles: [".nx-popover__content{font-size:var(--popover-content-font-size);line-height:var(--popover-content-line-height);font-weight:var(--popover-content-font-weight);letter-spacing:var(--popover-content-letter-spacing);background-color:var(--popover-background-color);color:var(--popover-text-color);border:1px solid var(--popover-border-color);border-radius:4px;box-shadow:var(--shadow-small);padding:23px;display:block}.nx-popover__content:focus{outline:none}.nx-popover__content::-moz-focus-inner{border:0}.nx-popover__close-icon{display:flex;position:absolute;top:4px;right:4px;cursor:pointer;font-size:var(--popover-close-icon-size);color:var(--popover-close-icon-color);border-radius:2px}[dir=rtl] .nx-popover__close-icon{right:auto;left:4px}.nx-popover__close-icon:focus{outline:none}.nx-popover__close-icon::-moz-focus-inner{border:0}@media screen and (-ms-high-contrast: active){.nx-popover__close-icon{color:buttonText}}.nx-popover__content.cdk-keyboard-focused,.nx-popover__close-icon.cdk-keyboard-focused{box-shadow:var(--focus-box-shadow)}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-popover__content.cdk-keyboard-focused,.nx-popover__close-icon.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}.nx-popover__arrow{width:12px;height:12px;background-color:inherit;position:absolute;transform:translate(-50%);border-top:1px solid var(--popover-border-color);border-left:1px solid var(--popover-border-color)}.nx-popover--top .nx-popover__arrow{transform:translate(-50%) rotate(225deg);bottom:-5px;box-shadow:2px 2px 1px 1px var(--popover-background-color),-2px -2px -4px var(--shadow-small-color)}.nx-popover--right .nx-popover__arrow{transform:translateY(-50%) rotate(-45deg);left:-5px}.nx-popover--bottom .nx-popover__arrow{transform:translate(-50%) rotate(45deg);top:-5px}.nx-popover--left .nx-popover__arrow{transform:translateY(-50%) rotate(135deg);right:-5px}\n"] }]
        }], ctorParameters: function () { return [{ type: NxPopoverIntl }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { templateRef: [{
                type: ViewChild,
                args: [TemplateRef]
            }], _lazyContent: [{
                type: ContentChild,
                args: [NxPopoverContentDirective]
            }], closed: [{
                type: Output,
                args: ['nxClosed']
            }] } });

var _NxPopoverTriggerDirective_scrollStrategy;
let nextId = 0;
const BASE_OFFSET = 16;
/** Injection token that determines the scroll handling while a popover is open. */
const NX_POPOVER_SCROLL_STRATEGY = new InjectionToken('nx-popover-scroll-strategy');
/** @docs-private */
function NX_POPOVER_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.close();
}
/** @docs-private */
const NX_POPOVER_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_POPOVER_SCROLL_STRATEGY,
    useFactory: NX_POPOVER_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
/**
 * Creates an error to be thrown if the user provided an invalid popover direction.
 * @docs-private
 */
function getNxPopoverInvalidDirectionError(direction) {
    return Error(`Popover direction "${direction}" is invalid.`);
}
class NxPopoverTriggerDirective {
    constructor(overlay, elementRef, viewContainerRef, eventManager, _focusTrapFactory, _focusMonitor, _ngZone, _platform, _dir, _defaultScrollStrategyFactory, _cdr) {
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._focusTrapFactory = _focusTrapFactory;
        this._focusMonitor = _focusMonitor;
        this._ngZone = _ngZone;
        this._platform = _platform;
        this._dir = _dir;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this._cdr = _cdr;
        this._overlayDestroyed = new Subject();
        this._show = false;
        this._closeable = null;
        this._modal = false;
        /** Element that was focused before the Popover was opened. Save this to restore upon close. */
        this._elementFocusedBeforePopoverWasOpened = null;
        this._manualListeners = new Map();
        this._possiblePopoverDirections = ['bottom', 'top', 'left', 'right'];
        this.closeOnLeftViewport = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if (!entry.isIntersecting) {
                    this._ngZone.run(() => this.overlayRef?.detach());
                }
                this.closeOnLeftViewport.disconnect();
            });
        }, { threshold: 0.2 });
        /** @docs-private */
        this.id = 'nx-popover-' + nextId++;
        /** An event is emitted if the visibility status of the popover changes. */
        this.changeShow = new EventEmitter();
        this._closeOnClickOutside = true;
        /** Sets the desired direction to open the popover. E.g., right, left, bottom, top */
        this.direction = 'right';
        /** Whether the popover will be opened automatically. */
        this.popoverInitialVisible = false;
        /** An event is emitted when the visibility of the popopver changes. */
        this.visibleChange = new EventEmitter();
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /** Sets the way to trigger the popover. Options are hover, click, manual */
        this.trigger = 'click';
        _NxPopoverTriggerDirective_scrollStrategy.set(this, void 0);
        this._destroyed = new Subject();
        /** Strategy factory that will be used to handle scrolling while the popover panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
        const element = elementRef.nativeElement;
        if (!this._platform.IOS && !this._platform.ANDROID) {
            this._manualListeners
                .set('mouseenter', () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            })
                .set('mouseleave', () => {
                if (this.trigger === 'hover') {
                    this.show = false;
                }
            })
                .set('keydown', (event) => {
                switch (event.keyCode) {
                    case SPACE:
                    case ENTER:
                        this.handleClick();
                        break;
                    default:
                }
            });
        }
        else {
            this._manualListeners.set('touchstart', () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            });
        }
        this._manualListeners.forEach((listener, event) => element.addEventListener(event, listener));
        this._focusMonitor
            .monitor(element)
            .pipe(takeUntil(this._destroyed))
            .subscribe(origin => {
            if (origin === 'keyboard' && this.trigger === 'hover') {
                this._ngZone.run(() => (this.show = true));
            }
        });
        this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(this._dirChangeHandler.bind(this));
    }
    /** Whether to show or hide the popover. */
    set show(value) {
        value = coerceBooleanProperty(value);
        if (this._show !== value) {
            this._show = value;
            if (this._show) {
                this.openPopover();
            }
            else {
                this.closePopover();
            }
        }
    }
    get show() {
        return this._show;
    }
    /** Whether to show a close button. By default a close icon is only shown for trigger type click. */
    set closeable(value) {
        this._closeable = coerceBooleanProperty(value);
        if (this.popover) {
            this.popover.showCloseButton = this.isCloseable();
        }
    }
    get closeable() {
        return this._closeable;
    }
    /** Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'. */
    set closeOnClickOutside(value) {
        this._closeOnClickOutside = coerceBooleanProperty(value);
    }
    get closeOnClickOutside() {
        return this._closeOnClickOutside;
    }
    /** Whether the popover opens in modal state. */
    set modal(value) {
        this._modal = coerceBooleanProperty(value);
    }
    get modal() {
        return this._modal;
    }
    /** Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin. */
    set scrollStrategy(value) {
        if (__classPrivateFieldGet(this, _NxPopoverTriggerDirective_scrollStrategy, "f") !== value) {
            __classPrivateFieldSet(this, _NxPopoverTriggerDirective_scrollStrategy, value, "f");
            this._scrollStrategyFactory = value ? this.getScrollStrategyFactory(value) : this._defaultScrollStrategyFactory;
            this._cdr.markForCheck();
        }
    }
    get scrollStrategy() {
        return __classPrivateFieldGet(this, _NxPopoverTriggerDirective_scrollStrategy, "f");
    }
    ngOnInit() {
        this.popover.showCloseButton = this.isCloseable();
    }
    ngAfterViewInit() {
        this.popover.id = this.id;
        this._removeEventListener = this.eventManager.addGlobalEventListener('window', 'keyup.esc', () => {
            if (this.isOpen) {
                this.show = false;
            }
        });
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this.show = false;
        });
        if (this.popoverInitialVisible || this._show) {
            this.show = true;
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this.show = false;
        this._removeEventListener();
        this._focusMonitor.stopMonitoring(this.elementRef.nativeElement);
        // Clean up the event listeners set in the constructor
        this._manualListeners.forEach((listener, event) => {
            this.elementRef.nativeElement.removeEventListener(event, listener);
        });
        if (this.overlayRef) {
            this.overlayRef.dispose();
        }
        this._manualListeners.clear();
        this._overlayDestroyed.next();
        this._overlayDestroyed.complete();
    }
    /** @docs-private */
    get isOpen() {
        return this.overlayRef && this.createOverlay().hasAttached();
    }
    /** @docs-private */
    isCloseable() {
        return (this.trigger === 'click' && this._closeable === null) || !!this._closeable;
    }
    /** Update the popover with the given position strategy. */
    updatePosition() {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    }
    /** @docs-private */
    handleClick() {
        if (this.trigger === 'click') {
            this.show = !this.isOpen;
        }
        else if (this.trigger === 'hover') {
            this.show = true;
        }
    }
    /** Open the popover instance. */
    open() {
        this.show = true;
    }
    /** Close the popover instance. */
    close() {
        this.show = false;
    }
    /** Toggle the popover instance. */
    toggle() {
        this.show = !this.show;
    }
    openPopover() {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            const element = this.getPopoverContainer();
            this._focusTrap = this._focusTrapFactory.create(element);
            this._elementFocusedBeforePopoverWasOpened = this.elementRef.nativeElement;
            this._focusMonitor.monitor(element.querySelector('.nx-popover__content'));
            const closeIcon = element.querySelector('.nx-popover__close-icon');
            if (closeIcon) {
                this._focusMonitor.monitor(closeIcon);
            }
            this._autoFocusFirstTabbableElement(element);
            // attach a close click listener only if it makes sense (ignore it on hover e.g.)
            if (this.closeOnClickOutside) {
                this.waitForClose();
            }
        }
    }
    /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     */
    _autoFocusFirstTabbableElement(element) {
        this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {
            // If we didn't find any focusable elements inside the popover, focus the
            // container so the user can't tab into other elements behind it.
            if (!hasMovedFocus) {
                element.focus();
            }
        });
    }
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    closePopover() {
        if (this.overlayRef.hasAttached()) {
            const element = this.getPopoverContainer();
            this._focusMonitor.stopMonitoring(element.querySelector('.nx-popover__content'));
            this._focusMonitor.stopMonitoring(element.querySelector('.nx-popover__close-icon'));
            this._returnFocusAfterPopover();
            this.overlayRef.detach();
            this._embeddedViewRef = null;
            this._focusTrap.destroy();
        }
    }
    getScrollStrategyFactory(scrollStrategy) {
        switch (scrollStrategy) {
            case 'reposition':
                return this.overlay.scrollStrategies.reposition;
            default:
                return this.overlay.scrollStrategies.close;
        }
    }
    createOverlay() {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            const overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            overlayState.scrollStrategy = this._scrollStrategyFactory();
            overlayState.scrollStrategy.enable();
            overlayState.direction = this._dir?.value || 'ltr';
            if (this._modal) {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions(overlayState.positionStrategy);
            this._subscribeToAttach();
            this._subscribeToDetach();
            if (this._modal && this._closeOnClickOutside) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    }
    subscribeToPositions(position) {
        position.positionChanges.pipe(takeUntil(this._overlayDestroyed)).subscribe(change => {
            const pair = change.connectionPair;
            this.positionOverlay(pair);
            this.positionArrow(pair);
            this.closeOnLeftViewport.observe(this.elementRef.nativeElement);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        });
    }
    // for modal popovers close the popover on backdrop clicks
    _subscribeToBackdropClick() {
        this.overlayRef.backdropClick()
            .pipe(takeUntil(this._overlayDestroyed))
            .subscribe(event => {
            this.show = false;
        });
    }
    // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
    _subscribeToDetach() {
        this.overlayRef.detachments()
            .pipe(takeUntil(this._overlayDestroyed))
            .subscribe(data => {
            // This is an exception: when the popover is closed by a scrolling event,
            // then only the detached method is called but the show state variable remains unchanged.
            if (this.show) {
                this.show = false;
            }
            this.changeShow.emit(this._show);
            this.popover.emitClosedEvent();
        });
    }
    _subscribeToAttach() {
        this.overlayRef.attachments()
            .pipe(takeUntil(this._overlayDestroyed))
            .subscribe(data => {
            this.changeShow.emit(this._show);
        });
    }
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    waitForClose() {
        return this.overlayRef.outsidePointerEvents()
            .pipe(map(event => event.target), filter(target => !this.elementRef.nativeElement.contains(target)), takeUntil(this.popover.closed))
            .subscribe(() => {
            this.show = false;
        });
    }
    positionOverlay(pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = this.isRtl ? 'left' : 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = this.isRtl ? 'right' : 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    }
    positionArrow(pair) {
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        const parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        const overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        const targetPosition = parentElementPositionX + parentElementWidth - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            const direction = 'left';
            const arrowStyle = { left: '0' };
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    }
    getPosition() {
        const origin = this._getOrigin(this.direction);
        const overlay = this._getOverlayPosition(this.direction);
        const offset = this._getOffset(this.direction);
        const fallbacks = this._getFallbackPositions(this.direction);
        return this.overlay
            .position()
            .flexibleConnectedTo(this.elementRef)
            .withPositions([
            {
                ...origin,
                ...overlay,
                ...offset,
            },
            ...fallbacks,
        ])
            .withFlexibleDimensions(false);
    }
    /** Returns the focus to the element focused before the Popover was open. */
    _returnFocusAfterPopover() {
        const toFocus = this._elementFocusedBeforePopoverWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
    }
    /** Returns the main popover container of the injected content. */
    getPopoverContainer() {
        return this.overlayRef.overlayElement.querySelector('.nx-popover');
    }
    /**
     * Returns the origin position based on the user's direction preference.
     */
    _getOrigin(direction) {
        switch (direction) {
            case 'top':
            case 'bottom': {
                return {
                    originX: 'center',
                    originY: direction,
                };
            }
            case 'left': {
                return {
                    originX: this.isRtl ? 'end' : 'start',
                    originY: 'center',
                };
            }
            case 'right': {
                return {
                    originX: this.isRtl ? 'start' : 'end',
                    originY: 'center',
                };
            }
            default: {
                throw getNxPopoverInvalidDirectionError(direction);
            }
        }
    }
    /** Returns the overlay position based on the user's direction preference */
    _getOverlayPosition(direction) {
        switch (direction) {
            case 'top':
            case 'bottom': {
                return {
                    overlayX: 'center',
                    overlayY: this._getInversePosition(direction),
                };
            }
            case 'left': {
                return {
                    overlayX: this.isRtl ? 'start' : 'end',
                    overlayY: 'center',
                };
            }
            case 'right': {
                return {
                    overlayX: this.isRtl ? 'end' : 'start',
                    overlayY: 'center',
                };
            }
            default: {
                throw getNxPopoverInvalidDirectionError(direction);
            }
        }
    }
    /** Returns the overlay offset required by the user's direction preference */
    _getOffset(direction) {
        switch (direction) {
            case 'top': {
                return {
                    offsetY: BASE_OFFSET * -1,
                };
            }
            case 'bottom': {
                return {
                    offsetY: BASE_OFFSET,
                };
            }
            case 'left': {
                return {
                    offsetX: BASE_OFFSET * -1,
                };
            }
            case 'right': {
                return {
                    offsetX: BASE_OFFSET,
                };
            }
            default: {
                throw getNxPopoverInvalidDirectionError(direction);
            }
        }
    }
    /** Returns the opposite direction, using aquila popover direction naming: top, right, bottom, left */
    _getInversePopoverDirection(direction) {
        const popoverDirectionPairs = {
            top: 'bottom',
            right: 'left',
            bottom: 'top',
            left: 'right',
        };
        return popoverDirectionPairs[direction];
    }
    /** Returns the opposite position, using angular position naming: top, bottom, start, end, center */
    _getInversePosition(position) {
        const positionPairs = {
            top: 'bottom',
            bottom: 'top',
            start: 'end',
            end: 'start',
            center: 'center',
        };
        return positionPairs[position];
    }
    /** Returns an array of fallback positions for popover, following the algoritm:
     * 1) Slightly alternate preferred position if applicable. I.e. for 'top' try 'top-start' and 'top-end' positioning.
     * 2) Try the opposite position, i.e. for 'top' try 'bottom'.
     * 3) Slightly alternate opposite position, i.e. 'bottom-start', 'bottom-end'
     * 4) All remaining positions from positions list
     */
    _getFallbackPositions(direction, possibleDirections = this._possiblePopoverDirections) {
        if (!direction) {
            return [];
        }
        const remainigDirections = possibleDirections.filter(possibleDirection => possibleDirection !== direction);
        let fallbackPositions = [];
        switch (direction) {
            case 'top':
            case 'bottom': {
                fallbackPositions = this._getVerticalFallbackPositionPairs(direction);
                break;
            }
            case 'left':
            case 'right': {
                fallbackPositions = this._getHorizontalFallbackPositionPairs(direction);
                break;
            }
        }
        const inverseDirection = this._getInversePopoverDirection(direction);
        const nextFallbackPosition = remainigDirections.includes(inverseDirection) ? inverseDirection : possibleDirections[0];
        return [...fallbackPositions, ...this._getFallbackPositions(nextFallbackPosition, remainigDirections)];
    }
    /** Calculates fallbacks for vertical popover positioning */
    _getVerticalFallbackPositionPairs(direction) {
        const isSelectedDirection = direction === this.direction;
        const verticalFallbackPositionPairs = [];
        const basePositionPair = {
            ...this._getOrigin(direction),
            ...this._getOverlayPosition(direction),
            ...this._getOffset(direction),
        };
        if (!isSelectedDirection) {
            // HINT: selected direction matches basePosition, so we don't need to repeat it in fallback
            verticalFallbackPositionPairs.push(basePositionPair);
        }
        verticalFallbackPositionPairs.push({
            ...basePositionPair,
            originX: 'start',
            overlayX: 'start',
        }, {
            ...basePositionPair,
            originX: 'end',
            overlayX: 'end',
        });
        return verticalFallbackPositionPairs;
    }
    /** Calculates fallbacks for horizontal popover positioning */
    _getHorizontalFallbackPositionPairs(direction) {
        const offset = this._getOffset(direction);
        return [
            {
                ...this._getOrigin(direction),
                ...this._getOverlayPosition(direction),
                ...offset,
            },
        ];
    }
    _dirChangeHandler() {
        if (this.overlayRef) {
            this.closePopover();
            this.overlayRef.dispose();
            this.overlayRef = null;
            this._overlayDestroyed.next();
        }
    }
    get isRtl() {
        return this._dir?.value === 'rtl';
    }
}
_NxPopoverTriggerDirective_scrollStrategy = new WeakMap();
NxPopoverTriggerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverTriggerDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2$1.EventManager }, { token: i3$1.FocusTrapFactory }, { token: i3$1.FocusMonitor }, { token: i0.NgZone }, { token: i4.Platform }, { token: i5.Directionality, optional: true }, { token: NX_POPOVER_SCROLL_STRATEGY }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
NxPopoverTriggerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxPopoverTriggerDirective, selector: "[nxPopoverTriggerFor]", inputs: { show: ["nxPopoverShow", "show"], closeable: ["nxPopoverCloseable", "closeable"], closeOnClickOutside: "closeOnClickOutside", popover: ["nxPopoverTriggerFor", "popover"], direction: ["nxPopoverDirection", "direction"], popoverInitialVisible: ["nxPopoverInitialVisible", "popoverInitialVisible"], visibleChange: ["nxPopoverVisibleChange", "visibleChange"], modal: ["nxPopoverModal", "modal"], trigger: ["nxPopoverTrigger", "trigger"], scrollStrategy: ["nxPopoverScrollStrategy", "scrollStrategy"] }, outputs: { changeShow: "nxPopoverShowChange" }, host: { attributes: { "aria-haspopup": "true" }, listeners: { "click": "handleClick()" }, properties: { "attr.aria-expanded": "isOpen", "attr.aria-describedby": "isOpen ? id : null" } }, exportAs: ["nxPopoverTrigger"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxPopoverTriggerFor]',
                    exportAs: 'nxPopoverTrigger',
                    host: {
                        '(click)': 'handleClick()',
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'isOpen',
                        '[attr.aria-describedby]': 'isOpen ? id : null',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2$1.EventManager }, { type: i3$1.FocusTrapFactory }, { type: i3$1.FocusMonitor }, { type: i0.NgZone }, { type: i4.Platform }, { type: i5.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NX_POPOVER_SCROLL_STRATEGY]
                }] }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { changeShow: [{
                type: Output,
                args: ['nxPopoverShowChange']
            }], show: [{
                type: Input,
                args: ['nxPopoverShow']
            }], closeable: [{
                type: Input,
                args: ['nxPopoverCloseable']
            }], closeOnClickOutside: [{
                type: Input
            }], popover: [{
                type: Input,
                args: ['nxPopoverTriggerFor']
            }], direction: [{
                type: Input,
                args: ['nxPopoverDirection']
            }], popoverInitialVisible: [{
                type: Input,
                args: ['nxPopoverInitialVisible']
            }], visibleChange: [{
                type: Input,
                args: ['nxPopoverVisibleChange']
            }], modal: [{
                type: Input,
                args: ['nxPopoverModal']
            }], trigger: [{
                type: Input,
                args: ['nxPopoverTrigger']
            }], scrollStrategy: [{
                type: Input,
                args: ['nxPopoverScrollStrategy']
            }] } });

class NxPopoverModule {
}
NxPopoverModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxPopoverModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverModule, declarations: [NxPopoverTriggerDirective, NxPopoverComponent, NxPopoverContentDirective], imports: [CommonModule, OverlayModule, NxIconModule], exports: [NxPopoverTriggerDirective, NxPopoverComponent, NxPopoverContentDirective] });
NxPopoverModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverModule, providers: [NxPopoverIntl, NX_POPOVER_SCROLL_STRATEGY_PROVIDER], imports: [[CommonModule, OverlayModule, NxIconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, OverlayModule, NxIconModule],
                    declarations: [NxPopoverTriggerDirective, NxPopoverComponent, NxPopoverContentDirective],
                    exports: [NxPopoverTriggerDirective, NxPopoverComponent, NxPopoverContentDirective],
                    providers: [NxPopoverIntl, NX_POPOVER_SCROLL_STRATEGY_PROVIDER],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NX_POPOVER_SCROLL_STRATEGY, NX_POPOVER_SCROLL_STRATEGY_PROVIDER, NX_POPOVER_SCROLL_STRATEGY_PROVIDER_FACTORY, NxPopoverComponent, NxPopoverContentDirective, NxPopoverIntl, NxPopoverModule, NxPopoverTriggerDirective, getNxPopoverInvalidDirectionError };
//# sourceMappingURL=aposin-ng-aquila-popover.mjs.map
