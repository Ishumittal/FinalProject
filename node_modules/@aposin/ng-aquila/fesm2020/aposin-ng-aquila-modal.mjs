import * as i1$1 from '@angular/cdk/overlay';
import { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';
import * as i5$1 from '@angular/cdk/portal';
import { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, TemplatePortal, PortalModule } from '@angular/cdk/portal';
import * as i0 from '@angular/core';
import { EventEmitter, Component, ChangeDetectionStrategy, Optional, Inject, ViewChild, InjectionToken, Injector, TemplateRef, Injectable, SkipSelf, Directive, Input, Output, NgModule } from '@angular/core';
import { Subject, defer } from 'rxjs';
import { filter, take, startWith, takeUntil } from 'rxjs/operators';
import { _getFocusedElementPierceShadowDom } from '@angular/cdk/platform';
import * as i5 from '@angular/common';
import { DOCUMENT, CommonModule } from '@angular/common';
import { trigger, state, style, transition, animate, animation, useAnimation, query, animateChild } from '@angular/animations';
import * as i1 from '@angular/cdk/a11y';
import { A11yModule } from '@angular/cdk/a11y';
import * as i3 from '@aposin/ng-aquila/icon';
import { NxIconModule } from '@aposin/ng-aquila/icon';
import { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';
import * as i2 from '@angular/platform-browser';
import * as i6 from '@angular/cdk/scrolling';

/**
 * Configuration for opening a modal  with the NxDialogService.
 */
class NxModalConfig {
    constructor() {
        /** The ARIA role of the modal element. */
        this.role = 'dialog';
        /** Custom class for the overlay pane. */
        this.panelClass = '';
        /** Whether the modal has a backdrop. */
        this.hasBackdrop = true;
        /** Custom class for the backdrop. */
        this.backdropClass = '';
        /** Whether the user can use escape or clicking on the backdrop to close the modal. */
        this.disableClose = false;
        /** Width of the modal. */
        this.width = '736px';
        /** Height of the modal. */
        this.height = '';
        /** Max-width of the modal. If a number is provided, assumes pixel units. Defaults to 100vw. */
        this.maxWidth = '736px';
        /** Data being injected into the child component. */
        this.data = null;
        /** ID of the element that describes the modal. */
        this.ariaDescribedBy = null;
        /** ID of the element that labels the modal. */
        this.ariaLabelledBy = null;
        /** Aria label to assign to the modal element. */
        this.ariaLabel = null;
        /** Whether the modal should focus the first focusable element on open. */
        this.autoFocus = true;
        /**
         * Whether the modal should restore focus to the
         * previously-focused element, after it's closed.
         */
        this.restoreFocus = true;
        /**
         * Whether the modal should close when the user goes backwards/forwards in history.
         * Note that this usually doesn't include clicking on links (unless the user is using
         * the `HashLocationStrategy`).
         */
        this.closeOnNavigation = true;
        /** Whether a close button with icon should be displayed in the top right corner of the modal.
         *
         * Default value is `false`.
         */
        this.showCloseIcon = false;
        /** Sets the 'aria-label' of the modal close button needed for accessibility.
         *
         * Default value is `'Close dialog'`.
         */
        this.closeIconButtonLabel = 'Close dialog';
        /** Sets locale direction for the modal
         *
         * Default value is `'ltr'`
         */
        this.direction = 'ltr';
    }
}

/**
 * Animations used by the NxModalContainer.
 * @docs-private
 */
const NxModalAnimations = {
    /** Animation that is applied on the modal container by defalt. */
    modalContainer: trigger('modalContainer', [
        // Note: The `enter` animation transitions to `transform: none`, because for some reason
        // specifying the transform explicitly, causes IE both to blur the modal content and
        // decimate the animation performance. Leaving it as `none` solves both issues.
        state('void, exit', style({ opacity: 0, transform: 'scale(1.3)' })),
        state('enter', style({ transform: 'none' })),
        transition('* => enter', animate('200ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'scale(1)', opacity: 1 }))),
        transition('* => void, * => exit', animate('200ms cubic-bezier(0.4, 0.0, 0.2, 1)', style({ opacity: 0, transform: 'scale(1.3)' }))),
    ]),
};

/**
 * Throws an exception for the case when a ComponentPortal is
 * attached to a DomPortalOutlet without an origin.
 * @docs-private
 */
function throwNxDialogContentAlreadyAttachedError() {
    throw Error('Attempting to attach modal content after content is already attached');
}
/**
 * Internal component that wraps user-provided modal content.
 * Animation is based on https://material.io/guidelines/motion/choreography.html.
 * @docs-private
 */
class NxModalContainer extends BasePortalOutlet {
    constructor(_elementRef, _focusTrapFactory, _cdr, _document, 
    /** The modal configuration. */
    _config, _focusMonitor) {
        super();
        this._elementRef = _elementRef;
        this._focusTrapFactory = _focusTrapFactory;
        this._cdr = _cdr;
        this._document = _document;
        this._config = _config;
        this._focusMonitor = _focusMonitor;
        /** Element that was focused before the modal was opened. Save this to restore upon close. */
        this._elementFocusedBeforeDialogWasOpened = null;
        /** State of the modal animation. */
        this._state = 'enter';
        /** Emits when an animation state changes. */
        this._animationStateChanged = new EventEmitter();
        /** Emits when the close button (X) is clicked. */
        this._closeButtonClicked = new EventEmitter();
        /**
         * Attaches a DOM portal to the modal container.
         * @param portal Portal to be attached.
         * @deprecated To be turned into a method when changed in the CDK.
         */
        this.attachDomPortal = (portal) => {
            if (this._portalOutlet.hasAttached()) {
                throwNxDialogContentAlreadyAttachedError();
            }
            this._savePreviouslyFocusedElement();
            return this._portalOutlet.attachDomPortal(portal);
        };
        this._ariaLabelledBy = _config.ariaLabelledBy || null;
    }
    ngAfterViewInit() {
        if (this._config.showCloseIcon) {
            this._focusMonitor.monitor(this._closeButton);
        }
    }
    ngOnDestroy() {
        this._focusMonitor.stopMonitoring(this._closeButton);
    }
    /**
     * Attach a ComponentPortal as content to this modal container.
     * @param portal Portal to be attached as the modal content.
     */
    attachComponentPortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throwNxDialogContentAlreadyAttachedError();
        }
        this._savePreviouslyFocusedElement();
        return this._portalOutlet.attachComponentPortal(portal);
    }
    /**
     * Attach a TemplatePortal as content to this modal container.
     * @param portal Portal to be attached as the modal content.
     */
    attachTemplatePortal(portal) {
        if (this._portalOutlet.hasAttached()) {
            throwNxDialogContentAlreadyAttachedError();
        }
        this._savePreviouslyFocusedElement();
        return this._portalOutlet.attachTemplatePortal(portal);
    }
    /** Moves the focus inside the focus trap. */
    _trapFocus() {
        const element = this._elementRef.nativeElement;
        if (!this._focusTrap) {
            this._focusTrap = this._focusTrapFactory.create(element);
        }
        // If we were to attempt to focus immediately, then the content of the modal would not yet be
        // ready in instances where change detection has to run first. To deal with this, we simply
        // wait for the microtask queue to be empty.
        if (this._config.autoFocus) {
            this._focusTrap.focusInitialElementWhenReady();
        }
        else {
            const activeElement = this._document?.activeElement;
            // Otherwise ensure that focus is on the modal container. It's possible that a different
            // component tried to move focus while the open animation was running. See:
            // https://github.com/angular/components/issues/16215. Note that we only want to do this
            // if the focus isn't inside the modal already, because it's possible that the consumer
            // turned off `autoFocus` in order to move focus themselves.
            if (activeElement !== element && !element.contains(activeElement)) {
                element.focus();
            }
        }
    }
    /** Restores focus to the element that was focused before the modal opened. */
    _restoreFocus() {
        const toFocus = this._elementFocusedBeforeDialogWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (this._config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {
            const activeElement = _getFocusedElementPierceShadowDom();
            const element = this._elementRef.nativeElement;
            // Make sure that focus is still inside the modal or is on the body (usually because a
            // non-focusable element like the backdrop was clicked) before moving it. It's possible that
            // the consumer moved it themselves before the animation was done, in which case we shouldn't
            // do anything.
            if (!activeElement || activeElement === this._document?.body || activeElement === element || element.contains(activeElement)) {
                this._focusMonitor.focusVia(toFocus, 'keyboard');
            }
        }
        if (this._focusTrap) {
            this._focusTrap.destroy();
        }
    }
    /** Saves a reference to the element that was focused before the modal was opened. */
    _savePreviouslyFocusedElement() {
        if (!this._document) {
            return;
        }
        this._elementFocusedBeforeDialogWasOpened = _getFocusedElementPierceShadowDom();
        // Note that there is no focus method when rendering on the server.
        if (this._elementRef.nativeElement.focus) {
            // Move focus onto the modal immediately in order to prevent the user from accidentally
            // opening multiple modals at the same time. Needs to be async, because the element
            // may not be focusable immediately.
            Promise.resolve().then(() => this._elementRef.nativeElement.focus());
        }
    }
    /** Callback, invoked whenever an animation on the host completes. */
    _onAnimationDone(event) {
        if (event.toState === 'enter') {
            this._trapFocus();
        }
        else if (event.toState === 'exit') {
            this._restoreFocus();
        }
        this._animationStateChanged.emit(event);
    }
    /** Callback, invoked when an animation on the host starts. */
    _onAnimationStart(event) {
        this._animationStateChanged.emit(event);
    }
    /** Starts the modal exit animation. */
    _startExitAnimation() {
        this._state = 'exit';
        // Mark the container for check so it can react if the
        // view container is using OnPush change detection.
        this._cdr.markForCheck();
    }
    _closeButtonClick() {
        this._closeButtonClicked.emit();
    }
}
NxModalContainer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalContainer, deps: [{ token: i0.ElementRef }, { token: i1.FocusTrapFactory }, { token: i0.ChangeDetectorRef }, { token: DOCUMENT, optional: true }, { token: NxModalConfig }, { token: i1.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxModalContainer.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxModalContainer, selector: "nx-modal-container", host: { attributes: { "tabindex": "-1", "aria-modal": "true" }, listeners: { "@modalContainer.start": "_onAnimationStart($event)", "@modalContainer.done": "_onAnimationDone($event)" }, properties: { "attr.id": "_id", "attr.role": "_config.role", "attr.aria-labelledby": "_config.ariaLabel ? null : _ariaLabelledBy", "attr.aria-label": "_config.ariaLabel", "attr.aria-describedby": "_config.ariaDescribedBy || null", "@modalContainer": "_state" }, classAttribute: "nx-modal__container" }, viewQueries: [{ propertyName: "_portalOutlet", first: true, predicate: CdkPortalOutlet, descendants: true, static: true }, { propertyName: "_closeButton", first: true, predicate: ["closeButton"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<button\n    #closeButton\n    *ngIf=\"_config.showCloseIcon\"\n    [attr.aria-label]=\"_config.closeIconButtonLabel\"\n    (click)=\"_closeButtonClick()\"\n    class=\"nx-modal__close\"\n    type=\"button\"\n>\n    <nx-icon name=\"close\"></nx-icon>\n</button>\n<ng-template cdkPortalOutlet></ng-template>\n", styles: [":host{background:var(--modal-background-color);color:var(--modal-text-color);margin:0 32px;padding:40px;border-radius:4px;box-shadow:var(--shadow-large);display:block;position:relative;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}@media (max-width: 703px){:host{margin:0 8px;padding:40px 32px 48px}}@media screen and (-ms-high-contrast: active){:host{border:2px solid windowText}}::ng-deep .nx-modal__content{display:block;margin:0 -40px;padding:0 40px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}@media (max-width: 703px){::ng-deep .nx-modal__content{margin:0 -32px;padding:0 32px}}::ng-deep .nx-modal__actions{margin-bottom:-48px;margin-left:-40px;margin-right:-40px;height:72px;border-top:1px solid var(--modal-actions-border-color);display:flex;align-items:center;justify-content:flex-end;padding:0 40px;border-bottom-left-radius:4px;border-bottom-right-radius:4px}@media (max-width: 703px){::ng-deep .nx-modal__actions{margin-left:-32px;margin-right:-32px;padding:0 32px}}.nx-modal__close{background-color:transparent;border:none;cursor:pointer;position:absolute;top:16px;right:16px;height:24px;outline:none;padding:0;color:var(--modal-close-icon-color)}.nx-modal__close nx-icon{font-size:24px}:host-context([dir=rtl]) .nx-modal__close{right:auto;left:16px}.nx-modal__close::-moz-focus-inner{border:0}.nx-modal__close.cdk-keyboard-focused{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-modal__close.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}\n"], components: [{ type: i3.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i5$1.CdkPortalOutlet, selector: "[cdkPortalOutlet]", inputs: ["cdkPortalOutlet"], outputs: ["attached"], exportAs: ["cdkPortalOutlet"] }], animations: [NxModalAnimations.modalContainer], changeDetection: i0.ChangeDetectionStrategy.Default });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalContainer, decorators: [{
            type: Component,
            args: [{ selector: 'nx-modal-container', changeDetection: ChangeDetectionStrategy.Default, animations: [NxModalAnimations.modalContainer], host: {
                        class: 'nx-modal__container',
                        tabindex: '-1',
                        'aria-modal': 'true',
                        '[attr.id]': '_id',
                        '[attr.role]': '_config.role',
                        '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',
                        '[attr.aria-label]': '_config.ariaLabel',
                        '[attr.aria-describedby]': '_config.ariaDescribedBy || null',
                        '[@modalContainer]': '_state',
                        '(@modalContainer.start)': '_onAnimationStart($event)',
                        '(@modalContainer.done)': '_onAnimationDone($event)',
                    }, template: "<button\n    #closeButton\n    *ngIf=\"_config.showCloseIcon\"\n    [attr.aria-label]=\"_config.closeIconButtonLabel\"\n    (click)=\"_closeButtonClick()\"\n    class=\"nx-modal__close\"\n    type=\"button\"\n>\n    <nx-icon name=\"close\"></nx-icon>\n</button>\n<ng-template cdkPortalOutlet></ng-template>\n", styles: [":host{background:var(--modal-background-color);color:var(--modal-text-color);margin:0 32px;padding:40px;border-radius:4px;box-shadow:var(--shadow-large);display:block;position:relative;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}@media (max-width: 703px){:host{margin:0 8px;padding:40px 32px 48px}}@media screen and (-ms-high-contrast: active){:host{border:2px solid windowText}}::ng-deep .nx-modal__content{display:block;margin:0 -40px;padding:0 40px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}@media (max-width: 703px){::ng-deep .nx-modal__content{margin:0 -32px;padding:0 32px}}::ng-deep .nx-modal__actions{margin-bottom:-48px;margin-left:-40px;margin-right:-40px;height:72px;border-top:1px solid var(--modal-actions-border-color);display:flex;align-items:center;justify-content:flex-end;padding:0 40px;border-bottom-left-radius:4px;border-bottom-right-radius:4px}@media (max-width: 703px){::ng-deep .nx-modal__actions{margin-left:-32px;margin-right:-32px;padding:0 32px}}.nx-modal__close{background-color:transparent;border:none;cursor:pointer;position:absolute;top:16px;right:16px;height:24px;outline:none;padding:0;color:var(--modal-close-icon-color)}.nx-modal__close nx-icon{font-size:24px}:host-context([dir=rtl]) .nx-modal__close{right:auto;left:16px}.nx-modal__close::-moz-focus-inner{border:0}.nx-modal__close.cdk-keyboard-focused{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-modal__close.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.FocusTrapFactory }, { type: i0.ChangeDetectorRef }, { type: Document, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: NxModalConfig }, { type: i1.FocusMonitor }]; }, propDecorators: { _portalOutlet: [{
                type: ViewChild,
                args: [CdkPortalOutlet, { static: true }]
            }], _closeButton: [{
                type: ViewChild,
                args: ['closeButton']
            }] } });

// Id counter
let nexId = 0;
/**
 * Reference to a modal opened via the NxDialogService.
 */
class NxModalRef {
    constructor(_overlayRef, _containerInstance, id = `nx-modal-${nexId++}`) {
        this._overlayRef = _overlayRef;
        this._containerInstance = _containerInstance;
        this.id = id;
        /** Whether the user is allowed to close the modal. */
        this.disableClose = this._containerInstance._config.disableClose;
        /** Subject for notifying the user that the modal has finished opening. */
        this._afterOpened = new Subject();
        /** Subject for notifying the user that the modal has finished closing. */
        this._afterClosed = new Subject();
        /** Subject for notifying the user that the modal has started closing. */
        this._beforeClosed = new Subject();
        /** Current state of the modal. */
        this._state = 0 /* OPEN */;
        // Pass the id along to the container.
        _containerInstance._id = id;
        // Emit when opening animation completes
        _containerInstance._animationStateChanged
            .pipe(filter(event => event.phaseName === 'done' && event.toState === 'enter'), take(1))
            .subscribe(() => {
            this._afterOpened.next();
            this._afterOpened.complete();
        });
        // Dispose overlay when closing animation is complete
        _containerInstance._animationStateChanged
            .pipe(filter(event => event.phaseName === 'done' && event.toState === 'exit'), take(1))
            .subscribe(() => {
            clearTimeout(this._closeFallbackTimeout);
            this._overlayRef.dispose();
        });
        _containerInstance._closeButtonClicked.subscribe(() => {
            this.close();
        });
        _overlayRef.detachments().subscribe(() => {
            this._beforeClosed.next(this._result);
            this._beforeClosed.complete();
            this._afterClosed.next(this._result);
            this._afterClosed.complete();
            this.componentInstance = null;
            this._overlayRef.dispose();
        });
        _overlayRef
            .keydownEvents()
            .pipe(filter(event => event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)))
            .subscribe(event => {
            event.preventDefault();
            this.close();
        });
    }
    /**
     * Close the modal.
     * @param modalResult Optional result to return to the modal opener.
     */
    close(modalResult) {
        this._result = modalResult;
        // Transition the backdrop in parallel to the modal.
        this._containerInstance._animationStateChanged
            .pipe(filter(event => event.phaseName === 'start'), take(1))
            .subscribe(event => {
            this._beforeClosed.next(modalResult);
            this._beforeClosed.complete();
            this._state = 2 /* CLOSED */;
            this._overlayRef.detachBackdrop();
            // The logic that disposes of the overlay depends on the exit animation completing, however
            // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback
            // timeout which will clean everything up if the animation hasn't fired within the specified
            // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the
            // vast majority of cases the timeout will have been cleared before it has the chance to fire.
            this._closeFallbackTimeout = setTimeout(() => {
                this._overlayRef.dispose();
            }, event.totalTime + 100);
        });
        this._containerInstance._startExitAnimation();
        this._state = 1 /* CLOSING */;
    }
    /**
     * Gets an observable that is notified when the modal is finished opening.
     */
    afterOpened() {
        return this._afterOpened.asObservable();
    }
    /**
     * Gets an observable that is notified when the modal is finished closing.
     */
    afterClosed() {
        return this._afterClosed.asObservable();
    }
    /**
     * Gets an observable that is notified when the modal has started closing.
     */
    beforeClosed() {
        return this._beforeClosed.asObservable();
    }
    /**
     * Gets an observable that emits when the overlay's backdrop has been clicked.
     */
    backdropClick() {
        return this._overlayRef.backdropClick();
    }
    /**
     * Gets an observable that emits when keydown events are targeted on the overlay.
     */
    keydownEvents() {
        return this._overlayRef.keydownEvents();
    }
    /**
     * Updates the modal's position.
     * @param position New modal position.
     */
    updatePosition(position) {
        const strategy = this._getPositionStrategy();
        if (position && (position.left || position.right)) {
            position.left ? strategy.left(position.left) : strategy.right(position.right);
        }
        else {
            strategy.centerHorizontally();
        }
        if (position && (position.top || position.bottom)) {
            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
        }
        else {
            strategy.centerVertically();
        }
        this._overlayRef.updatePosition();
        return this;
    }
    /**
     * Updates the modal's width and height.
     * @param width New width of the modal.
     * @param height New height of the modal.
     */
    updateSize(width = '', height = '') {
        this._getPositionStrategy().width(width).height(height);
        this._overlayRef.updatePosition();
        return this;
    }
    /** Add a CSS class or an array of classes to the overlay pane. */
    addPanelClass(classes) {
        this._overlayRef.addPanelClass(classes);
        return this;
    }
    /** Remove a CSS class or an array of classes from the overlay pane. */
    removePanelClass(classes) {
        this._overlayRef.removePanelClass(classes);
        return this;
    }
    /** Gets the current state of the modal's lifecycle. */
    getState() {
        return this._state;
    }
    /** Fetches the position strategy object from the overlay ref. */
    _getPositionStrategy() {
        return this._overlayRef.getConfig().positionStrategy;
    }
}

/** Injection token that can be used to access the data that was passed in to a modal. */
const NX_MODAL_DATA = new InjectionToken('NxModalData');
/** Injection token that can be used to specify default modal options. */
const NX_MODAL_DEFAULT_OPTIONS = new InjectionToken('nx-modal-default-options');
/** Injection token that determines the scroll handling while a modal is open. */
const NX_MODAL_SCROLL_STRATEGY = new InjectionToken('nx-modal-scroll-strategy');
/** @docs-private */
function NX_MODAL_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.block();
}
/** @docs-private */
const NX_MODAL_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_MODAL_SCROLL_STRATEGY,
    useFactory: NX_MODAL_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
/**
 * Service to open Material Design modal modals.
 */
class NxDialogService {
    constructor(_overlay, _injector, _defaultOptions, _parentDialogService, _overlayContainer, _defaultScrollStrategyFactory) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._defaultOptions = _defaultOptions;
        this._parentDialogService = _parentDialogService;
        this._overlayContainer = _overlayContainer;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this._openModalsAtThisLevel = [];
        this._afterAllClosedAtThisLevel = new Subject();
        this._afterOpenedAtThisLevel = new Subject();
        this._ariaHiddenElements = new Map();
        /**
         * Stream that emits when all open modal have finished closing.
         * Will emit on subscribe if there are no open modals to begin with.
         */
        this.afterAllClosed = defer(() => this.openModals.length ? this._afterAllClosed : this._afterAllClosed.pipe(startWith(undefined)));
        this._destroyed = new Subject();
        /** Strategy factory that will be used to handle scrolling while the modal panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
    }
    /** Keeps track of the currently-open modals. */
    get openModals() {
        return this._parentDialogService ? this._parentDialogService.openModals : this._openModalsAtThisLevel;
    }
    /** Stream that emits when a modal has been opened. */
    get afterOpened() {
        return this._parentDialogService ? this._parentDialogService.afterOpened : this._afterOpenedAtThisLevel;
    }
    get _afterAllClosed() {
        const parent = this._parentDialogService;
        return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
    }
    /**
     * Opens a modal modal containing the given component.
     * @param componentOrTemplateRef Type of the component to load into the dialog,
     *     or a TemplateRef to instantiate as the modal content.
     * @param config Extra configuration options.
     * @returns Reference to the newly-opened modal.
     */
    open(componentOrTemplateRef, config) {
        config = _applyConfigDefaults(config, this._defaultOptions || new NxModalConfig());
        if (config.id && this.getModalById(config.id)) {
            throw Error(`Modal with id "${config.id}" exists already. The modal id must be unique.`);
        }
        const overlayRef = this._createOverlay(config);
        const modalContainer = this._attachModalContainer(overlayRef, config);
        const modalRef = this._attachModalContent(componentOrTemplateRef, modalContainer, overlayRef, config);
        // If this is the first modal that we're opening, hide all the non-overlay content.
        if (!this.openModals.length) {
            this._hideNonModalContentFromAssistiveTechnology();
        }
        this.openModals.push(modalRef);
        modalRef.afterClosed().subscribe(() => this._removeOpenModal(modalRef));
        this.afterOpened.next(modalRef);
        return modalRef;
    }
    /**
     * Closes all of the currently-open modals.
     */
    closeAll() {
        this._closeModals(this.openModals);
    }
    /**
     * Finds an open modal by its id.
     * @param id ID to use when looking up the modal.
     */
    getModalById(id) {
        return this.openModals.find(modal => modal.id === id);
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        // Only close the modals at this level on destroy
        // since the parent service may still be active.
        this._closeModals(this._openModalsAtThisLevel);
        this._afterAllClosedAtThisLevel.complete();
        this._afterOpenedAtThisLevel.complete();
    }
    /**
     * Creates the overlay into which the modal will be loaded.
     * @param config The modal configuration.
     * @returns A promise resolving to the OverlayRef for the created overlay.
     */
    _createOverlay(config) {
        const overlayConfig = this._getOverlayConfig(config);
        return this._overlay.create(overlayConfig);
    }
    /**
     * Creates an overlay config from a modal config.
     * @param modalConfig The modal configuration.
     * @returns The overlay configuration.
     */
    _getOverlayConfig(modalConfig) {
        const state = new OverlayConfig({
            positionStrategy: this._overlay.position().global(),
            scrollStrategy: modalConfig.scrollStrategy || this._scrollStrategyFactory(),
            panelClass: modalConfig.panelClass,
            hasBackdrop: modalConfig.hasBackdrop,
            minWidth: modalConfig.minWidth,
            minHeight: modalConfig.minHeight,
            maxWidth: modalConfig.maxWidth,
            maxHeight: modalConfig.maxHeight,
            disposeOnNavigation: modalConfig.closeOnNavigation,
            direction: modalConfig.direction,
        });
        if (modalConfig.backdropClass) {
            state.backdropClass = modalConfig.backdropClass;
        }
        return state;
    }
    /**
     * Attaches an NxModalContainer to a dialog's already-created overlay.
     * @param overlay Reference to the dialog's underlying overlay.
     * @param config The modal configuration.
     * @returns A promise resolving to a ComponentRef for the attached container.
     */
    _attachModalContainer(overlay, config) {
        const userInjector = config?.viewContainerRef?.injector;
        const injector = Injector.create({
            parent: userInjector || this._injector,
            providers: [{ provide: NxModalConfig, useValue: config }],
        });
        const containerPortal = new ComponentPortal(NxModalContainer, config.viewContainerRef, injector, config.componentFactoryResolver);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * Attaches the user-provided component to the already-created NxModalContainer.
     * @param componentOrTemplateRef The type of component being loaded into the dialog,
     *     or a TemplateRef to instantiate as the content.
     * @param modalContainer Reference to the wrapping NxModalContainer.
     * @param overlayRef Reference to the overlay in which the modal resides.
     * @param config The modal configuration.
     * @returns A promise resolving to the NxModalRef that should be returned to the user.
     */
    _attachModalContent(componentOrTemplateRef, modalContainer, overlayRef, config) {
        // Create a reference to the modal we're creating in order to give the user a handle
        // to modify and close it.
        const modalRef = new NxModalRef(overlayRef, modalContainer, config.id);
        // When the modal backdrop is clicked, we want to close it.
        if (config.hasBackdrop) {
            overlayRef
                .backdropClick()
                .pipe(takeUntil(this._destroyed))
                .subscribe(() => {
                if (!modalRef.disableClose) {
                    modalRef.close();
                }
            });
        }
        if (componentOrTemplateRef instanceof TemplateRef) {
            modalContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, { $implicit: config.data, modalRef }));
        }
        else {
            const injector = this._createInjector(config, modalRef, modalContainer);
            const contentRef = modalContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));
            modalRef.componentInstance = contentRef.instance;
        }
        modalRef.updateSize(config.width, config.height).updatePosition(config.position);
        return modalRef;
    }
    /**
     * Creates a custom injector to be used inside the modal. This allows a component loaded inside
     * of a modal to close itself and, optionally, to return a value.
     * @param config Config object that is used to construct the modal.
     * @param modalRef Reference to the modal.
     * @param container Modal container element that wraps all of the contents.
     * @returns The custom injector that can be used inside the modal.
     */
    _createInjector(config, modalRef, modalContainer) {
        const userInjector = config?.viewContainerRef?.injector;
        // The NxModalContainer is injected in the portal as the NxModalContainer and the dialog's
        // content are created out of the same ViewContainerRef and as such, are siblings for injector
        // purposes. To allow the hierarchy that is expected, the NxModalContainer is explicitly
        // added to the injection tokens.
        const providers = [
            { provide: NxModalContainer, useValue: modalContainer },
            { provide: NX_MODAL_DATA, useValue: config.data },
            { provide: NxModalRef, useValue: modalRef },
        ];
        return Injector.create({ parent: userInjector || this._injector, providers });
    }
    /**
     * Removes a modal from the array of open modals.
     * @param modalRef Modal to be removed.
     */
    _removeOpenModal(modalRef) {
        const index = this.openModals.indexOf(modalRef);
        if (index > -1) {
            this.openModals.splice(index, 1);
            // If all the modals were closed, remove/restore the `aria-hidden`
            // to a the siblings and emit to the `afterAllClosed` stream.
            if (!this.openModals.length) {
                this._ariaHiddenElements.forEach((previousValue, element) => {
                    if (previousValue) {
                        element.setAttribute('aria-hidden', previousValue);
                    }
                    else {
                        element.removeAttribute('aria-hidden');
                    }
                });
                this._ariaHiddenElements.clear();
                this._afterAllClosed.next();
            }
        }
    }
    /**
     * Hides all of the content that isn't an overlay from assistive technology.
     */
    _hideNonModalContentFromAssistiveTechnology() {
        const overlayContainer = this._overlayContainer.getContainerElement();
        // Ensure that the overlay container is attached to the DOM.
        if (overlayContainer.parentElement) {
            const siblings = overlayContainer.parentElement.children;
            for (let i = siblings.length - 1; i > -1; i--) {
                const sibling = siblings[i];
                if (sibling !== overlayContainer && sibling.nodeName !== 'SCRIPT' && sibling.nodeName !== 'STYLE' && !sibling.hasAttribute('aria-live')) {
                    this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                    sibling.setAttribute('aria-hidden', 'true');
                }
            }
        }
    }
    /** Closes all of the modals in an array. */
    _closeModals(modals) {
        let i = modals.length;
        while (i--) {
            // The `_openModals` property isn't updated after close until the rxjs subscription
            // runs on the next microtask, in addition to modifying the array as we're going
            // through it. We loop through all of them and call close without assuming that
            // they'll be removed from the list instantaneously.
            modals[i].close();
        }
    }
}
NxDialogService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDialogService, deps: [{ token: i1$1.Overlay }, { token: i0.Injector }, { token: NX_MODAL_DEFAULT_OPTIONS, optional: true }, { token: NxDialogService, optional: true, skipSelf: true }, { token: i1$1.OverlayContainer }, { token: NX_MODAL_SCROLL_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });
NxDialogService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDialogService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDialogService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1$1.Overlay }, { type: i0.Injector }, { type: NxModalConfig, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [NX_MODAL_DEFAULT_OPTIONS]
                }] }, { type: NxDialogService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i1$1.OverlayContainer }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NX_MODAL_SCROLL_STRATEGY]
                }] }]; } });
/**
 * Applies default options to the modal config.
 * @param config Config to be modified.
 * @param defaultOptions Default options provided.
 * @returns The new configuration object.
 */
function _applyConfigDefaults(config, defaultOptions) {
    return { ...defaultOptions, ...config };
}

/**
 * Button that will close the current modal.
 */
class NxModalCloseDirective {
    constructor(modalRef, _elementRef, _dialogService) {
        this.modalRef = modalRef;
        this._elementRef = _elementRef;
        this._dialogService = _dialogService;
        /** Default to "button" to prevents accidental form submits. */
        this.type = 'button';
    }
    ngOnInit() {
        if (!this.modalRef) {
            // When this directive is included in a modal via TemplateRef (rather than being
            // in a Component), the DialogRef isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the DialogRef by
            // ID. This must occur in `onInit`, as the ID binding for the modal container won't
            // be resolved at constructor time.
            this.modalRef = getClosestDialog(this._elementRef, this._dialogService.openModals);
        }
    }
    ngOnChanges(changes) {
        const proxiedChange = changes['modalResult'];
        if (proxiedChange) {
            this.modalResult = proxiedChange.currentValue;
        }
    }
}
NxModalCloseDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalCloseDirective, deps: [{ token: NxModalRef, optional: true }, { token: i0.ElementRef }, { token: NxDialogService }], target: i0.ɵɵFactoryTarget.Directive });
NxModalCloseDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxModalCloseDirective, selector: "[nxModalClose]", inputs: { ariaLabel: ["aria-label", "ariaLabel"], type: "type", modalResult: ["nxModalClose", "modalResult"] }, host: { listeners: { "click": "modalRef.close(modalResult)" }, properties: { "attr.aria-label": "ariaLabel || null", "attr.type": "type" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxModalClose]',
                    host: {
                        '(click)': 'modalRef.close(modalResult)',
                        '[attr.aria-label]': 'ariaLabel || null',
                        '[attr.type]': 'type',
                    },
                }]
        }], ctorParameters: function () { return [{ type: NxModalRef, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef }, { type: NxDialogService }]; }, propDecorators: { ariaLabel: [{
                type: Input,
                args: ['aria-label']
            }], type: [{
                type: Input
            }], modalResult: [{
                type: Input,
                args: ['nxModalClose']
            }] } });
/**
 * Finds the closest NxModalRef to an element by looking at the DOM.
 * @param element Element relative to which to look for a modal.
 * @param openDialogs References to the currently-open modals.
 */
function getClosestDialog(element, openDialogs) {
    let parent = element.nativeElement.parentElement;
    while (parent && !parent.classList.contains('nx-modal__container')) {
        parent = parent.parentElement;
    }
    return parent ? openDialogs.find(modal => modal.id === parent.id) : null;
}

const fadeIn = animation([style({ opacity: 0 }), animate('300ms', style({ opacity: 1 }))]);
const fadeOut = animation(animate('300ms', style({ opacity: 0 })));
const scaleUp = animation([
    style({ transform: 'scale(1)', opacity: 1 }),
    animate('250ms', style({ transform: 'scale(1.3)', opacity: 0 })),
]);
const scaleDown = animation([
    style({ transform: 'scale(1.3)', opacity: 0 }),
    animate('250ms', style({ transform: 'scale(1)', opacity: 1 })),
]);

/** @docs-private */
class NxModalService {
    constructor() {
        this.subject = new Subject();
        this.close$ = this.subject.asObservable();
    }
    close() {
        this.subject.next();
    }
}
NxModalService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NxModalService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalService, decorators: [{
            type: Injectable
        }] });

/** Container for the action buttons in a modal. Has a fixed position at the bottom of the modal on scroll. */
class NxModalActionsDirective {
}
NxModalActionsDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalActionsDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
NxModalActionsDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxModalActionsDirective, selector: "[nxModalActions]", host: { properties: { "class.nx-modal__actions": "true" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalActionsDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxModalActions]',
                    host: {
                        '[class.nx-modal__actions]': 'true',
                    },
                }]
        }] });
/** Scrollable container for the content of a modal. */
class NxModalContentDirective {
}
NxModalContentDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalContentDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive });
NxModalContentDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxModalContentDirective, selector: "[nxModalContent]", host: { properties: { "class.nx-modal__content": "true" } }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalContentDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxModalContent]',
                    host: {
                        '[class.nx-modal__content]': 'true',
                    },
                }]
        }] });
class NxModalComponent {
    constructor(modalService, eventManager, _cdr, _focusMonitor) {
        this.modalService = modalService;
        this.eventManager = eventManager;
        this._cdr = _cdr;
        this._focusMonitor = _focusMonitor;
        this._closeButtonLabel = 'Close dialog';
        /**
         * Whether the modal view should close when the user hits the escape key.
         * Default is true.
         */
        this.hideOnEsc = true;
        /**
         * Whether the modal view should close when the user clicks on the backdrop.
         * Default is true.
         */
        this.hideOnClickOutside = true;
        /**
         * Whether the modal view should have a close icon in the upper right corner.
         * Default is true.
         */
        this.showCloseIcon = true;
        /**
         * Controls the width of the dialog.
         * On `auto` the width is controlled by the content width,
         * on `fixed` the dialog gets a fixed width of 736px if the viewport is big enough. */
        this.size = 'auto';
        /**
         * An event emitted when the user clicks on the backdrop or uses the built-in close button.
         * This event can be applied in conjunction with the custom open state handling
         * of a modal to close it when requested by the user.
         */
        this.closeEvent = new EventEmitter();
        this._destroyed = new Subject();
    }
    /** Sets the 'aria-label' of the modal close button needed for accessibility.
     *
     * Default value is 'Close dialog'.
     */
    set closeButtonLabel(value) {
        if (value !== this._closeButtonLabel) {
            this._closeButtonLabel = value;
            this._cdr.markForCheck();
        }
    }
    get closeButtonLabel() {
        return this._closeButtonLabel;
    }
    ngOnInit() {
        this.modalService.close$.pipe(takeUntil(this._destroyed)).subscribe(() => this.closeEvent.emit());
        this.removeEventListener = this.eventManager.addGlobalEventListener('window', 'keyup.esc', () => {
            if (this.hideOnEsc) {
                this.modalService.close();
            }
        });
    }
    ngAfterViewInit() {
        if (this.showCloseIcon) {
            this._focusMonitor.monitor(this._closeButton);
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this.removeEventListener();
        this._focusMonitor.stopMonitoring(this._closeButton);
    }
    /** @docs-private */
    clickOutsideModal() {
        if (this.hideOnClickOutside) {
            this.modalService.close();
        }
    }
    /** @docs-private */
    closeButtonClick() {
        this.modalService.close();
    }
    /** @docs-private */
    cancelClick(evt) {
        evt.stopPropagation();
    }
}
NxModalComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalComponent, deps: [{ token: NxModalService }, { token: i2.EventManager }, { token: i0.ChangeDetectorRef }, { token: i1.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxModalComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxModalComponent, selector: "nx-modal", inputs: { closeButtonLabel: "closeButtonLabel", body: ["nxBody", "body"], hideOnEsc: ["nxHideOnEsc", "hideOnEsc"], hideOnClickOutside: ["nxHideOnClickOutside", "hideOnClickOutside"], showCloseIcon: ["nxShowCloseIcon", "showCloseIcon"], size: ["nxSize", "size"] }, outputs: { closeEvent: "nxClose" }, host: { properties: { "@fadeInOut": "", "class.nx-modal--fixed-width": "size === \"fixed\"" } }, viewQueries: [{ propertyName: "_closeButton", first: true, predicate: ["closeButton"], descendants: true }], ngImport: i0, template: "<div class=\"nx-modal\" role=\"dialog\" cdkTrapFocus cdkTrapFocusAutoCapture cdkFocusInitial>\n    <div class=\"nx-modal__backdrop\" (click)=\"clickOutsideModal()\">\n        <div class=\"nx-modal__position\">\n            <div class=\"nx-modal__container\" (click)=\"cancelClick($event)\" [@scaleUpDown]>\n                <button\n                    #closeButton\n                    (click)=\"closeButtonClick()\"\n                    *ngIf=\"showCloseIcon\"\n                    [attr.aria-label]=\"closeButtonLabel\"\n                    class=\"nx-modal__close\"\n                    type=\"button\"\n                >\n                    <nx-icon name=\"close\"></nx-icon>\n                </button>\n\n                <div class=\"nx-modal__content-wrapper\" cdkScrollable>\n                    <ng-container *ngIf=\"body; else projectContent\">\n                        <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n                    </ng-container>\n\n                    <ng-template #projectContent>\n                        <ng-content></ng-content>\n                    </ng-template>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n", styles: [":host{position:relative;z-index:1000}.nx-modal{display:flex;position:fixed;width:100vw;height:100vh;top:0;bottom:0;left:0;right:0;z-index:1000;align-items:center;justify-content:center;transition:opacity .3s ease}.nx-modal__backdrop{background-color:#00000059;height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.nx-modal__position{position:absolute;display:inline-block;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20}.nx-modal__container{border-radius:4px;box-shadow:var(--shadow-large);background:var(--modal-background-color);color:var(--modal-text-color)}.nx-modal__content-wrapper{padding:40px 40px 48px;max-height:calc(100vh - 48px);overflow-y:auto}@media (max-width: 703px){.nx-modal__content-wrapper{max-height:70vh;padding:40px 32px 48px}}.nx-modal__close{background-color:transparent;border:none;cursor:pointer;position:absolute;top:16px;right:16px;height:24px;outline:none;padding:0;color:var(--modal-close-icon-color)}.nx-modal__close nx-icon{font-size:24px}.nx-modal__close::-moz-focus-inner{border:0}:host-context([dir=rtl]) .nx-modal__close{right:auto;left:16px}.nx-modal__close.cdk-keyboard-focused{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-modal__close.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}@media (max-width: 703px){.nx-modal__position{width:100%}.nx-modal__container{position:relative;max-width:calc(100vw - 16px);max-height:70vh;margin:0 auto}}:host(.nx-modal--fixed-width) .nx-modal__container{width:736px;max-width:calc(100vw - 16px)}::ng-deep .nx-modal__actions{height:72px;border-top:1px solid var(--modal-actions-border-color);display:flex;align-items:center;justify-content:flex-end;padding:0 40px;position:absolute;bottom:0;left:0;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px;background:var(--modal-actions-background-color)}::ng-deep .nx-modal__content{overflow-y:auto;max-height:calc(100vh - 120px);padding:0 40px;margin:0 -40px}@media (max-width: 703px){::ng-deep .nx-modal__content{max-height:calc(70vh - 120px);margin:0 -32px}}@media screen and (-ms-high-contrast: active){.nx-modal__content-wrapper,::ng-deep .nx-modal__actions{border:2px solid windowText}}\n"], components: [{ type: i3.NxIconComponent, selector: "nx-icon", inputs: ["name", "outline", "fill", "size", "font"] }], directives: [{ type: i1.CdkTrapFocus, selector: "[cdkTrapFocus]", inputs: ["cdkTrapFocus", "cdkTrapFocusAutoCapture"], exportAs: ["cdkTrapFocus"] }, { type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6.CdkScrollable, selector: "[cdk-scrollable], [cdkScrollable]" }, { type: i5.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet"] }], animations: [
        trigger('fadeInOut', [
            transition(':enter', [useAnimation(fadeIn), query('@scaleUpDown', [animateChild()])]),
            transition(':leave', [query('@scaleUpDown', [animateChild()]), useAnimation(fadeOut)]),
        ]),
        trigger('scaleUpDown', [transition(':enter', useAnimation(scaleDown)), transition(':leave', useAnimation(scaleUp))]),
    ], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-modal', changeDetection: ChangeDetectionStrategy.OnPush, animations: [
                        trigger('fadeInOut', [
                            transition(':enter', [useAnimation(fadeIn), query('@scaleUpDown', [animateChild()])]),
                            transition(':leave', [query('@scaleUpDown', [animateChild()]), useAnimation(fadeOut)]),
                        ]),
                        trigger('scaleUpDown', [transition(':enter', useAnimation(scaleDown)), transition(':leave', useAnimation(scaleUp))]),
                    ], host: {
                        '[@fadeInOut]': '',
                        '[class.nx-modal--fixed-width]': 'size === "fixed"',
                    }, template: "<div class=\"nx-modal\" role=\"dialog\" cdkTrapFocus cdkTrapFocusAutoCapture cdkFocusInitial>\n    <div class=\"nx-modal__backdrop\" (click)=\"clickOutsideModal()\">\n        <div class=\"nx-modal__position\">\n            <div class=\"nx-modal__container\" (click)=\"cancelClick($event)\" [@scaleUpDown]>\n                <button\n                    #closeButton\n                    (click)=\"closeButtonClick()\"\n                    *ngIf=\"showCloseIcon\"\n                    [attr.aria-label]=\"closeButtonLabel\"\n                    class=\"nx-modal__close\"\n                    type=\"button\"\n                >\n                    <nx-icon name=\"close\"></nx-icon>\n                </button>\n\n                <div class=\"nx-modal__content-wrapper\" cdkScrollable>\n                    <ng-container *ngIf=\"body; else projectContent\">\n                        <ng-container *ngTemplateOutlet=\"body\"></ng-container>\n                    </ng-container>\n\n                    <ng-template #projectContent>\n                        <ng-content></ng-content>\n                    </ng-template>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n", styles: [":host{position:relative;z-index:1000}.nx-modal{display:flex;position:fixed;width:100vw;height:100vh;top:0;bottom:0;left:0;right:0;z-index:1000;align-items:center;justify-content:center;transition:opacity .3s ease}.nx-modal__backdrop{background-color:#00000059;height:100%;left:0;position:absolute;top:0;width:100%;z-index:-1}.nx-modal__position{position:absolute;display:inline-block;top:50%;left:50%;transform:translate(-50%,-50%);z-index:20}.nx-modal__container{border-radius:4px;box-shadow:var(--shadow-large);background:var(--modal-background-color);color:var(--modal-text-color)}.nx-modal__content-wrapper{padding:40px 40px 48px;max-height:calc(100vh - 48px);overflow-y:auto}@media (max-width: 703px){.nx-modal__content-wrapper{max-height:70vh;padding:40px 32px 48px}}.nx-modal__close{background-color:transparent;border:none;cursor:pointer;position:absolute;top:16px;right:16px;height:24px;outline:none;padding:0;color:var(--modal-close-icon-color)}.nx-modal__close nx-icon{font-size:24px}.nx-modal__close::-moz-focus-inner{border:0}:host-context([dir=rtl]) .nx-modal__close{right:auto;left:16px}.nx-modal__close.cdk-keyboard-focused{box-shadow:var(--focus-box-shadow);border-radius:4px}@media screen and (-ms-high-contrast: active),(forced-colors: active){.nx-modal__close.cdk-keyboard-focused{box-shadow:0 0 0 2px background,0 0 0 6px windowText;outline:4px solid CanvasText;outline-offset:2px}}@media (max-width: 703px){.nx-modal__position{width:100%}.nx-modal__container{position:relative;max-width:calc(100vw - 16px);max-height:70vh;margin:0 auto}}:host(.nx-modal--fixed-width) .nx-modal__container{width:736px;max-width:calc(100vw - 16px)}::ng-deep .nx-modal__actions{height:72px;border-top:1px solid var(--modal-actions-border-color);display:flex;align-items:center;justify-content:flex-end;padding:0 40px;position:absolute;bottom:0;left:0;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px;background:var(--modal-actions-background-color)}::ng-deep .nx-modal__content{overflow-y:auto;max-height:calc(100vh - 120px);padding:0 40px;margin:0 -40px}@media (max-width: 703px){::ng-deep .nx-modal__content{max-height:calc(70vh - 120px);margin:0 -32px}}@media screen and (-ms-high-contrast: active){.nx-modal__content-wrapper,::ng-deep .nx-modal__actions{border:2px solid windowText}}\n"] }]
        }], ctorParameters: function () { return [{ type: NxModalService }, { type: i2.EventManager }, { type: i0.ChangeDetectorRef }, { type: i1.FocusMonitor }]; }, propDecorators: { _closeButton: [{
                type: ViewChild,
                args: ['closeButton']
            }], closeButtonLabel: [{
                type: Input
            }], body: [{
                type: Input,
                args: ['nxBody']
            }], hideOnEsc: [{
                type: Input,
                args: ['nxHideOnEsc']
            }], hideOnClickOutside: [{
                type: Input,
                args: ['nxHideOnClickOutside']
            }], showCloseIcon: [{
                type: Input,
                args: ['nxShowCloseIcon']
            }], size: [{
                type: Input,
                args: ['nxSize']
            }], closeEvent: [{
                type: Output,
                args: ['nxClose']
            }] } });

class NxOpenModalOnClickDirective {
    constructor(templateRef, viewContainer, modalService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.modalService = modalService;
        this._destroyed = new Subject();
        /** @docs-private */
        this.clickHandler = (event) => {
            this.viewContainer.clear();
            // instantiate the template onto which this directive is applied
            const viewRef = this.viewContainer.createEmbeddedView(this.templateRef);
            // we need to mark the viewRef explicitly if the modal is used inside another
            // component that is using onPush change detection
            viewRef.markForCheck();
            event.preventDefault();
            event.stopPropagation();
        };
    }
    ngOnInit() {
        this.modalService.close$.pipe(takeUntil(this._destroyed)).subscribe(() => this.viewContainer.clear());
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this.elements.forEach(el => {
            if (el.removeEventListener) {
                el.removeEventListener('click', this.clickHandler);
            }
        });
    }
    /**
     * One or multiple template reference variables pointing to elements
     * which should trigger opening the modal on click.
     *
     * Value: A single template reference variable or an array of template reference variables.
     */
    set nxOpenModalOnClick(elements) {
        // also support the case where only one element is passed, check for the length property to be sure elements is an array
        if (Array.isArray(elements)) {
            this.elements = elements;
        }
        else {
            this.elements = [elements];
        }
        // add a click event listener to any element passed as property to this directive
        this.elements.forEach(el => {
            if (el.addEventListener) {
                el.addEventListener('click', this.clickHandler);
                // workaround until refactoring: if the reference is a component
                // reference the component has to implement a getter to its own elementRef
            }
            else if (el.elementRef) {
                el.elementRef.nativeElement.addEventListener('click', this.clickHandler);
            }
            else {
                console.warn(`nxOpenModalOnClick: Given Element doesn't appear to be an ElementRef.`, el);
            }
        });
    }
}
NxOpenModalOnClickDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxOpenModalOnClickDirective, deps: [{ token: i0.TemplateRef }, { token: i0.ViewContainerRef }, { token: NxModalService }], target: i0.ɵɵFactoryTarget.Directive });
NxOpenModalOnClickDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxOpenModalOnClickDirective, selector: "[nxOpenModalOnClick]", inputs: { nxOpenModalOnClick: "nxOpenModalOnClick" }, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxOpenModalOnClickDirective, decorators: [{
            type: Directive,
            args: [{ selector: '[nxOpenModalOnClick]' }]
        }], ctorParameters: function () { return [{ type: i0.TemplateRef }, { type: i0.ViewContainerRef }, { type: NxModalService }]; }, propDecorators: { nxOpenModalOnClick: [{
                type: Input
            }] } });

class NxModalModule {
    // define the modal service on root level as an application wide singleton,
    // assuming that we only display one modal at a time, which seems quite reasonable
    // this is static and named "forRoot" by convention
    static forRoot() {
        return {
            ngModule: NxModalModule,
            providers: [NxModalService],
        };
    }
}
NxModalModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxModalModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalModule, declarations: [NxModalComponent,
        NxOpenModalOnClickDirective,
        NxModalActionsDirective,
        NxModalContentDirective,
        /* new modal implementation */
        NxModalContainer,
        NxModalCloseDirective], imports: [A11yModule, OverlayModule, PortalModule, CommonModule, NxIconModule], exports: [NxModalComponent,
        NxOpenModalOnClickDirective,
        NxModalActionsDirective,
        NxModalContentDirective,
        /* new modal implementation */
        NxModalContainer,
        NxModalCloseDirective] });
NxModalModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalModule, providers: [NxDialogService, NX_MODAL_SCROLL_STRATEGY_PROVIDER], imports: [[A11yModule, OverlayModule, PortalModule, CommonModule, NxIconModule]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [A11yModule, OverlayModule, PortalModule, CommonModule, NxIconModule],
                    declarations: [
                        NxModalComponent,
                        NxOpenModalOnClickDirective,
                        NxModalActionsDirective,
                        NxModalContentDirective,
                        /* new modal implementation */
                        NxModalContainer,
                        NxModalCloseDirective,
                    ],
                    exports: [
                        NxModalComponent,
                        NxOpenModalOnClickDirective,
                        NxModalActionsDirective,
                        NxModalContentDirective,
                        /* new modal implementation */
                        NxModalContainer,
                        NxModalCloseDirective,
                    ],
                    providers: [NxDialogService, NX_MODAL_SCROLL_STRATEGY_PROVIDER],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NX_MODAL_DATA, NX_MODAL_DEFAULT_OPTIONS, NX_MODAL_SCROLL_STRATEGY, NX_MODAL_SCROLL_STRATEGY_PROVIDER, NX_MODAL_SCROLL_STRATEGY_PROVIDER_FACTORY, NxDialogService, NxModalActionsDirective, NxModalAnimations, NxModalCloseDirective, NxModalComponent, NxModalConfig, NxModalContainer, NxModalContentDirective, NxModalModule, NxModalRef, NxModalService, NxOpenModalOnClickDirective, throwNxDialogContentAlreadyAttachedError };
//# sourceMappingURL=aposin-ng-aquila-modal.mjs.map
