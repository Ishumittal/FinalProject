{"version":3,"file":"aposin-ng-aquila-overlay.mjs","sources":["../../../projects/ng-aquila/src/overlay/overlay-config.ts","../../../projects/ng-aquila/src/overlay/overlay-container.component.ts","../../../projects/ng-aquila/src/overlay/overlay-container.component.html","../../../projects/ng-aquila/src/overlay/overlay-ref.ts","../../../projects/ng-aquila/src/overlay/position-builder.ts","../../../projects/ng-aquila/src/overlay/overlay-service.ts","../../../projects/ng-aquila/src/overlay/overlay.module.ts","../../../projects/ng-aquila/src/overlay/trigger-button.ts","../../../projects/ng-aquila/src/overlay/aposin-ng-aquila-overlay.ts"],"sourcesContent":["import { FlexibleConnectedPositionStrategy, ScrollStrategy } from '@angular/cdk/overlay';\nimport { ComponentFactoryResolver, ViewContainerRef } from '@angular/core';\n\nimport { NxTriggerButton } from './trigger-button';\n\n/** The ARIA role of the overlay. */\nexport type NxOverlayRole = string;\n\nexport type NxOverlayDirection = NxOverlayVerticalDirection | NxOverlayHorizontalDirection;\nexport declare type NxOverlayVerticalDirection = 'top' | 'top-start' | 'top-end' | 'bottom' | 'bottom-start' | 'bottom-end';\nexport declare type NxOverlayHorizontalDirection = 'left' | 'right';\n\nexport type NxOverlayFallbackOrientation = 'vertical' | 'horizontal' | 'clockwise';\n\nexport const VERTICAL_DIRECTIONS: NxOverlayDirection[] = ['top', 'bottom'];\nexport const HORIZONTAL_DIRECTIONS: NxOverlayDirection[] = ['left', 'right'];\nexport const CLOCKWISE_DIRECTIONS: NxOverlayDirection[] = ['top', 'right', 'bottom', 'left'];\n\nexport const BASE_OFFSET = 0; // TODO should be 16 once we have a \"showArrow\" option\n\n/**\n * Configuration for opening a overlay  with the NxDialogService.\n */\nexport class NxOverlayConfig<D = any> {\n    /**\n     * Where the attached component should live in Angular's *logical* component tree.\n     * This affects what is available for injection and the change detection order for the\n     * component instantiated inside of the overlay. This does not affect where the overlay\n     * content will be rendered.\n     */\n    viewContainerRef?: ViewContainerRef;\n\n    /** ID for the overlay. If omitted, a unique one will be generated. */\n    id?: string;\n\n    /** The ARIA role of the overlay element. */\n    role?: NxOverlayRole | null = null;\n\n    /** Custom class for the overlay pane. */\n    panelClass?: string | string[] = '';\n\n    /** Whether the overlay has a backdrop. */\n    hasBackdrop?: boolean = false;\n\n    /** Custom class for the backdrop. */\n    backdropClass?: string = '';\n\n    /** Whether the user can use escape or clicking on the backdrop to close the overlay. */\n    closeOnClickOutside?: boolean = true;\n\n    /** Width of the overlay. */\n    width?: number | string = '';\n\n    /** Height of the overlay. */\n    height?: number | string = '';\n\n    /** Min-width of the overlay. If a number is provided, assumes pixel units. */\n    minWidth?: number | string;\n\n    /** Min-height of the overlay. If a number is provided, assumes pixel units. */\n    minHeight?: number | string;\n\n    /** Max-width of the overlay. If a number is provided, assumes pixel units. Defaults to 100vw. */\n    maxWidth?: number | string = '';\n\n    /** Max-height of the overlay. If a number is provided, assumes pixel units. */\n    maxHeight?: number | string;\n\n    /** The distance from the trigger to the overlay in pixels. */\n    offset?: number;\n\n    /** Position overrides. */\n    direction?: NxOverlayDirection = 'bottom';\n\n    /** The fallbacks that are chosen. */\n    fallbackOrientation?: NxOverlayFallbackOrientation = 'clockwise';\n\n    /** ID of the element that describes the overlay. */\n    ariaDescribedBy?: string | null = null;\n\n    /** ID of the element that labels the overlay. */\n    ariaLabelledBy?: string | null = null;\n\n    /** Aria label to assign to the overlay element. */\n    ariaLabel?: string | null = null;\n\n    /** Whether the overlay should focus the first focusable element on open. */\n    autoFocus?: boolean = true;\n\n    /**\n     * Whether the overlay should restore focus to the\n     * previously-focused element, after it's closed.\n     */\n    restoreFocus?: boolean = true;\n\n    /** Scroll strategy to be used for the overlay. */\n    scrollStrategy?: ScrollStrategy;\n\n    /** Scroll strategy to be used for the overlay. */\n    positionStrategy?: FlexibleConnectedPositionStrategy;\n\n    /**\n     * Whether the overlay should close when the user goes backwards/forwards in history.\n     * Note that this usually doesn't include clicking on links (unless the user is using\n     * the `HashLocationStrategy`).\n     */\n    closeOnNavigation?: boolean = true;\n\n    /** Alternate `ComponentFactoryResolver` to use when resolving the associated component. */\n    componentFactoryResolver?: ComponentFactoryResolver;\n\n    triggerButton?: NxTriggerButton;\n}\n","import { FocusTrap, FocusTrapFactory } from '@angular/cdk/a11y';\nimport { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, DomPortal, TemplatePortal } from '@angular/cdk/portal';\nimport { DOCUMENT } from '@angular/common';\nimport { ChangeDetectionStrategy, Component, ComponentRef, ElementRef, EmbeddedViewRef, Inject, Optional, ViewChild } from '@angular/core';\n\nimport { NxOverlayConfig } from './overlay-config';\n\n/**\n * Throws an exception for the case when a ComponentPortal is\n * attached to a DomPortalOutlet without an origin.\n * @docs-private\n */\nexport function throwNxOverlayContentAlreadyAttachedError() {\n    throw Error('Attempting to attach overlay content after content is already attached');\n}\n\n/**\n * Internal component that wraps user-provided overlay content.\n */\n@Component({\n    selector: 'nx-overlay-container',\n    templateUrl: 'overlay-container.component.html',\n    styleUrls: ['overlay-container.component.scss'],\n    // Using OnPush for overlays caused some G3 sync issues. Disabled until we can track them down.\n    changeDetection: ChangeDetectionStrategy.Default,\n    host: {\n        class: 'nx-overlay-container',\n        '[attr.id]': '_id',\n        '[attr.role]': '_config.role',\n        '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',\n        '[attr.aria-label]': '_config.ariaLabel',\n        '[attr.aria-describedby]': '_config.ariaDescribedBy || null',\n    },\n})\nexport class NxOverlayContainerComponent extends BasePortalOutlet {\n    /** The portal outlet inside of this container into which the overlay content will be loaded. */\n    @ViewChild(CdkPortalOutlet, { static: true }) _portalOutlet!: CdkPortalOutlet;\n\n    /** The class that traps and manages focus within the overlay. */\n    private _focusTrap!: FocusTrap;\n\n    /** Element that was focused before the overlay was opened. Save this to restore upon close. */\n    private _elementFocusedBeforeDialogWasOpened: HTMLElement | null = null;\n\n    /** ID of the element that should be considered as the overlay's label. */\n    _ariaLabelledBy: string | null;\n\n    /** ID for the container DOM element. */\n    _id!: string;\n\n    constructor(\n        private _elementRef: ElementRef,\n        private _focusTrapFactory: FocusTrapFactory,\n        @Optional() @Inject(DOCUMENT) private _document: Document | null,\n        /** The overlay configuration. */\n        public _config: NxOverlayConfig,\n    ) {\n        super();\n        this._ariaLabelledBy = _config.ariaLabelledBy || null;\n    }\n\n    get elementRef() {\n        return this._elementRef;\n    }\n\n    /**\n     * Attach a ComponentPortal as content to this overlay container.\n     * @param portal Portal to be attached as the overlay content.\n     */\n    attachComponentPortal<T>(portal: ComponentPortal<T>): ComponentRef<T> {\n        if (this._portalOutlet.hasAttached()) {\n            throwNxOverlayContentAlreadyAttachedError();\n        }\n\n        this._savePreviouslyFocusedElement();\n        return this._portalOutlet.attachComponentPortal(portal);\n    }\n\n    /**\n     * Attach a TemplatePortal as content to this overlay container.\n     * @param portal Portal to be attached as the overlay content.\n     */\n    attachTemplatePortal<C>(portal: TemplatePortal<C>): EmbeddedViewRef<C> {\n        if (this._portalOutlet.hasAttached()) {\n            throwNxOverlayContentAlreadyAttachedError();\n        }\n        this._trapFocus();\n\n        this._savePreviouslyFocusedElement();\n        return this._portalOutlet.attachTemplatePortal(portal);\n    }\n\n    /**\n     * Attaches a DOM portal to the overlay container.\n     * @param portal Portal to be attached.\n     * @deprecated To be turned into a method when changed in the CDK.\n     */\n    attachDomPortal = (portal: DomPortal) => {\n        if (this._portalOutlet.hasAttached()) {\n            throwNxOverlayContentAlreadyAttachedError();\n        }\n\n        this._savePreviouslyFocusedElement();\n        return this._portalOutlet.attachDomPortal(portal);\n    };\n\n    /** Moves the focus inside the focus trap. */\n    private _trapFocus() {\n        const element = this._elementRef.nativeElement;\n\n        if (!this._focusTrap) {\n            this._focusTrap = this._focusTrapFactory.create(element);\n        }\n\n        // If we were to attempt to focus immediately, then the content of the overlay would not yet be\n        // ready in instances where change detection has to run first. To deal with this, we simply\n        // wait for the microtask queue to be empty.\n        if (this._config.autoFocus) {\n            this._focusTrap.focusInitialElementWhenReady();\n        } else {\n            const activeElement = this._document?.activeElement;\n\n            // Otherwise ensure that focus is on the overlay container. It's possible that a different\n            // component tried to move focus while the open animation was running. See:\n            // https://github.com/angular/components/issues/16215. Note that we only want to do this\n            // if the focus isn't inside the overlay already, because it's possible that the consumer\n            // turned off `autoFocus` in order to move focus themselves.\n            if (activeElement !== element && !element.contains(activeElement)) {\n                element.focus();\n            }\n        }\n    }\n\n    /** Restores focus to the element that was focused before the overlay opened. */\n    restoreFocus() {\n        const toFocus = this._elementFocusedBeforeDialogWasOpened;\n\n        // We need the extra check, because IE can set the `activeElement` to null in some cases.\n        if (this._config.restoreFocus && toFocus && typeof toFocus.focus === 'function') {\n            const activeElement = this._document?.activeElement;\n            const element = this._elementRef.nativeElement;\n\n            // Make sure that focus is still inside the overlay or is on the body (usually because a\n            // non-focusable element like the backdrop was clicked) before moving it. It's possible that\n            // the consumer moved it themselves before the animation was done, in which case we shouldn't\n            // do anything.\n            if (!activeElement || activeElement === this._document?.body || activeElement === element || element.contains(activeElement)) {\n                toFocus.focus();\n            }\n        }\n\n        if (this._focusTrap) {\n            this._focusTrap.destroy();\n        }\n    }\n\n    /** Saves a reference to the element that was focused before the overlay was opened. */\n    private _savePreviouslyFocusedElement() {\n        if (!this._document) {\n            return;\n        }\n        this._elementFocusedBeforeDialogWasOpened = this._document.activeElement as HTMLElement;\n\n        // Note that there is no focus method when rendering on the server.\n        if (this._elementRef.nativeElement.focus) {\n            // Move focus onto the overlay immediately in order to prevent the user from accidentally\n            // opening multiple overlays at the same time. Needs to be async, because the element\n            // may not be focusable immediately.\n            Promise.resolve().then(() => this._elementRef.nativeElement.focus());\n        }\n    }\n}\n","<ng-template cdkPortalOutlet></ng-template>\n","import { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nimport { FlexibleConnectedPositionStrategyOrigin, OverlayRef } from '@angular/cdk/overlay';\nimport { NavigationEnd, Router } from '@angular/router';\nimport { fromEvent, Observable, Subject } from 'rxjs';\nimport { filter, map, takeUntil } from 'rxjs/operators';\n\nimport { NxOverlayContainerComponent } from './overlay-container.component';\nimport { NxOverlayState } from './overlay-service';\n\n// Id counter\nlet nextId = 0;\n\n/**\n * Reference to a overlay opened via the NxDialogService.\n */\nexport class NxOverlayRef<T, R = any> {\n    /** The instance of component opened into the overlay. */\n    componentInstance!: T;\n\n    /** Whether the user is allowed to close the overlay. */\n    closeOnClickOutside: boolean | undefined = this._containerInstance._config.closeOnClickOutside;\n\n    /** Subject for notifying the user that the overlay has finished opening. */\n    private readonly _afterOpened = new Subject<void>();\n\n    /** Subject for notifying the user that the overlay has finished closing. */\n    private readonly _afterClosed = new Subject<R | undefined>();\n\n    /** Subject for notifying the user that the overlay has started closing. */\n    private readonly _beforeClosed = new Subject<R | undefined>();\n\n    private _documentClickObservable: Observable<MouseEvent>;\n\n    /** Result to be passed to afterClosed. */\n    private _result: R | undefined;\n\n    /** Current state of the overlay. */\n    private _state = NxOverlayState.OPEN;\n\n    constructor(\n        private _overlayRef: OverlayRef,\n        public _containerInstance: NxOverlayContainerComponent,\n        public origin: FlexibleConnectedPositionStrategyOrigin,\n        private _router: Router,\n        readonly id: string = `nx-overlay-${nextId++}`,\n    ) {\n        this._documentClickObservable = fromEvent<MouseEvent>(document, 'click');\n        _overlayRef\n            .backdropClick()\n            .pipe(takeUntil(this._afterClosed))\n            .subscribe(() => {\n                if (this.closeOnClickOutside) {\n                    this.close();\n                }\n            });\n\n        // We have to defer that or the same click that opened an overlay\n        // would immediately close it again.\n        setTimeout(() => this.waitForClose());\n\n        this._router.events.pipe(takeUntil(this.afterClosed())).subscribe(event => {\n            if (event instanceof NavigationEnd) {\n                this.close();\n            }\n        });\n\n        // Pass the id along to the container.\n        _containerInstance._id = id;\n\n        _overlayRef\n            .detachments()\n            .pipe(takeUntil(this._afterClosed))\n            .subscribe(() => {\n                this._beforeClosed.next(this._result);\n                this._beforeClosed.complete();\n                this._afterClosed.next(this._result);\n                this._afterClosed.complete();\n                this.componentInstance = null!;\n                this._overlayRef.dispose();\n            });\n\n        _overlayRef\n            .keydownEvents()\n            .pipe(\n                filter(event => event.keyCode === ESCAPE && !hasModifierKey(event)),\n                takeUntil(this._afterClosed),\n            )\n            .subscribe(event => {\n                event.preventDefault();\n                this.close();\n            });\n\n        this._afterOpened.next();\n        this._afterOpened.complete();\n    }\n\n    waitForClose() {\n        this._documentClickObservable\n            .pipe(\n                map(event => event.target as Node),\n                filter((target: Node) => !this._overlayRef.overlayElement?.contains(target)),\n                takeUntil(this._afterClosed),\n            )\n            .subscribe(() => {\n                if (this.closeOnClickOutside) {\n                    this.close();\n                }\n            });\n    }\n\n    /**\n     * Close the overlay.\n     * @param overlayResult Optional result to return to the overlay opener.\n     */\n    close(overlayResult?: R): void {\n        this._result = overlayResult;\n        this._beforeClosed.next(overlayResult);\n        this._beforeClosed.complete();\n        this._overlayRef.dispose();\n        this._state = NxOverlayState.CLOSED;\n        this._containerInstance.restoreFocus();\n        if (this._containerInstance._config.triggerButton) {\n            this._containerInstance._config.triggerButton.setTriggerInactive();\n        }\n    }\n\n    /**\n     * Gets an observable that is notified when the overlay is finished opening.\n     */\n    afterOpened(): Observable<void> {\n        return this._afterOpened.asObservable();\n    }\n\n    /**\n     * Gets an observable that is notified when the overlay is finished closing.\n     */\n    afterClosed(): Observable<R | undefined> {\n        return this._afterClosed.asObservable();\n    }\n\n    /**\n     * Gets an observable that is notified when the overlay has started closing.\n     */\n    beforeClosed(): Observable<R | undefined> {\n        return this._beforeClosed.asObservable();\n    }\n\n    /**\n     * Gets an observable that emits when the overlay's backdrop has been clicked.\n     */\n    backdropClick(): Observable<MouseEvent> {\n        return this._overlayRef.backdropClick();\n    }\n\n    /**\n     * Gets an observable that emits when keydown events are targeted on the overlay.\n     */\n    keydownEvents(): Observable<KeyboardEvent> {\n        return this._overlayRef.keydownEvents();\n    }\n\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes: string | string[]): this {\n        this._overlayRef.addPanelClass(classes);\n        return this;\n    }\n\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes: string | string[]): this {\n        this._overlayRef.removePanelClass(classes);\n        return this;\n    }\n\n    /** Gets the current state of the overlay's lifecycle. */\n    getState(): NxOverlayState {\n        return this._state;\n    }\n}\n","import { Directionality } from '@angular/cdk/bidi';\nimport {\n    ConnectionPositionPair,\n    FlexibleConnectedPositionStrategyOrigin,\n    HorizontalConnectionPos,\n    OriginConnectionPosition,\n    Overlay,\n    OverlayConnectionPosition,\n    VerticalConnectionPos,\n} from '@angular/cdk/overlay';\nimport { Injectable, Optional } from '@angular/core';\n\nimport { BASE_OFFSET, CLOCKWISE_DIRECTIONS, HORIZONTAL_DIRECTIONS, NxOverlayConfig, NxOverlayDirection, VERTICAL_DIRECTIONS } from './overlay-config';\n\n/**\n * Creates an error to be thrown if the user provided an invalid popover direction.\n * @docs-private\n */\nexport function getNxOverlayInvalidDirectionError(direction: string) {\n    return Error(`Overlay direction \"${direction}\" is invalid.`);\n}\n\nexport const OVERLAY_POSITIONS: { [key in NxOverlayDirection]: (isRtl: boolean) => OverlayConnectionPosition } = {\n    top(isRtl) {\n        return { overlayX: 'center', overlayY: 'bottom' };\n    },\n    'top-start': function (isRtl) {\n        return { overlayX: isRtl ? 'end' : 'start', overlayY: 'bottom' };\n    },\n    'top-end': function (isRtl) {\n        return { overlayX: isRtl ? 'start' : 'end', overlayY: 'bottom' };\n    },\n    bottom(isRtl) {\n        return { overlayX: 'center', overlayY: 'top' };\n    },\n    'bottom-start': function (isRtl) {\n        return { overlayX: isRtl ? 'end' : 'start', overlayY: 'top' };\n    },\n    'bottom-end': function (isRtl) {\n        return { overlayX: isRtl ? 'start' : 'end', overlayY: 'top' };\n    },\n    left(isRtl) {\n        return { overlayX: isRtl ? 'start' : 'end', overlayY: 'center' };\n    },\n    right(isRtl) {\n        return { overlayX: isRtl ? 'end' : 'start', overlayY: 'center' };\n    },\n};\nexport const ORIGIN_POSITIONS: { [key in NxOverlayDirection]: (arg0: boolean) => OriginConnectionPosition } = {\n    top(isRtl) {\n        return { originX: 'center', originY: 'top' };\n    },\n    'top-start': function (isRtl) {\n        return { originX: isRtl ? 'end' : 'start', originY: 'top' };\n    },\n    'top-end': function (isRtl) {\n        return { originX: isRtl ? 'start' : 'end', originY: 'top' };\n    },\n    bottom(isRtl) {\n        return { originX: 'center', originY: 'bottom' };\n    },\n    'bottom-start': function (isRtl) {\n        return { originX: isRtl ? 'end' : 'start', originY: 'bottom' };\n    },\n    'bottom-end': function (isRtl) {\n        return { originX: isRtl ? 'start' : 'end', originY: 'bottom' };\n    },\n    left(isRtl) {\n        return { originX: isRtl ? 'end' : 'start', originY: 'center' };\n    },\n    right(isRtl) {\n        return { originX: isRtl ? 'start' : 'end', originY: 'center' };\n    },\n};\n\n@Injectable()\nexport class NxOverlayPositionBuilder {\n    constructor(private _overlay: Overlay, @Optional() private _dir: Directionality | null) {}\n\n    createPositionStrategy(element: FlexibleConnectedPositionStrategyOrigin, config: NxOverlayConfig) {\n        const fallbacks = this._getFallbackPositions(config.direction as NxOverlayDirection, config);\n        const origin = this.getOrigin(config.direction);\n        const overlay = this.getOverlayPosition(config.direction);\n        const offset = this.getOffset(config.direction, config);\n        return this._overlay\n            .position()\n            .flexibleConnectedTo(element)\n            .withPush(false)\n            .withFlexibleDimensions(true)\n            .withLockedPosition()\n            .withGrowAfterOpen()\n            .withPositions([\n                {\n                    ...origin,\n                    ...overlay,\n                    ...offset,\n                },\n                ...fallbacks,\n            ]);\n    }\n\n    /**\n     * Returns the origin position based on the user's direction preference.\n     */\n    getOrigin(direction: NxOverlayDirection | undefined): OriginConnectionPosition {\n        if (!direction || !(direction in ORIGIN_POSITIONS)) {\n            throw getNxOverlayInvalidDirectionError(direction as string);\n        }\n        return ORIGIN_POSITIONS[direction](this.isRtl);\n    }\n\n    /** Returns the overlay position based on the user's direction preference */\n    getOverlayPosition(direction: NxOverlayDirection | undefined): OverlayConnectionPosition {\n        if (!direction || !(direction in OVERLAY_POSITIONS)) {\n            throw getNxOverlayInvalidDirectionError(direction as string);\n        }\n        return OVERLAY_POSITIONS[direction](this.isRtl);\n    }\n\n    /** Returns the overlay offset required by the user's direction preference */\n    getOffset(direction: NxOverlayDirection | undefined, config: NxOverlayConfig) {\n        if (!direction || !(direction in OVERLAY_POSITIONS)) {\n            throw getNxOverlayInvalidDirectionError(direction as string);\n        }\n        const offset = config.offset || BASE_OFFSET;\n        const [genericDirection] = direction.split('-');\n        switch (genericDirection) {\n            case 'top': {\n                return {\n                    offsetY: offset * -1,\n                };\n            }\n            case 'bottom': {\n                return {\n                    offsetY: offset,\n                };\n            }\n            case 'left': {\n                return {\n                    offsetX: offset * -1,\n                };\n            }\n            case 'right': {\n                return {\n                    offsetX: offset,\n                };\n            }\n            default: {\n                throw getNxOverlayInvalidDirectionError(direction);\n            }\n        }\n    }\n\n    /** Returns an array of fallback positions for popover, following the algoritm:\n     * 1) Slightly alternate preferred position if applicable. I.e. for 'top' try 'top-start' and 'top-end' positioning.\n     * 2) Try the opposite position, i.e. for 'top' try 'bottom'.\n     * 3) Slightly alternate opposite position, i.e. 'bottom-start', 'bottom-end'\n     * 4) All remaining positions from positions list\n     */\n    private _getFallbackPositions(direction: NxOverlayDirection, config: NxOverlayConfig): ConnectionPositionPair[] {\n        if (!direction) {\n            return [];\n        }\n\n        // create order of fallbacks like: if top then bottom, left, right\n        const fallbackOrder = this._getFallbackOrder(direction, config);\n        // add positions like {direction}-start and filter the requested direction\n        const resolvedDirections = this._resolveFallbacks(fallbackOrder, config).filter(d => d !== direction);\n\n        const fallbackPositions: ConnectionPositionPair[] = [];\n\n        resolvedDirections.forEach(fallbackDirection => {\n            const origin = this.getOrigin(fallbackDirection);\n            const overlay = this.getOverlayPosition(fallbackDirection);\n            const offset = this.getOffset(fallbackDirection, config);\n            fallbackPositions.push({\n                ...origin,\n                ...overlay,\n                ...offset,\n            });\n        });\n\n        return fallbackPositions;\n    }\n\n    /** Takes the defined fallback orders and adjusts it for the requested direction */\n    private _getFallbackOrder(direction: NxOverlayDirection, config: NxOverlayConfig) {\n        let order: NxOverlayDirection[];\n        switch (config.fallbackOrientation) {\n            case 'vertical':\n                order = VERTICAL_DIRECTIONS;\n                break;\n            case 'horizontal':\n                order = HORIZONTAL_DIRECTIONS;\n                break;\n            case 'clockwise':\n                order = CLOCKWISE_DIRECTIONS;\n                break;\n            default:\n                throw getNxOverlayInvalidDirectionError(config.fallbackOrientation || '');\n        }\n        // reorder the array to start from the requested position\n        const [generalDirection] = this._splitDirection(direction);\n        const directionIndex = order.indexOf(generalDirection as NxOverlayDirection);\n        return [...order.slice(directionIndex), ...order.slice(0, directionIndex)];\n    }\n\n    // We often need the general direction like top or bottom if the requested direction\n    // is like bottom-start\n    private _splitDirection(direction: NxOverlayDirection) {\n        return direction.split('-');\n    }\n\n    get isRtl(): boolean {\n        return this._dir?.value === 'rtl';\n    }\n\n    /** Returns the opposite position, using angular position naming: top, bottom, start, end, center */\n    private _getInversePosition(position: string): VerticalConnectionPos | HorizontalConnectionPos {\n        const positionPairs: { [k: string]: VerticalConnectionPos | HorizontalConnectionPos } = {\n            top: 'bottom',\n            bottom: 'top',\n            start: 'end',\n            end: 'start',\n            center: 'center',\n        };\n        return positionPairs[position];\n    }\n\n    /** Resolve the fallback order to all possible direction. For top and bottom we want to add the start and end positions. */\n    private _resolveFallbacks(fallbacks: NxOverlayDirection[], config: NxOverlayConfig) {\n        if (!config.direction) {\n            throw getNxOverlayInvalidDirectionError('');\n        }\n        const [generalDirection, addition] = this._splitDirection(config.direction);\n        return fallbacks.reduce((resolved: NxOverlayDirection[], direction) => {\n            if (direction === 'top' || direction === 'bottom') {\n                if (addition) {\n                    // if we have something like bottom-start we want to do bottom-end first\n                    resolved.push(\n                        `${direction}-${addition}` as NxOverlayDirection,\n                        `${direction}-${this._getInversePosition(addition)}` as NxOverlayDirection,\n                        direction,\n                    );\n                } else {\n                    resolved.push(direction, `${direction}-start` as NxOverlayDirection, `${direction}-end` as NxOverlayDirection);\n                }\n            } else {\n                resolved.push(direction);\n            }\n            return resolved;\n        }, []);\n    }\n}\n","import { Direction, Directionality } from '@angular/cdk/bidi';\nimport { FlexibleConnectedPositionStrategyOrigin, Overlay, OverlayConfig, OverlayRef, ScrollStrategy } from '@angular/cdk/overlay';\nimport { ComponentPortal, ComponentType, TemplatePortal } from '@angular/cdk/portal';\nimport { Inject, Injectable, InjectionToken, Injector, OnDestroy, Optional, SkipSelf, StaticProvider, TemplateRef } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Subject } from 'rxjs';\n\nimport { NxOverlayConfig } from './overlay-config';\nimport { NxOverlayContainerComponent } from './overlay-container.component';\nimport { NxOverlayRef } from './overlay-ref';\nimport { NxOverlayPositionBuilder } from './position-builder';\n\n/** Injection token that determines the scroll handling while a overlay is open. */\nexport const NX_OVERLAY_SCROLL_STRATEGY = new InjectionToken<() => ScrollStrategy>('nx-overlay-scroll-strategy');\n\n/** @docs-private */\nexport function NX_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => ScrollStrategy {\n    return () => overlay.scrollStrategies.reposition();\n}\n\n/** @docs-private */\nexport const NX_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: NX_OVERLAY_SCROLL_STRATEGY,\n    useFactory: NX_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n    deps: [Overlay],\n};\n\n/** Possible states of the lifecycle of a overlay. */\nexport const enum NxOverlayState {\n    OPEN,\n    CLOSED,\n}\n\n@Injectable()\nexport class NxOverlayService implements OnDestroy {\n    private readonly _afterAllClosedAtThisLevel = new Subject<void>();\n    private readonly _afterOpenedAtThisLevel = new Subject<NxOverlayRef<any>>();\n    private _openOverlaysAtThisLevel: NxOverlayRef<any>[] = [];\n\n    /** Strategy factory that will be used to handle scrolling while an overlay panel is open. */\n    private _scrollStrategyFactory = this._defaultScrollStrategyFactory;\n\n    constructor(\n        private _overlay: Overlay,\n        private _injector: Injector,\n        private _router: Router,\n        private _positionBuilder: NxOverlayPositionBuilder,\n        @Optional() @SkipSelf() private _parentOverlayService: NxOverlayService | null,\n        @Optional() private _dir: Directionality | null,\n        @Inject(NX_OVERLAY_SCROLL_STRATEGY) private _defaultScrollStrategyFactory: () => ScrollStrategy,\n    ) {}\n\n    /** Keeps track of the currently-open overlays. */\n    get openOverlays(): NxOverlayRef<any>[] {\n        return this._parentOverlayService ? this._parentOverlayService.openOverlays : this._openOverlaysAtThisLevel;\n    }\n\n    /** The text direction of the containing app. */\n    get dir(): Direction {\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n    }\n\n    /**\n     * Opens a panel containing the given component and attaches it to an element.\n     * @param componentOrTemplateRef Type of the component to load into the dialog,\n     *     or a TemplateRef to instantiate as the panel content.\n     * @param config Extra configuration options.\n     * @returns Reference to the newly-opened panel.\n     */\n    open<T, D = any, R = any>(\n        componentOrTemplateRef: ComponentType<T> | TemplateRef<T>,\n        origin: FlexibleConnectedPositionStrategyOrigin,\n        config?: NxOverlayConfig<D>,\n    ): NxOverlayRef<T, R> {\n        config = _applyConfigDefaults(config, new NxOverlayConfig());\n\n        if (config.id && this.getOverlayById(config.id)) {\n            throw Error(`Overlay with id \"${config.id}\" exists already. The overlay id must be unique.`);\n        }\n\n        const cdkOverlayRef = this._createOverlay(config, origin);\n        const overlayContainer = this._attachOverlayContainer(cdkOverlayRef, config);\n        const overlayRef = this._attachOverlayContent<T, R>(componentOrTemplateRef, overlayContainer, cdkOverlayRef, config, origin);\n\n        this.openOverlays.push(overlayRef);\n        overlayRef.afterClosed().subscribe(() => this._removeOpenOverlay(overlayRef));\n\n        if (config.triggerButton) {\n            config.triggerButton.setTriggerActive();\n        }\n        return overlayRef;\n    }\n\n    /**\n     * Finds an open overlay by its id.\n     * @param id ID to use when looking up the overlay.\n     */\n    getOverlayById(id: string): NxOverlayRef<any> | undefined {\n        return this.openOverlays.find(overlay => overlay.id === id);\n    }\n\n    ngOnDestroy() {\n        // Only close the overlays at this level on destroy\n        // since the parent service may still be active.\n        this._closeOverlays(this._openOverlaysAtThisLevel);\n        this._afterAllClosedAtThisLevel.complete();\n        this._afterOpenedAtThisLevel.complete();\n    }\n\n    /**\n     * Creates the overlay into which the overlay will be loaded.\n     * @param config The overlay configuration.\n     * @returns A promise resolving to the OverlayRef for the created overlay.\n     */\n    private _createOverlay(config: NxOverlayConfig, origin: FlexibleConnectedPositionStrategyOrigin): OverlayRef {\n        const overlayConfig = this._getOverlayConfig(config, origin);\n        return this._overlay.create(overlayConfig);\n    }\n\n    /*\n     **\n     * Creates a CDK overlay configuration from the overlay service config.\n     * @param overlayConfig The nx overlay service configuration.\n     * @returns The CDK overlay configuration.\n     */\n    private _getOverlayConfig(overlayConfig: NxOverlayConfig, origin: FlexibleConnectedPositionStrategyOrigin): OverlayConfig {\n        const state = new OverlayConfig({\n            positionStrategy: overlayConfig.positionStrategy || this._positionBuilder.createPositionStrategy(origin, overlayConfig),\n            scrollStrategy: overlayConfig.scrollStrategy || this._scrollStrategyFactory(),\n            panelClass: overlayConfig.panelClass,\n            hasBackdrop: overlayConfig.hasBackdrop,\n            width: overlayConfig.width,\n            height: overlayConfig.height,\n            minWidth: overlayConfig.minWidth,\n            minHeight: overlayConfig.minHeight,\n            maxWidth: overlayConfig.maxWidth,\n            maxHeight: overlayConfig.maxHeight,\n            disposeOnNavigation: overlayConfig.closeOnNavigation,\n            direction: this.dir,\n        });\n\n        if (overlayConfig.backdropClass) {\n            state.backdropClass = overlayConfig.backdropClass;\n        }\n\n        return state;\n    }\n\n    get isRtl(): boolean {\n        return this._dir?.value === 'rtl';\n    }\n\n    /**\n     * Attaches an NxOverlayContainer to the already-created overlay.\n     * @param cdkOverlay Reference to the dialog's underlying overlay.\n     * @param config The overlay configuration.\n     * @returns A promise resolving to a ComponentRef for the attached container.\n     */\n    private _attachOverlayContainer(cdkOverlay: OverlayRef, config: NxOverlayConfig): NxOverlayContainerComponent {\n        const userInjector = config?.viewContainerRef?.injector;\n        const injector = Injector.create({\n            parent: userInjector || this._injector,\n            providers: [{ provide: NxOverlayConfig, useValue: config }],\n        });\n\n        const containerPortal = new ComponentPortal(NxOverlayContainerComponent, config.viewContainerRef, injector, config.componentFactoryResolver);\n        const containerRef = cdkOverlay.attach<NxOverlayContainerComponent>(containerPortal);\n\n        return containerRef.instance;\n    }\n\n    /**\n     * Attaches the user-provided component to the already-created NxOverlayContainer.\n     * @param componentOrTemplateRef The type of component being loaded into the dialog,\n     *     or a TemplateRef to instantiate as the content.\n     * @param overlayContainer Reference to the wrapping NxOverlayContainer.\n     * @param cdkOverlayRef Reference to the overlay in which the overlay resides.\n     * @param config The overlay configuration.\n     * @returns A promise resolving to the NxOverlayRef that should be returned to the user.\n     */\n    private _attachOverlayContent<T, R>(\n        componentOrTemplateRef: ComponentType<T> | TemplateRef<T>,\n        overlayContainer: NxOverlayContainerComponent,\n        cdkOverlayRef: OverlayRef,\n        config: NxOverlayConfig,\n        origin: FlexibleConnectedPositionStrategyOrigin,\n    ): NxOverlayRef<T, R> {\n        // Create a reference to the overlay we're creating in order to give the user a handle\n        // to modify and close it.\n        const overlayRef = new NxOverlayRef<T, R>(cdkOverlayRef, overlayContainer, origin, this._router, config.id);\n\n        if (componentOrTemplateRef instanceof TemplateRef) {\n            overlayContainer.attachTemplatePortal(new TemplatePortal<T>(componentOrTemplateRef, null!, { $implicit: overlayRef } as any));\n        } else {\n            const injector = this._createInjector<T>(config, overlayRef, overlayContainer);\n            const contentRef = overlayContainer.attachComponentPortal<T>(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));\n            overlayRef.componentInstance = contentRef.instance;\n        }\n\n        return overlayRef;\n    }\n\n    /**\n     * Creates a custom injector to be used inside the overlay. This allows a component loaded inside\n     * of a overlay to close itself and, optionally, to return a value.\n     * @param config Config object that is used to construct the overlay.\n     * @param overlayRef Reference to the overlay.\n     * @param container Overlay container element that wraps all of the contents.\n     * @returns The custom injector that can be used inside the overlay.\n     */\n    private _createInjector<T>(config: NxOverlayConfig, overlayRef: NxOverlayRef<T>, overlayContainer: NxOverlayContainerComponent): Injector {\n        const userInjector = config?.viewContainerRef?.injector;\n\n        // The NxOverlayContainer is injected in the portal as the NxOverlayContainer and the overlays's\n        // content are created out of the same ViewContainerRef and as such, are siblings for injector\n        // purposes. To allow the hierarchy that is expected, the NxOverlayContainer is explicitly\n        // added to the injection tokens.\n        const providers: StaticProvider[] = [\n            { provide: NxOverlayContainerComponent, useValue: overlayContainer },\n            { provide: NxOverlayRef, useValue: overlayRef },\n        ];\n\n        return Injector.create({ parent: userInjector || this._injector, providers });\n    }\n\n    /**\n     * Removes a overlay from the array of open overlays.\n     * @param overlayRef Overlay to be removed.\n     */\n    private _removeOpenOverlay(overlayRef: NxOverlayRef<any>) {\n        const index = this.openOverlays.indexOf(overlayRef);\n\n        if (index > -1) {\n            this.openOverlays.splice(index, 1);\n        }\n    }\n\n    /** Closes all of the overlays in an array. */\n    private _closeOverlays(overlays: NxOverlayRef<any>[]) {\n        let i = overlays.length;\n\n        while (i--) {\n            // The `_openOverlays` property isn't updated after close until the rxjs subscription\n            // runs on the next microtask, in addition to modifying the array as we're going\n            // through it. We loop through all of them and call close without assuming that\n            // they'll be removed from the list instantaneously.\n            overlays[i].close();\n        }\n    }\n}\n\n/**\n * Applies default options to the overlay config.\n * @param config Config to be modified.\n * @param defaultOptions Default options provided.\n * @returns The new configuration object.\n */\nfunction _applyConfigDefaults(config?: NxOverlayConfig, defaultOptions?: NxOverlayConfig): NxOverlayConfig {\n    return { ...defaultOptions, ...config };\n}\n","import { A11yModule } from '@angular/cdk/a11y';\nimport { OverlayModule } from '@angular/cdk/overlay';\nimport { PortalModule } from '@angular/cdk/portal';\nimport { NgModule } from '@angular/core';\nimport { RouterModule } from '@angular/router';\n\nimport { NxOverlayContainerComponent } from './overlay-container.component';\nimport { NX_OVERLAY_SCROLL_STRATEGY_PROVIDER, NxOverlayService } from './overlay-service';\nimport { NxOverlayPositionBuilder } from './position-builder';\n\n@NgModule({\n    imports: [OverlayModule, A11yModule, PortalModule, RouterModule],\n    exports: [NxOverlayContainerComponent, OverlayModule],\n    declarations: [NxOverlayContainerComponent],\n    providers: [NxOverlayService, NxOverlayPositionBuilder, NX_OVERLAY_SCROLL_STRATEGY_PROVIDER],\n})\nexport class NxOverlayModule {}\n","import { Directive } from '@angular/core';\n\n/**\n * Interface for any kind of button that should be active while\n * an overlay is open.\n */\n@Directive()\nexport abstract class NxTriggerButton {\n    /** Applies active styles to the button. */\n    abstract setTriggerActive(): void;\n    /** Applies or unsets inactive styles to the button. */\n    abstract setTriggerInactive(): void;\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["i2.NxOverlayConfig","i1","i2","i3.NxOverlayPositionBuilder","i4"],"mappings":";;;;;;;;;;;;;;;;MAca,mBAAmB,GAAyB,CAAC,KAAK,EAAE,QAAQ,EAAE;MAC9D,qBAAqB,GAAyB,CAAC,MAAM,EAAE,OAAO,EAAE;AACtE,MAAM,oBAAoB,GAAyB,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE;AAEhF,MAAA,WAAW,GAAG,EAAE;AAE7B;;AAEG;MACU,eAAe,CAAA;AAA5B,IAAA,WAAA,GAAA;;QAaI,IAAI,CAAA,IAAA,GAA0B,IAAI,CAAC;;QAGnC,IAAU,CAAA,UAAA,GAAuB,EAAE,CAAC;;QAGpC,IAAW,CAAA,WAAA,GAAa,KAAK,CAAC;;QAG9B,IAAa,CAAA,aAAA,GAAY,EAAE,CAAC;;QAG5B,IAAmB,CAAA,mBAAA,GAAa,IAAI,CAAC;;QAGrC,IAAK,CAAA,KAAA,GAAqB,EAAE,CAAC;;QAG7B,IAAM,CAAA,MAAA,GAAqB,EAAE,CAAC;;QAS9B,IAAQ,CAAA,QAAA,GAAqB,EAAE,CAAC;;QAShC,IAAS,CAAA,SAAA,GAAwB,QAAQ,CAAC;;QAG1C,IAAmB,CAAA,mBAAA,GAAkC,WAAW,CAAC;;QAGjE,IAAe,CAAA,eAAA,GAAmB,IAAI,CAAC;;QAGvC,IAAc,CAAA,cAAA,GAAmB,IAAI,CAAC;;QAGtC,IAAS,CAAA,SAAA,GAAmB,IAAI,CAAC;;QAGjC,IAAS,CAAA,SAAA,GAAa,IAAI,CAAC;AAE3B;;;AAGG;QACH,IAAY,CAAA,YAAA,GAAa,IAAI,CAAC;AAQ9B;;;;AAIG;QACH,IAAiB,CAAA,iBAAA,GAAa,IAAI,CAAC;KAMtC;AAAA;;ACzGD;;;;AAIG;SACa,yCAAyC,GAAA;AACrD,IAAA,MAAM,KAAK,CAAC,wEAAwE,CAAC,CAAC;AAC1F,CAAC;AAED;;AAEG;AAgBG,MAAO,2BAA4B,SAAQ,gBAAgB,CAAA;AAgB7D,IAAA,WAAA,CACY,WAAuB,EACvB,iBAAmC,EACL,SAA0B;;IAEzD,OAAwB,EAAA;AAE/B,QAAA,KAAK,EAAE,CAAC;QANA,IAAW,CAAA,WAAA,GAAX,WAAW,CAAY;QACvB,IAAiB,CAAA,iBAAA,GAAjB,iBAAiB,CAAkB;QACL,IAAS,CAAA,SAAA,GAAT,SAAS,CAAiB;QAEzD,IAAO,CAAA,OAAA,GAAP,OAAO,CAAiB;;QAb3B,IAAoC,CAAA,oCAAA,GAAuB,IAAI,CAAC;AAkDxE;;;;AAIG;AACH,QAAA,IAAA,CAAA,eAAe,GAAG,CAAC,MAAiB,KAAI;AACpC,YAAA,IAAI,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,EAAE;AAClC,gBAAA,yCAAyC,EAAE,CAAC;AAC/C,aAAA;YAED,IAAI,CAAC,6BAA6B,EAAE,CAAC;YACrC,OAAO,IAAI,CAAC,aAAa,CAAC,eAAe,CAAC,MAAM,CAAC,CAAC;AACtD,SAAC,CAAC;QA9CE,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,cAAc,IAAI,IAAI,CAAC;KACzD;AAED,IAAA,IAAI,UAAU,GAAA;QACV,OAAO,IAAI,CAAC,WAAW,CAAC;KAC3B;AAED;;;AAGG;AACH,IAAA,qBAAqB,CAAI,MAA0B,EAAA;AAC/C,QAAA,IAAI,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,EAAE;AAClC,YAAA,yCAAyC,EAAE,CAAC;AAC/C,SAAA;QAED,IAAI,CAAC,6BAA6B,EAAE,CAAC;QACrC,OAAO,IAAI,CAAC,aAAa,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC;KAC3D;AAED;;;AAGG;AACH,IAAA,oBAAoB,CAAI,MAAyB,EAAA;AAC7C,QAAA,IAAI,IAAI,CAAC,aAAa,CAAC,WAAW,EAAE,EAAE;AAClC,YAAA,yCAAyC,EAAE,CAAC;AAC/C,SAAA;QACD,IAAI,CAAC,UAAU,EAAE,CAAC;QAElB,IAAI,CAAC,6BAA6B,EAAE,CAAC;QACrC,OAAO,IAAI,CAAC,aAAa,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;KAC1D;;IAiBO,UAAU,GAAA;AACd,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC;AAE/C,QAAA,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YAClB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;AAC5D,SAAA;;;;AAKD,QAAA,IAAI,IAAI,CAAC,OAAO,CAAC,SAAS,EAAE;AACxB,YAAA,IAAI,CAAC,UAAU,CAAC,4BAA4B,EAAE,CAAC;AAClD,SAAA;AAAM,aAAA;AACH,YAAA,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC;;;;;;YAOpD,IAAI,aAAa,KAAK,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;gBAC/D,OAAO,CAAC,KAAK,EAAE,CAAC;AACnB,aAAA;AACJ,SAAA;KACJ;;IAGD,YAAY,GAAA;AACR,QAAA,MAAM,OAAO,GAAG,IAAI,CAAC,oCAAoC,CAAC;;AAG1D,QAAA,IAAI,IAAI,CAAC,OAAO,CAAC,YAAY,IAAI,OAAO,IAAI,OAAO,OAAO,CAAC,KAAK,KAAK,UAAU,EAAE;AAC7E,YAAA,MAAM,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE,aAAa,CAAC;AACpD,YAAA,MAAM,OAAO,GAAG,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC;;;;;YAM/C,IAAI,CAAC,aAAa,IAAI,aAAa,KAAK,IAAI,CAAC,SAAS,EAAE,IAAI,IAAI,aAAa,KAAK,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;gBAC1H,OAAO,CAAC,KAAK,EAAE,CAAC;AACnB,aAAA;AACJ,SAAA;QAED,IAAI,IAAI,CAAC,UAAU,EAAE;AACjB,YAAA,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE,CAAC;AAC7B,SAAA;KACJ;;IAGO,6BAA6B,GAAA;AACjC,QAAA,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACjB,OAAO;AACV,SAAA;QACD,IAAI,CAAC,oCAAoC,GAAG,IAAI,CAAC,SAAS,CAAC,aAA4B,CAAC;;AAGxF,QAAA,IAAI,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,KAAK,EAAE;;;;AAItC,YAAA,OAAO,CAAC,OAAO,EAAE,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,KAAK,EAAE,CAAC,CAAC;AACxE,SAAA;KACJ;;AAxIQ,2BAAA,CAAA,IAAA,GAAA,EAAA,CAAA,kBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,2BAA2B,4EAmBZ,QAAQ,EAAA,QAAA,EAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAAA,eAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;4GAnBvB,2BAA2B,EAAA,QAAA,EAAA,sBAAA,EAAA,IAAA,EAAA,EAAA,UAAA,EAAA,EAAA,SAAA,EAAA,KAAA,EAAA,WAAA,EAAA,cAAA,EAAA,sBAAA,EAAA,4CAAA,EAAA,iBAAA,EAAA,mBAAA,EAAA,uBAAA,EAAA,iCAAA,EAAA,EAAA,cAAA,EAAA,sBAAA,EAAA,EAAA,WAAA,EAAA,CAAA,EAAA,YAAA,EAAA,eAAA,EAAA,KAAA,EAAA,IAAA,EAAA,SAAA,EAEzB,eAAe,EAAA,WAAA,EAAA,IAAA,EAAA,MAAA,EAAA,IAAA,EAAA,CAAA,EAAA,eAAA,EAAA,IAAA,EAAA,QAAA,EAAA,EAAA,EAAA,QAAA,ECpC9B,+CACA,EAAA,MAAA,EAAA,CAAA,wMAAA,CAAA,EAAA,UAAA,EAAA,CAAA,EAAA,IAAA,EAAA,EAAA,CAAA,eAAA,EAAA,QAAA,EAAA,mBAAA,EAAA,MAAA,EAAA,CAAA,iBAAA,CAAA,EAAA,OAAA,EAAA,CAAA,UAAA,CAAA,EAAA,QAAA,EAAA,CAAA,iBAAA,CAAA,EAAA,CAAA,EAAA,eAAA,EAAA,EAAA,CAAA,uBAAA,CAAA,OAAA,EAAA,CAAA,CAAA;2FDiCa,2BAA2B,EAAA,UAAA,EAAA,CAAA;kBAfvC,SAAS;AACI,YAAA,IAAA,EAAA,CAAA,EAAA,QAAA,EAAA,sBAAsB,EAIf,eAAA,EAAA,uBAAuB,CAAC,OAAO,EAC1C,IAAA,EAAA;AACF,wBAAA,KAAK,EAAE,sBAAsB;AAC7B,wBAAA,WAAW,EAAE,KAAK;AAClB,wBAAA,aAAa,EAAE,cAAc;AAC7B,wBAAA,wBAAwB,EAAE,4CAA4C;AACtE,wBAAA,mBAAmB,EAAE,mBAAmB;AACxC,wBAAA,yBAAyB,EAAE,iCAAiC;AAC/D,qBAAA,EAAA,QAAA,EAAA,+CAAA,EAAA,MAAA,EAAA,CAAA,wMAAA,CAAA,EAAA,CAAA;kHAqBoD,QAAQ,EAAA,UAAA,EAAA,CAAA;0BAAxD,QAAQ;;0BAAI,MAAM;2BAAC,QAAQ,CAAA;uEAjBc,aAAa,EAAA,CAAA;sBAA1D,SAAS;AAAC,gBAAA,IAAA,EAAA,CAAA,eAAe,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,CAAA;;;AE3BhD;AACA,IAAI,MAAM,GAAG,CAAC,CAAC;AAEf;;AAEG;MACU,YAAY,CAAA;AAwBrB,IAAA,WAAA,CACY,WAAuB,EACxB,kBAA+C,EAC/C,MAA+C,EAC9C,OAAe,EACd,EAAa,GAAA,CAAA,WAAA,EAAc,MAAM,EAAE,CAAE,CAAA,EAAA;QAJtC,IAAW,CAAA,WAAA,GAAX,WAAW,CAAY;QACxB,IAAkB,CAAA,kBAAA,GAAlB,kBAAkB,CAA6B;QAC/C,IAAM,CAAA,MAAA,GAAN,MAAM,CAAyC;QAC9C,IAAO,CAAA,OAAA,GAAP,OAAO,CAAQ;QACd,IAAE,CAAA,EAAA,GAAF,EAAE,CAAmC;;QAxBlD,IAAmB,CAAA,mBAAA,GAAwB,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,mBAAmB,CAAC;;AAG9E,QAAA,IAAA,CAAA,YAAY,GAAG,IAAI,OAAO,EAAQ,CAAC;;AAGnC,QAAA,IAAA,CAAA,YAAY,GAAG,IAAI,OAAO,EAAiB,CAAC;;AAG5C,QAAA,IAAA,CAAA,aAAa,GAAG,IAAI,OAAO,EAAiB,CAAC;;AAQtD,QAAA,IAAA,CAAA,MAAM,GAAuB,CAAA,YAAA;QASjC,IAAI,CAAC,wBAAwB,GAAG,SAAS,CAAa,QAAQ,EAAE,OAAO,CAAC,CAAC;QACzE,WAAW;AACN,aAAA,aAAa,EAAE;AACf,aAAA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;aAClC,SAAS,CAAC,MAAK;YACZ,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC1B,IAAI,CAAC,KAAK,EAAE,CAAC;AAChB,aAAA;AACL,SAAC,CAAC,CAAC;;;QAIP,UAAU,CAAC,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC,CAAC;QAEtC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,IAAG;YACtE,IAAI,KAAK,YAAY,aAAa,EAAE;gBAChC,IAAI,CAAC,KAAK,EAAE,CAAC;AAChB,aAAA;AACL,SAAC,CAAC,CAAC;;AAGH,QAAA,kBAAkB,CAAC,GAAG,GAAG,EAAE,CAAC;QAE5B,WAAW;AACN,aAAA,WAAW,EAAE;AACb,aAAA,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;aAClC,SAAS,CAAC,MAAK;YACZ,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACtC,YAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC;YAC9B,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACrC,YAAA,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC;AAC7B,YAAA,IAAI,CAAC,iBAAiB,GAAG,IAAK,CAAC;AAC/B,YAAA,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;AAC/B,SAAC,CAAC,CAAC;QAEP,WAAW;AACN,aAAA,aAAa,EAAE;aACf,IAAI,CACD,MAAM,CAAC,KAAK,IAAI,KAAK,CAAC,OAAO,KAAK,MAAM,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,EACnE,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAC/B;aACA,SAAS,CAAC,KAAK,IAAG;YACf,KAAK,CAAC,cAAc,EAAE,CAAC;YACvB,IAAI,CAAC,KAAK,EAAE,CAAC;AACjB,SAAC,CAAC,CAAC;AAEP,QAAA,IAAI,CAAC,YAAY,CAAC,IAAI,EAAE,CAAC;AACzB,QAAA,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE,CAAC;KAChC;IAED,YAAY,GAAA;AACR,QAAA,IAAI,CAAC,wBAAwB;AACxB,aAAA,IAAI,CACD,GAAG,CAAC,KAAK,IAAI,KAAK,CAAC,MAAc,CAAC,EAClC,MAAM,CAAC,CAAC,MAAY,KAAK,CAAC,IAAI,CAAC,WAAW,CAAC,cAAc,EAAE,QAAQ,CAAC,MAAM,CAAC,CAAC,EAC5E,SAAS,CAAC,IAAI,CAAC,YAAY,CAAC,CAC/B;aACA,SAAS,CAAC,MAAK;YACZ,IAAI,IAAI,CAAC,mBAAmB,EAAE;gBAC1B,IAAI,CAAC,KAAK,EAAE,CAAC;AAChB,aAAA;AACL,SAAC,CAAC,CAAC;KACV;AAED;;;AAGG;AACH,IAAA,KAAK,CAAC,aAAiB,EAAA;AACnB,QAAA,IAAI,CAAC,OAAO,GAAG,aAAa,CAAC;AAC7B,QAAA,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;AACvC,QAAA,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC;AAC9B,QAAA,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE,CAAC;QAC3B,IAAI,CAAC,MAAM,GAAA,CAAA,cAAyB;AACpC,QAAA,IAAI,CAAC,kBAAkB,CAAC,YAAY,EAAE,CAAC;AACvC,QAAA,IAAI,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,aAAa,EAAE;YAC/C,IAAI,CAAC,kBAAkB,CAAC,OAAO,CAAC,aAAa,CAAC,kBAAkB,EAAE,CAAC;AACtE,SAAA;KACJ;AAED;;AAEG;IACH,WAAW,GAAA;AACP,QAAA,OAAO,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC;KAC3C;AAED;;AAEG;IACH,WAAW,GAAA;AACP,QAAA,OAAO,IAAI,CAAC,YAAY,CAAC,YAAY,EAAE,CAAC;KAC3C;AAED;;AAEG;IACH,YAAY,GAAA;AACR,QAAA,OAAO,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,CAAC;KAC5C;AAED;;AAEG;IACH,aAAa,GAAA;AACT,QAAA,OAAO,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE,CAAC;KAC3C;AAED;;AAEG;IACH,aAAa,GAAA;AACT,QAAA,OAAO,IAAI,CAAC,WAAW,CAAC,aAAa,EAAE,CAAC;KAC3C;;AAGD,IAAA,aAAa,CAAC,OAA0B,EAAA;AACpC,QAAA,IAAI,CAAC,WAAW,CAAC,aAAa,CAAC,OAAO,CAAC,CAAC;AACxC,QAAA,OAAO,IAAI,CAAC;KACf;;AAGD,IAAA,gBAAgB,CAAC,OAA0B,EAAA;AACvC,QAAA,IAAI,CAAC,WAAW,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;AAC3C,QAAA,OAAO,IAAI,CAAC;KACf;;IAGD,QAAQ,GAAA;QACJ,OAAO,IAAI,CAAC,MAAM,CAAC;KACtB;AACJ;;ACnKD;;;AAGG;AACG,SAAU,iCAAiC,CAAC,SAAiB,EAAA;AAC/D,IAAA,OAAO,KAAK,CAAC,CAAA,mBAAA,EAAsB,SAAS,CAAA,aAAA,CAAe,CAAC,CAAC;AACjE,CAAC;AAEY,MAAA,iBAAiB,GAAmF;AAC7G,IAAA,GAAG,CAAC,KAAK,EAAA;QACL,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;KACrD;IACD,WAAW,EAAE,UAAU,KAAK,EAAA;AACxB,QAAA,OAAO,EAAE,QAAQ,EAAE,KAAK,GAAG,KAAK,GAAG,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;KACpE;IACD,SAAS,EAAE,UAAU,KAAK,EAAA;AACtB,QAAA,OAAO,EAAE,QAAQ,EAAE,KAAK,GAAG,OAAO,GAAG,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;KACpE;AACD,IAAA,MAAM,CAAC,KAAK,EAAA;QACR,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;KAClD;IACD,cAAc,EAAE,UAAU,KAAK,EAAA;AAC3B,QAAA,OAAO,EAAE,QAAQ,EAAE,KAAK,GAAG,KAAK,GAAG,OAAO,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;KACjE;IACD,YAAY,EAAE,UAAU,KAAK,EAAA;AACzB,QAAA,OAAO,EAAE,QAAQ,EAAE,KAAK,GAAG,OAAO,GAAG,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,CAAC;KACjE;AACD,IAAA,IAAI,CAAC,KAAK,EAAA;AACN,QAAA,OAAO,EAAE,QAAQ,EAAE,KAAK,GAAG,OAAO,GAAG,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;KACpE;AACD,IAAA,KAAK,CAAC,KAAK,EAAA;AACP,QAAA,OAAO,EAAE,QAAQ,EAAE,KAAK,GAAG,KAAK,GAAG,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,CAAC;KACpE;EACH;AACW,MAAA,gBAAgB,GAAiF;AAC1G,IAAA,GAAG,CAAC,KAAK,EAAA;QACL,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC;KAChD;IACD,WAAW,EAAE,UAAU,KAAK,EAAA;AACxB,QAAA,OAAO,EAAE,OAAO,EAAE,KAAK,GAAG,KAAK,GAAG,OAAO,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC;KAC/D;IACD,SAAS,EAAE,UAAU,KAAK,EAAA;AACtB,QAAA,OAAO,EAAE,OAAO,EAAE,KAAK,GAAG,OAAO,GAAG,KAAK,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC;KAC/D;AACD,IAAA,MAAM,CAAC,KAAK,EAAA;QACR,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;KACnD;IACD,cAAc,EAAE,UAAU,KAAK,EAAA;AAC3B,QAAA,OAAO,EAAE,OAAO,EAAE,KAAK,GAAG,KAAK,GAAG,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;KAClE;IACD,YAAY,EAAE,UAAU,KAAK,EAAA;AACzB,QAAA,OAAO,EAAE,OAAO,EAAE,KAAK,GAAG,OAAO,GAAG,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;KAClE;AACD,IAAA,IAAI,CAAC,KAAK,EAAA;AACN,QAAA,OAAO,EAAE,OAAO,EAAE,KAAK,GAAG,KAAK,GAAG,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;KAClE;AACD,IAAA,KAAK,CAAC,KAAK,EAAA;AACP,QAAA,OAAO,EAAE,OAAO,EAAE,KAAK,GAAG,OAAO,GAAG,KAAK,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC;KAClE;EACH;MAGW,wBAAwB,CAAA;IACjC,WAAoB,CAAA,QAAiB,EAAsB,IAA2B,EAAA;QAAlE,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAS;QAAsB,IAAI,CAAA,IAAA,GAAJ,IAAI,CAAuB;KAAI;IAE1F,sBAAsB,CAAC,OAAgD,EAAE,MAAuB,EAAA;AAC5F,QAAA,MAAM,SAAS,GAAG,IAAI,CAAC,qBAAqB,CAAC,MAAM,CAAC,SAA+B,EAAE,MAAM,CAAC,CAAC;QAC7F,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAChD,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;AAC1D,QAAA,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;QACxD,OAAO,IAAI,CAAC,QAAQ;AACf,aAAA,QAAQ,EAAE;aACV,mBAAmB,CAAC,OAAO,CAAC;aAC5B,QAAQ,CAAC,KAAK,CAAC;aACf,sBAAsB,CAAC,IAAI,CAAC;AAC5B,aAAA,kBAAkB,EAAE;AACpB,aAAA,iBAAiB,EAAE;AACnB,aAAA,aAAa,CAAC;AACX,YAAA;AACI,gBAAA,GAAG,MAAM;AACT,gBAAA,GAAG,OAAO;AACV,gBAAA,GAAG,MAAM;AACZ,aAAA;AACD,YAAA,GAAG,SAAS;AACf,SAAA,CAAC,CAAC;KACV;AAED;;AAEG;AACH,IAAA,SAAS,CAAC,SAAyC,EAAA;QAC/C,IAAI,CAAC,SAAS,IAAI,EAAE,SAAS,IAAI,gBAAgB,CAAC,EAAE;AAChD,YAAA,MAAM,iCAAiC,CAAC,SAAmB,CAAC,CAAC;AAChE,SAAA;QACD,OAAO,gBAAgB,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KAClD;;AAGD,IAAA,kBAAkB,CAAC,SAAyC,EAAA;QACxD,IAAI,CAAC,SAAS,IAAI,EAAE,SAAS,IAAI,iBAAiB,CAAC,EAAE;AACjD,YAAA,MAAM,iCAAiC,CAAC,SAAmB,CAAC,CAAC;AAChE,SAAA;QACD,OAAO,iBAAiB,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;KACnD;;IAGD,SAAS,CAAC,SAAyC,EAAE,MAAuB,EAAA;QACxE,IAAI,CAAC,SAAS,IAAI,EAAE,SAAS,IAAI,iBAAiB,CAAC,EAAE;AACjD,YAAA,MAAM,iCAAiC,CAAC,SAAmB,CAAC,CAAC;AAChE,SAAA;AACD,QAAA,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM,IAAI,WAAW,CAAC;QAC5C,MAAM,CAAC,gBAAgB,CAAC,GAAG,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AAChD,QAAA,QAAQ,gBAAgB;YACpB,KAAK,KAAK,EAAE;gBACR,OAAO;AACH,oBAAA,OAAO,EAAE,MAAM,GAAG,CAAC,CAAC;iBACvB,CAAC;AACL,aAAA;YACD,KAAK,QAAQ,EAAE;gBACX,OAAO;AACH,oBAAA,OAAO,EAAE,MAAM;iBAClB,CAAC;AACL,aAAA;YACD,KAAK,MAAM,EAAE;gBACT,OAAO;AACH,oBAAA,OAAO,EAAE,MAAM,GAAG,CAAC,CAAC;iBACvB,CAAC;AACL,aAAA;YACD,KAAK,OAAO,EAAE;gBACV,OAAO;AACH,oBAAA,OAAO,EAAE,MAAM;iBAClB,CAAC;AACL,aAAA;AACD,YAAA,SAAS;AACL,gBAAA,MAAM,iCAAiC,CAAC,SAAS,CAAC,CAAC;AACtD,aAAA;AACJ,SAAA;KACJ;AAED;;;;;AAKG;IACK,qBAAqB,CAAC,SAA6B,EAAE,MAAuB,EAAA;QAChF,IAAI,CAAC,SAAS,EAAE;AACZ,YAAA,OAAO,EAAE,CAAC;AACb,SAAA;;QAGD,MAAM,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC,SAAS,EAAE,MAAM,CAAC,CAAC;;QAEhE,MAAM,kBAAkB,GAAG,IAAI,CAAC,iBAAiB,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,KAAK,SAAS,CAAC,CAAC;QAEtG,MAAM,iBAAiB,GAA6B,EAAE,CAAC;AAEvD,QAAA,kBAAkB,CAAC,OAAO,CAAC,iBAAiB,IAAG;YAC3C,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,CAAC,CAAC;YACjD,MAAM,OAAO,GAAG,IAAI,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;YAC3D,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,iBAAiB,EAAE,MAAM,CAAC,CAAC;YACzD,iBAAiB,CAAC,IAAI,CAAC;AACnB,gBAAA,GAAG,MAAM;AACT,gBAAA,GAAG,OAAO;AACV,gBAAA,GAAG,MAAM;AACZ,aAAA,CAAC,CAAC;AACP,SAAC,CAAC,CAAC;AAEH,QAAA,OAAO,iBAAiB,CAAC;KAC5B;;IAGO,iBAAiB,CAAC,SAA6B,EAAE,MAAuB,EAAA;AAC5E,QAAA,IAAI,KAA2B,CAAC;QAChC,QAAQ,MAAM,CAAC,mBAAmB;AAC9B,YAAA,KAAK,UAAU;gBACX,KAAK,GAAG,mBAAmB,CAAC;gBAC5B,MAAM;AACV,YAAA,KAAK,YAAY;gBACb,KAAK,GAAG,qBAAqB,CAAC;gBAC9B,MAAM;AACV,YAAA,KAAK,WAAW;gBACZ,KAAK,GAAG,oBAAoB,CAAC;gBAC7B,MAAM;AACV,YAAA;gBACI,MAAM,iCAAiC,CAAC,MAAM,CAAC,mBAAmB,IAAI,EAAE,CAAC,CAAC;AACjF,SAAA;;QAED,MAAM,CAAC,gBAAgB,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC;QAC3D,MAAM,cAAc,GAAG,KAAK,CAAC,OAAO,CAAC,gBAAsC,CAAC,CAAC;AAC7E,QAAA,OAAO,CAAC,GAAG,KAAK,CAAC,KAAK,CAAC,cAAc,CAAC,EAAE,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,CAAC;KAC9E;;;AAIO,IAAA,eAAe,CAAC,SAA6B,EAAA;AACjD,QAAA,OAAO,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;KAC/B;AAED,IAAA,IAAI,KAAK,GAAA;AACL,QAAA,OAAO,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK,KAAK,CAAC;KACrC;;AAGO,IAAA,mBAAmB,CAAC,QAAgB,EAAA;AACxC,QAAA,MAAM,aAAa,GAAqE;AACpF,YAAA,GAAG,EAAE,QAAQ;AACb,YAAA,MAAM,EAAE,KAAK;AACb,YAAA,KAAK,EAAE,KAAK;AACZ,YAAA,GAAG,EAAE,OAAO;AACZ,YAAA,MAAM,EAAE,QAAQ;SACnB,CAAC;AACF,QAAA,OAAO,aAAa,CAAC,QAAQ,CAAC,CAAC;KAClC;;IAGO,iBAAiB,CAAC,SAA+B,EAAE,MAAuB,EAAA;AAC9E,QAAA,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE;AACnB,YAAA,MAAM,iCAAiC,CAAC,EAAE,CAAC,CAAC;AAC/C,SAAA;AACD,QAAA,MAAM,CAAC,gBAAgB,EAAE,QAAQ,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;QAC5E,OAAO,SAAS,CAAC,MAAM,CAAC,CAAC,QAA8B,EAAE,SAAS,KAAI;AAClE,YAAA,IAAI,SAAS,KAAK,KAAK,IAAI,SAAS,KAAK,QAAQ,EAAE;AAC/C,gBAAA,IAAI,QAAQ,EAAE;;oBAEV,QAAQ,CAAC,IAAI,CACT,CAAA,EAAG,SAAS,CAAI,CAAA,EAAA,QAAQ,CAAwB,CAAA,EAChD,CAAG,EAAA,SAAS,IAAI,IAAI,CAAC,mBAAmB,CAAC,QAAQ,CAAC,CAAwB,CAAA,EAC1E,SAAS,CACZ,CAAC;AACL,iBAAA;AAAM,qBAAA;AACH,oBAAA,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,CAAA,EAAG,SAAS,CAAA,MAAA,CAA8B,EAAE,CAAA,EAAG,SAAS,CAAA,IAAA,CAA4B,CAAC,CAAC;AAClH,iBAAA;AACJ,aAAA;AAAM,iBAAA;AACH,gBAAA,QAAQ,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;AAC5B,aAAA;AACD,YAAA,OAAO,QAAQ,CAAC;SACnB,EAAE,EAAE,CAAC,CAAC;KACV;;qHAhLQ,wBAAwB,EAAA,IAAA,EAAA,CAAA,EAAA,KAAA,EAAAC,IAAA,CAAA,OAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,cAAA,EAAA,QAAA,EAAA,IAAA,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA;yHAAxB,wBAAwB,EAAA,CAAA,CAAA;2FAAxB,wBAAwB,EAAA,UAAA,EAAA,CAAA;kBADpC,UAAU;;0BAEiC,QAAQ;;;ACjEpD;MACa,0BAA0B,GAAG,IAAI,cAAc,CAAuB,4BAA4B,EAAE;AAEjH;AACM,SAAU,2CAA2C,CAAC,OAAgB,EAAA;IACxE,OAAO,MAAM,OAAO,CAAC,gBAAgB,CAAC,UAAU,EAAE,CAAC;AACvD,CAAC;AAED;AACa,MAAA,mCAAmC,GAAG;AAC/C,IAAA,OAAO,EAAE,0BAA0B;AACnC,IAAA,UAAU,EAAE,2CAA2C;IACvD,IAAI,EAAE,CAAC,OAAO,CAAC;EACjB;MASW,gBAAgB,CAAA;AAQzB,IAAA,WAAA,CACY,QAAiB,EACjB,SAAmB,EACnB,OAAe,EACf,gBAA0C,EAClB,qBAA8C,EAC1D,IAA2B,EACH,6BAAmD,EAAA;QANvF,IAAQ,CAAA,QAAA,GAAR,QAAQ,CAAS;QACjB,IAAS,CAAA,SAAA,GAAT,SAAS,CAAU;QACnB,IAAO,CAAA,OAAA,GAAP,OAAO,CAAQ;QACf,IAAgB,CAAA,gBAAA,GAAhB,gBAAgB,CAA0B;QAClB,IAAqB,CAAA,qBAAA,GAArB,qBAAqB,CAAyB;QAC1D,IAAI,CAAA,IAAA,GAAJ,IAAI,CAAuB;QACH,IAA6B,CAAA,6BAAA,GAA7B,6BAA6B,CAAsB;AAdlF,QAAA,IAAA,CAAA,0BAA0B,GAAG,IAAI,OAAO,EAAQ,CAAC;AACjD,QAAA,IAAA,CAAA,uBAAuB,GAAG,IAAI,OAAO,EAAqB,CAAC;QACpE,IAAwB,CAAA,wBAAA,GAAwB,EAAE,CAAC;;AAGnD,QAAA,IAAA,CAAA,sBAAsB,GAAG,IAAI,CAAC,6BAA6B,CAAC;KAUhE;;AAGJ,IAAA,IAAI,YAAY,GAAA;AACZ,QAAA,OAAO,IAAI,CAAC,qBAAqB,GAAG,IAAI,CAAC,qBAAqB,CAAC,YAAY,GAAG,IAAI,CAAC,wBAAwB,CAAC;KAC/G;;AAGD,IAAA,IAAI,GAAG,GAAA;AACH,QAAA,OAAO,IAAI,CAAC,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;KACjE;AAED;;;;;;AAMG;AACH,IAAA,IAAI,CACA,sBAAyD,EACzD,MAA+C,EAC/C,MAA2B,EAAA;QAE3B,MAAM,GAAG,oBAAoB,CAAC,MAAM,EAAE,IAAI,eAAe,EAAE,CAAC,CAAC;AAE7D,QAAA,IAAI,MAAM,CAAC,EAAE,IAAI,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,EAAE,CAAC,EAAE;YAC7C,MAAM,KAAK,CAAC,CAAoB,iBAAA,EAAA,MAAM,CAAC,EAAE,CAAA,gDAAA,CAAkD,CAAC,CAAC;AAChG,SAAA;QAED,MAAM,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAC1D,MAAM,gBAAgB,GAAG,IAAI,CAAC,uBAAuB,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;AAC7E,QAAA,MAAM,UAAU,GAAG,IAAI,CAAC,qBAAqB,CAAO,sBAAsB,EAAE,gBAAgB,EAAE,aAAa,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;AAE7H,QAAA,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACnC,QAAA,UAAU,CAAC,WAAW,EAAE,CAAC,SAAS,CAAC,MAAM,IAAI,CAAC,kBAAkB,CAAC,UAAU,CAAC,CAAC,CAAC;QAE9E,IAAI,MAAM,CAAC,aAAa,EAAE;AACtB,YAAA,MAAM,CAAC,aAAa,CAAC,gBAAgB,EAAE,CAAC;AAC3C,SAAA;AACD,QAAA,OAAO,UAAU,CAAC;KACrB;AAED;;;AAGG;AACH,IAAA,cAAc,CAAC,EAAU,EAAA;AACrB,QAAA,OAAO,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,IAAI,OAAO,CAAC,EAAE,KAAK,EAAE,CAAC,CAAC;KAC/D;IAED,WAAW,GAAA;;;AAGP,QAAA,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;AACnD,QAAA,IAAI,CAAC,0BAA0B,CAAC,QAAQ,EAAE,CAAC;AAC3C,QAAA,IAAI,CAAC,uBAAuB,CAAC,QAAQ,EAAE,CAAC;KAC3C;AAED;;;;AAIG;IACK,cAAc,CAAC,MAAuB,EAAE,MAA+C,EAAA;QAC3F,MAAM,aAAa,GAAG,IAAI,CAAC,iBAAiB,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAC7D,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;KAC9C;AAED;;;;;AAKG;IACK,iBAAiB,CAAC,aAA8B,EAAE,MAA+C,EAAA;AACrG,QAAA,MAAM,KAAK,GAAG,IAAI,aAAa,CAAC;AAC5B,YAAA,gBAAgB,EAAE,aAAa,CAAC,gBAAgB,IAAI,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,CAAC,MAAM,EAAE,aAAa,CAAC;YACvH,cAAc,EAAE,aAAa,CAAC,cAAc,IAAI,IAAI,CAAC,sBAAsB,EAAE;YAC7E,UAAU,EAAE,aAAa,CAAC,UAAU;YACpC,WAAW,EAAE,aAAa,CAAC,WAAW;YACtC,KAAK,EAAE,aAAa,CAAC,KAAK;YAC1B,MAAM,EAAE,aAAa,CAAC,MAAM;YAC5B,QAAQ,EAAE,aAAa,CAAC,QAAQ;YAChC,SAAS,EAAE,aAAa,CAAC,SAAS;YAClC,QAAQ,EAAE,aAAa,CAAC,QAAQ;YAChC,SAAS,EAAE,aAAa,CAAC,SAAS;YAClC,mBAAmB,EAAE,aAAa,CAAC,iBAAiB;YACpD,SAAS,EAAE,IAAI,CAAC,GAAG;AACtB,SAAA,CAAC,CAAC;QAEH,IAAI,aAAa,CAAC,aAAa,EAAE;AAC7B,YAAA,KAAK,CAAC,aAAa,GAAG,aAAa,CAAC,aAAa,CAAC;AACrD,SAAA;AAED,QAAA,OAAO,KAAK,CAAC;KAChB;AAED,IAAA,IAAI,KAAK,GAAA;AACL,QAAA,OAAO,IAAI,CAAC,IAAI,EAAE,KAAK,KAAK,KAAK,CAAC;KACrC;AAED;;;;;AAKG;IACK,uBAAuB,CAAC,UAAsB,EAAE,MAAuB,EAAA;AAC3E,QAAA,MAAM,YAAY,GAAG,MAAM,EAAE,gBAAgB,EAAE,QAAQ,CAAC;AACxD,QAAA,MAAM,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC;AAC7B,YAAA,MAAM,EAAE,YAAY,IAAI,IAAI,CAAC,SAAS;YACtC,SAAS,EAAE,CAAC,EAAE,OAAO,EAAE,eAAe,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC;AAC9D,SAAA,CAAC,CAAC;AAEH,QAAA,MAAM,eAAe,GAAG,IAAI,eAAe,CAAC,2BAA2B,EAAE,MAAM,CAAC,gBAAgB,EAAE,QAAQ,EAAE,MAAM,CAAC,wBAAwB,CAAC,CAAC;QAC7I,MAAM,YAAY,GAAG,UAAU,CAAC,MAAM,CAA8B,eAAe,CAAC,CAAC;QAErF,OAAO,YAAY,CAAC,QAAQ,CAAC;KAChC;AAED;;;;;;;;AAQG;IACK,qBAAqB,CACzB,sBAAyD,EACzD,gBAA6C,EAC7C,aAAyB,EACzB,MAAuB,EACvB,MAA+C,EAAA;;;AAI/C,QAAA,MAAM,UAAU,GAAG,IAAI,YAAY,CAAO,aAAa,EAAE,gBAAgB,EAAE,MAAM,EAAE,IAAI,CAAC,OAAO,EAAE,MAAM,CAAC,EAAE,CAAC,CAAC;QAE5G,IAAI,sBAAsB,YAAY,WAAW,EAAE;AAC/C,YAAA,gBAAgB,CAAC,oBAAoB,CAAC,IAAI,cAAc,CAAI,sBAAsB,EAAE,IAAK,EAAE,EAAE,SAAS,EAAE,UAAU,EAAS,CAAC,CAAC,CAAC;AACjI,SAAA;AAAM,aAAA;AACH,YAAA,MAAM,QAAQ,GAAG,IAAI,CAAC,eAAe,CAAI,MAAM,EAAE,UAAU,EAAE,gBAAgB,CAAC,CAAC;AAC/E,YAAA,MAAM,UAAU,GAAG,gBAAgB,CAAC,qBAAqB,CAAI,IAAI,eAAe,CAAC,sBAAsB,EAAE,MAAM,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC,CAAC;AAC7I,YAAA,UAAU,CAAC,iBAAiB,GAAG,UAAU,CAAC,QAAQ,CAAC;AACtD,SAAA;AAED,QAAA,OAAO,UAAU,CAAC;KACrB;AAED;;;;;;;AAOG;AACK,IAAA,eAAe,CAAI,MAAuB,EAAE,UAA2B,EAAE,gBAA6C,EAAA;AAC1H,QAAA,MAAM,YAAY,GAAG,MAAM,EAAE,gBAAgB,EAAE,QAAQ,CAAC;;;;;AAMxD,QAAA,MAAM,SAAS,GAAqB;AAChC,YAAA,EAAE,OAAO,EAAE,2BAA2B,EAAE,QAAQ,EAAE,gBAAgB,EAAE;AACpE,YAAA,EAAE,OAAO,EAAE,YAAY,EAAE,QAAQ,EAAE,UAAU,EAAE;SAClD,CAAC;AAEF,QAAA,OAAO,QAAQ,CAAC,MAAM,CAAC,EAAE,MAAM,EAAE,YAAY,IAAI,IAAI,CAAC,SAAS,EAAE,SAAS,EAAE,CAAC,CAAC;KACjF;AAED;;;AAGG;AACK,IAAA,kBAAkB,CAAC,UAA6B,EAAA;QACpD,MAAM,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;AAEpD,QAAA,IAAI,KAAK,GAAG,CAAC,CAAC,EAAE;YACZ,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;AACtC,SAAA;KACJ;;AAGO,IAAA,cAAc,CAAC,QAA6B,EAAA;AAChD,QAAA,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,CAAC;QAExB,OAAO,CAAC,EAAE,EAAE;;;;;AAKR,YAAA,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;AACvB,SAAA;KACJ;;6GAtNQ,gBAAgB,EAAA,IAAA,EAAA,CAAA,EAAA,KAAA,EAAAA,IAAA,CAAA,OAAA,EAAA,EAAA,EAAA,KAAA,EAAA,EAAA,CAAA,QAAA,EAAA,EAAA,EAAA,KAAA,EAAAC,IAAA,CAAA,MAAA,EAAA,EAAA,EAAA,KAAA,EAAAC,wBAAA,EAAA,EAAA,EAAA,KAAA,EAakC,gBAAgB,EAAA,QAAA,EAAA,IAAA,EAAA,QAAA,EAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAAC,EAAA,CAAA,cAAA,EAAA,QAAA,EAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAE/D,0BAA0B,EAAA,CAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,UAAA,EAAA,CAAA,CAAA;iHAf7B,gBAAgB,EAAA,CAAA,CAAA;2FAAhB,gBAAgB,EAAA,UAAA,EAAA,CAAA;kBAD5B,UAAU;oKAcoD,gBAAgB,EAAA,UAAA,EAAA,CAAA;0BAAtE,QAAQ;;0BAAI,QAAQ;;0BACpB,QAAQ;;0BACR,MAAM;2BAAC,0BAA0B,CAAA;;AA0M1C;;;;;AAKG;AACH,SAAS,oBAAoB,CAAC,MAAwB,EAAE,cAAgC,EAAA;AACpF,IAAA,OAAO,EAAE,GAAG,cAAc,EAAE,GAAG,MAAM,EAAE,CAAC;AAC5C;;MCnPa,eAAe,CAAA;;4GAAf,eAAe,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,QAAA,EAAA,CAAA,CAAA;AAAf,eAAA,CAAA,IAAA,GAAA,EAAA,CAAA,mBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,eAAe,EAHT,YAAA,EAAA,CAAA,2BAA2B,CAFhC,EAAA,OAAA,EAAA,CAAA,aAAa,EAAE,UAAU,EAAE,YAAY,EAAE,YAAY,CACrD,EAAA,OAAA,EAAA,CAAA,2BAA2B,EAAE,aAAa,CAAA,EAAA,CAAA,CAAA;AAI3C,eAAA,CAAA,IAAA,GAAA,EAAA,CAAA,mBAAA,CAAA,EAAA,UAAA,EAAA,QAAA,EAAA,OAAA,EAAA,QAAA,EAAA,QAAA,EAAA,EAAA,EAAA,IAAA,EAAA,eAAe,aAFb,CAAC,gBAAgB,EAAE,wBAAwB,EAAE,mCAAmC,CAAC,EAAA,OAAA,EAAA,CAHnF,CAAC,aAAa,EAAE,UAAU,EAAE,YAAY,EAAE,YAAY,CAAC,EACzB,aAAa,CAAA,EAAA,CAAA,CAAA;2FAI3C,eAAe,EAAA,UAAA,EAAA,CAAA;kBAN3B,QAAQ;AAAC,YAAA,IAAA,EAAA,CAAA;oBACN,OAAO,EAAE,CAAC,aAAa,EAAE,UAAU,EAAE,YAAY,EAAE,YAAY,CAAC;AAChE,oBAAA,OAAO,EAAE,CAAC,2BAA2B,EAAE,aAAa,CAAC;oBACrD,YAAY,EAAE,CAAC,2BAA2B,CAAC;AAC3C,oBAAA,SAAS,EAAE,CAAC,gBAAgB,EAAE,wBAAwB,EAAE,mCAAmC,CAAC;AAC/F,iBAAA,CAAA;;;ACbD;;;AAGG;MAEmB,eAAe,CAAA;;4GAAf,eAAe,EAAA,IAAA,EAAA,EAAA,EAAA,MAAA,EAAA,EAAA,CAAA,eAAA,CAAA,SAAA,EAAA,CAAA,CAAA;gGAAf,eAAe,EAAA,QAAA,EAAA,EAAA,EAAA,CAAA,CAAA;2FAAf,eAAe,EAAA,UAAA,EAAA,CAAA;kBADpC,SAAS;;;ACNV;;AAEG;;;;"}