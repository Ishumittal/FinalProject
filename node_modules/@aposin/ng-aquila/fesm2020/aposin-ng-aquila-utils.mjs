import * as i0 from '@angular/core';
import { Injectable } from '@angular/core';
import { Subject, fromEvent, asyncScheduler } from 'rxjs';
import { map, takeUntil, startWith, throttleTime } from 'rxjs/operators';

function isString(value) {
    return typeof value === 'string';
}
function pad(str, length = 2, padCharacter = '0') {
    if (!isString(str) || str.length >= length) {
        return str;
    }
    while (str.length < length) {
        str = padCharacter + str;
    }
    return str;
}
// DATE -> YYYY-MM-DD
function formatDate(date) {
    const dateOfBirth = [String(date.getFullYear()), pad(String(date.getMonth() + 1)), pad(String(date.getDate()))].join('-');
    return dateOfBirth;
}
function formatDateHuman(date) {
    const dateOfBirth = [pad(String(date.getDate())), pad(String(date.getMonth() + 1)), String(date.getFullYear())].join('-');
    return dateOfBirth;
}
/*
  Purpose of this function is to allow a list of short keywords
  expand to longer bem class names with will then be applied to the classname value.

  This function will map a list of keys to values in a MAPPING list.
  Whatever value is found will replace the keyword.
  Every keyword not found will just transfered wiithmout modifying.
*/
function mapClassNames(value, DEFAULTS = [], MAPPING = {}) {
    let sanitizedList = [...DEFAULTS];
    if (typeof value === 'string') {
        const mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = [...sanitizedList, ...mappedClasses];
    }
    return sanitizedList.join(' ').trim();
}
function getClassNameList(value, MAPPING = {}) {
    let mappedClasses = [];
    if (typeof value === 'string') {
        const classNames = value.split(' ');
        const keys = Object.keys(MAPPING);
        mappedClasses = classNames.map(className => {
            if (keys.includes(className)) {
                return MAPPING[className];
            }
            return className;
        });
    }
    return mappedClasses;
}
function appendClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach(item => {
            renderer.addClass(element.nativeElement, item);
        });
    }
}
function removeClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach(item => {
            renderer.removeClass(element.nativeElement, item);
        });
    }
}
// YYYY-MM-DD -> DATE
function parseDate(dateString) {
    return new Date(dateString);
}
// Manually compose a font shorthand defintion as it's not
// guaranteed to be given by the computed style object.
function getFontShorthand(style) {
    const { font, fontStyle, fontVariant, fontWeight, fontSize, lineHeight, fontFamily } = style;
    if (font.length > 0) {
        return font;
    }
    return `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;
}
function numberOfDecimals(number) {
    const parsed = Number(number);
    if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
    }
    const match = parsed.toString().match(/(?:\.(\d+))?(?:[Ee]([+-]?\d+))?$/);
    if (!match || !match[1]) {
        return 0;
    }
    return match[1].length;
}
function clamp(value, min = 0, max = 1) {
    return Math.max(min, Math.min(max, value));
}
function randomString() {
    return Math.random().toString(36);
}
/** Provider that defines when form controls have an error. */
class ErrorStateMatcher {
    isErrorState(control, form) {
        return !!(control?.invalid && (control.touched || form?.submitted));
    }
}
ErrorStateMatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: ErrorStateMatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ErrorStateMatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: ErrorStateMatcher, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: ErrorStateMatcher, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });

/** Available breakpoints to subscribe to. */
var NxBreakpoints;
(function (NxBreakpoints) {
    /** Min size for BREAKPOINT_MOBILE */
    NxBreakpoints[NxBreakpoints["BREAKPOINT_XSMALL"] = 0] = "BREAKPOINT_XSMALL";
    NxBreakpoints[NxBreakpoints["BREAKPOINT_SMALL"] = 320] = "BREAKPOINT_SMALL";
    /** Min size for BREAKPOINT_TABLET */
    NxBreakpoints[NxBreakpoints["BREAKPOINT_MEDIUM"] = 704] = "BREAKPOINT_MEDIUM";
    /** Min size for BREAKPOINT_DESKTOP */
    NxBreakpoints[NxBreakpoints["BREAKPOINT_LARGE"] = 992] = "BREAKPOINT_LARGE";
    NxBreakpoints[NxBreakpoints["BREAKPOINT_XLARGE"] = 1280] = "BREAKPOINT_XLARGE";
    NxBreakpoints[NxBreakpoints["BREAKPOINT_2XLARGE"] = 1472] = "BREAKPOINT_2XLARGE";
    NxBreakpoints[NxBreakpoints["BREAKPOINT_3XLARGE"] = 1760] = "BREAKPOINT_3XLARGE";
})(NxBreakpoints || (NxBreakpoints = {}));
const DEFAULT_THROTTLE_TIME = 200;
/** Service subscribing to window resize events and providing breakpoint matching functions. */
class NxViewportService {
    constructor() {
        this._destroyed = new Subject();
        this.initialViewportWidth = 0;
        this.viewportChange$ = fromEvent(window, 'resize').pipe(map(() => window.innerWidth), takeUntil(this._destroyed));
    }
    /** Returns whether the current viewport width is greater than or equal (>=) to minSize. */
    min(minSize, throttleTimeMs = DEFAULT_THROTTLE_TIME) {
        return this.viewportChange$.pipe(startWith(window.innerWidth), throttleTime(throttleTimeMs, asyncScheduler, { trailing: true }), map(windowInnerWidth => windowInnerWidth >= minSize));
    }
    /** Returns whether the current viewport width is lower (<) than maxSize. */
    max(maxSize, throttleTimeMs = DEFAULT_THROTTLE_TIME) {
        return this.viewportChange$.pipe(startWith(window.innerWidth), throttleTime(throttleTimeMs, asyncScheduler, { trailing: true }), map(windowInnerWidth => windowInnerWidth < maxSize));
    }
    /** Returns whether the current viewport width is greater than or equal (>=) to minSize and lower (<) than maxSize. */
    between(minSize, maxSize, throttleTimeMs = DEFAULT_THROTTLE_TIME) {
        return this.viewportChange$.pipe(startWith(window.innerWidth), throttleTime(throttleTimeMs, asyncScheduler, { trailing: true }), map(windowInnerWidth => windowInnerWidth >= minSize && windowInnerWidth < maxSize));
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
}
NxViewportService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxViewportService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NxViewportService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxViewportService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxViewportService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return []; } });

/**
 * Generated bundle index. Do not edit.
 */

export { ErrorStateMatcher, NxBreakpoints, NxViewportService, appendClasses, clamp, formatDate, formatDateHuman, getClassNameList, getFontShorthand, isString, mapClassNames, numberOfDecimals, pad, parseDate, randomString, removeClasses };
//# sourceMappingURL=aposin-ng-aquila-utils.mjs.map
