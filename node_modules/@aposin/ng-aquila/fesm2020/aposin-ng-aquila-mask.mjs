import * as i0 from '@angular/core';
import { forwardRef, Directive, Input, Inject, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import * as IBAN from 'iban';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { BACKSPACE, DELETE } from '@angular/cdk/keycodes';
import { NX_INPUT_VALUE_ACCESSOR } from '@aposin/ng-aquila/input';
import { CommonModule } from '@angular/common';
import { NxFormfieldModule } from '@aposin/ng-aquila/formfield';

const NX_MASK_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NxMaskDirective),
    multi: true,
};
const NX_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NxMaskDirective),
    multi: true,
};
class NxMaskDirective {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
        this._dropSpecialCharacters = false;
        this._validateMask = true;
        this._deactivateMask = false;
        this._mask = '';
        /**
         * Emits the unmasked value before the value changes.
         */
        this.cvaModelChange = new Subject();
        this._onChangeCallback = (_) => { };
        this._onTouchedCallback = () => { };
        this._validatorOnChange = () => { };
        this._afterInputHook = (event) => { };
        this._beforePasteHook = (event) => { };
    }
    _callOnChangeCallback() {
        if (this.dropSpecialCharacters) {
            this._onChangeCallback(this.getUnmaskedValue());
        }
        else {
            this._onChangeCallback(this._elementRef.nativeElement.value);
        }
    }
    /**
     * Registers a function to be executed after the onInput handler.
     * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
     *
     * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
     * to perform similar changes for pasting.
     */
    registerAfterInputHook(afterInput) {
        this._afterInputHook = afterInput;
    }
    /**
     * Registers a function to be executed before the onPaste handler.
     * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
     */
    registerBeforePasteHook(beforePaste) {
        this._beforePasteHook = beforePaste;
    }
    /** Whether the mask validation should be deactivated. */
    set deactivateMask(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._deactivateMask) {
            this._deactivateMask = newValue;
            if (this._deactivateMask) {
                this.updateValue(this.getUnmaskedValue());
            }
            else {
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            }
            this._callOnChangeCallback();
        }
    }
    get deactivateMask() {
        return this._deactivateMask;
    }
    /** Sets the mask. */
    set mask(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._callOnChangeCallback();
            this._validatorOnChange();
        }
    }
    get mask() {
        return this._mask;
    }
    /** Sets the case sensitivity of the mask. */
    set convertTo(value) {
        this._convertTo = value; // TODO properly coerce input value
        this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        this._callOnChangeCallback();
    }
    get convertTo() {
        return this._convertTo;
    }
    /**
     * Sets the keys that are recognized as separators.
     * Default separators: / ( ) . : - + , and space.
     */
    set separators(values) {
        this._separators = values;
        this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        this._validatorOnChange();
        this._callOnChangeCallback();
    }
    get separators() {
        return this._separators;
    }
    /** Whether the separators should be dropped in the control value accessor. */
    set dropSpecialCharacters(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._dropSpecialCharacters) {
            this._dropSpecialCharacters = newValue;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._callOnChangeCallback();
        }
    }
    get dropSpecialCharacters() {
        return this._dropSpecialCharacters;
    }
    /** Whether the mask validation should be applied on the input. Default: true. */
    set validateMask(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._validateMask) {
            this._validateMask = newValue;
            this._validatorOnChange();
        }
    }
    get validateMask() {
        return this._validateMask;
    }
    /** @docs-private */
    get elementRefValue() {
        return this._elementRef.nativeElement.value;
    }
    /** Returns the unmasked value. */
    getUnmaskedValue() {
        const unmaskedValue = this.separators.reduce((unmasked, separator) => unmasked.split(separator).join(''), this._elementRef.nativeElement.value);
        return unmaskedValue;
    }
    /**
     * Sets the mask (for programmatical use).
     *
     * No `_onChangeCallback()` will be called!
     */
    setMask(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
        }
    }
    /**
     * this._cursor can be set to a new value in this function;
     * in _onInputChange() it is then used to set the cursor position.
     */
    _onKeydown(event) {
        const keyCode = event.keyCode;
        const input = event.target;
        const currentValue = this._elementRef.nativeElement.value;
        if (keyCode === BACKSPACE || keyCode === DELETE) {
            // if backspace pressed, cursor has to move one character to start
            const backspaceShift = keyCode === BACKSPACE ? 1 : 0;
            const lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
            const selectionAtLastCharacter = input.selectionStart === currentValue.length - 1 + backspaceShift;
            if (input.selectionStart !== input.selectionEnd) {
                let newPosition = input.selectionStart;
                // jump behind separators, but do not shift after the next character (=> don't use _calculateCursorShift())
                while (this.isSeparator(this.mask[newPosition])) {
                    newPosition++;
                }
                this._cursor = { position: newPosition };
            }
            else if (selectionAtLastCharacter) {
                // if last character is deleted: only delete last character, do not trigger input event again
                // (here the separator would be added again)
                this.updateValue(currentValue.substring(0, currentValue.length - 1));
                this._callOnChangeCallback();
                event.preventDefault();
            }
            else if (this.isSeparator(lastCharacter)) {
                // do not delete a separator, only set cursor position
                input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                event.preventDefault();
            }
            else {
                // for any other character: decrease cursor position by one (backspaceShift).
                // the input is modified and will be validated in _onInputChange().
                this._cursor = { position: input.selectionStart - backspaceShift };
            }
        }
        else {
            this._cursor = { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd };
        }
    }
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     */
    _calculateCursorShift(position) {
        let shift = 0;
        // tracks if the entered letter was already placed in the current mask
        // and therefor was considered in the cursor calculation.
        let characterWasEntered = false;
        if (!this.isSeparator(this.mask[position + shift])) {
            shift++;
            characterWasEntered = true;
        }
        while (this.isSeparator(this.mask[position + shift])) {
            shift++;
        }
        if (!characterWasEntered) {
            shift++;
        }
        return shift;
    }
    _isStringAllowed(value, maskedValue) {
        if ((maskedValue === '0' && /^\d$/.test(value)) ||
            (maskedValue === 'A' && /^[\dA-Za-z]$/.test(value)) ||
            (maskedValue === 'S' && /^[A-Za-z]$/.test(value))) {
            return true;
        }
        return false;
    }
    /**
     * Handles the onInput event.
     * `_beforeInputHook()` is called before the actual execution.
     *
     */
    _onInputChange(event) {
        // _inputValue is updated in updateValue(), so I need to pick it up here to compare it to a new value
        const oldVal = this._inputValue;
        const input = event.target;
        let newVal = this.getMaskedString(input.value);
        if (this._deactivateMask) {
            newVal = input.value;
            this.updateValue(newVal);
            this._callOnChangeCallback();
            return;
        }
        // if _pastedData was set in _onPaste(), use this value
        if (this._pastedData) {
            this.updateValue(this._pastedData);
            input.setSelectionRange(this._cursor.position, this._cursor.position);
            this._pastedData = null;
            this._cursor = null;
            this._callOnChangeCallback();
            return;
        }
        // do nothing if mask is already filled up
        if (oldVal.length === this._mask.length &&
            newVal.length === this._mask.length &&
            oldVal !== newVal &&
            this._cursor &&
            this._cursor.selectionStart !== undefined &&
            this._cursor.selectionStart === this._cursor.selectionEnd) {
            this._elementRef.nativeElement.value = this.getMaskedString(oldVal);
            input.setSelectionRange(this._cursor.selectionStart, this._cursor.selectionEnd);
            this._cursor = null;
            return;
        }
        this.updateValue(newVal);
        // set new cursor position
        if (this._cursor?.position !== undefined) {
            input.setSelectionRange(this._cursor.position, this._cursor.position);
            this._cursor = null;
        }
        else if (this._cursor?.selectionStart !== undefined) {
            // only one character can be entered (except pasting, this is calculated in _onPaste())
            if (oldVal === input.value) {
                // we always have to set the cursor position here even if nothing changed
                // because otherwise the cursor would jump to the end of the input.
                // if the cursor is placed in front of a separator and the user types a non-allowed character,
                // the cursor is supposed to jump over the separator.
                let currentPosition = this._cursor.selectionStart;
                while (this.isSeparator(this.mask[currentPosition])) {
                    currentPosition++;
                }
                input.setSelectionRange(currentPosition, currentPosition);
                this._cursor = null;
            }
            else {
                const newPosition = this._cursor.selectionStart + this._calculateCursorShift(this._cursor.selectionStart);
                input.setSelectionRange(newPosition, newPosition);
                this._cursor = null;
            }
        }
        this._afterInputHook(event);
        this._callOnChangeCallback();
    }
    /**
     * this._cursor and this._pastedData can be set to a new value in this function;
     * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
     * _pastedData carries the valid part of the pasted value to _inInputChange();
     *
     *`_beforePasteHook()` is called before the actual execution.
     */
    _onPaste(event) {
        const input = event.target;
        const pastedData = (event.clipboardData || window.clipboardData).getData('text');
        // saving these three values as if something is changed in the _beforePasteHook()
        // which causes the input value to be updated, this values will get lost.
        const selectionStart = input.selectionStart;
        const selectionEnd = input.selectionEnd;
        const oldValue = input.value;
        this._beforePasteHook(event);
        const maskedString = this.getMaskedString(pastedData, selectionStart);
        // if mask is already filled up (and no characters are selected with the cursor), do nothing
        if (input.value.length === this._mask.length && maskedString.length > 0 && selectionStart === selectionEnd) {
            input.setSelectionRange(selectionStart, selectionEnd);
            this._cursor = null; // was set in _onKeydown(), but will not be used in this case; so reset it
            event.preventDefault();
            return;
        }
        // if length of newValue is >= mask: allow only to enter characters from a pasted value until mask is filled up
        // example: 12:|34: ("|" cursor position, mask: 00:00:00) => when pasting '567', only '56' fits in until input is filled up => 12:56:|34
        // get the pasted unmasked value from the pasted string (to cut all the invalid characters and separators)
        const pastedUnmaskedValue = this.separators.reduce((unmasked, separator) => unmasked.split(separator).join(''), maskedString);
        let newValue = this.getMaskedString(oldValue.substring(0, selectionStart) + pastedUnmaskedValue + oldValue.substring(selectionEnd, oldValue.length));
        if (newValue.length >= this._mask.length) {
            let newPosition = selectionStart;
            let i = 1;
            do {
                newValue = this.getMaskedString(oldValue.substring(0, selectionStart) + pastedUnmaskedValue.substring(0, i) + oldValue.substring(selectionEnd, oldValue.length));
                newPosition += this._calculateCursorShift(newPosition);
                i++;
            } while (newValue.length < this._mask.length);
            // save value for using it in _onInputChange()
            this._pastedData = newValue;
            this._cursor = {
                position: newPosition,
            };
            return;
        }
        // if pasting is fine: save the cursor position for using them in _onInputChange()
        this._cursor = {
            position: selectionStart + maskedString.length,
        };
    }
    updateValue(value) {
        if (!this._deactivateMask) {
            // Write UpperCase
            if (this._convertTo === 'upper') {
                value = value.toUpperCase();
            }
            else if (this._convertTo === 'lower') {
                value = value.toLowerCase();
            }
        }
        this._elementRef.nativeElement.value = value;
        // _inputValue is needed for calculating the cursor shift in onInput()
        this._inputValue = value;
    }
    /** @docs-private */
    getMaskedString(inputValue, maskStartIndex = 0) {
        let formattedValue = '';
        let maskIndex = maskStartIndex;
        let inputIndex = 0;
        // insert if next in mask is separator
        while (this.isSeparator(this.mask[maskIndex])) {
            formattedValue += this.mask[maskIndex];
            maskIndex++;
        }
        while (inputIndex < inputValue.length) {
            // test if letters are valid
            if (this._isStringAllowed(inputValue[inputIndex], this.mask[maskIndex])) {
                formattedValue += inputValue[inputIndex];
                inputIndex++;
                maskIndex++;
            }
            else {
                inputIndex++;
            }
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                maskIndex++;
            }
        }
        return formattedValue;
    }
    isSeparator(value) {
        return this._separators.includes(value);
    }
    // control value accessor
    writeValue(value) {
        if (!value) {
            value = '';
        }
        this.cvaModelChange.next(value);
        if (this.deactivateMask) {
            this.updateValue(value || this.getUnmaskedValue());
        }
        else {
            this.updateValue(this.getMaskedString(value));
        }
    }
    registerOnChange(onChange) {
        this._onChangeCallback = onChange;
    }
    registerOnTouched(onTouched) {
        this._onTouchedCallback = onTouched;
    }
    /** @docs-private */
    registerOnValidatorChange(fn) {
        this._validatorOnChange = fn;
    }
    _validateFn() {
        const inputLength = this._elementRef.nativeElement.value.length;
        const maskLength = this._mask.length;
        if (inputLength !== maskLength && !this.deactivateMask) {
            return { nxMaskLengthError: { length: maskLength, actual: inputLength } };
        }
        return null;
    }
    /** @docs-private */
    validate() {
        return this.validateMask ? this._validateFn() : null;
    }
    _touch() {
        this._onTouchedCallback();
    }
}
NxMaskDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMaskDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NxMaskDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxMaskDirective, selector: "input[nxMask]", inputs: { deactivateMask: "deactivateMask", mask: ["nxMask", "mask"], convertTo: ["nxConvertTo", "convertTo"], separators: "separators", dropSpecialCharacters: "dropSpecialCharacters", validateMask: "validateMask" }, host: { listeners: { "input": "_onInputChange($event)", "keydown": "_onKeydown($event)", "paste": "_onPaste($event)", "blur": "_touch()" } }, providers: [NX_MASK_VALUE_ACCESSOR, { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective }, NX_MASK_VALIDATORS], exportAs: ["nxMaskDirective"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMaskDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[nxMask]',
                    host: {
                        '(input)': '_onInputChange($event)',
                        '(keydown)': '_onKeydown($event)',
                        '(paste)': '_onPaste($event)',
                        '(blur)': '_touch()',
                    },
                    exportAs: 'nxMaskDirective',
                    providers: [NX_MASK_VALUE_ACCESSOR, { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective }, NX_MASK_VALIDATORS],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { deactivateMask: [{
                type: Input
            }], mask: [{
                type: Input,
                args: ['nxMask']
            }], convertTo: [{
                type: Input,
                args: ['nxConvertTo']
            }], separators: [{
                type: Input
            }], dropSpecialCharacters: [{
                type: Input
            }], validateMask: [{
                type: Input
            }] } });

const NX_IBAN_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NxIbanMaskDirective),
    multi: true,
};
/**
 * To use the `NxIbanMaskDirective`, you have to install the **peer dependency** `iban.js`.
 */
class NxIbanMaskDirective {
    constructor(_elementRef, maskDirective) {
        this._elementRef = _elementRef;
        this.maskDirective = maskDirective;
        this._destroyed = new Subject();
        this._afterInputHook = (event) => {
            const input = event.target;
            this._setCountryCode(input.value.substr(0, 2));
        };
        this._beforePasteHook = (event) => {
            // change the country code here if necessary
            const input = event.target;
            const pastedData = (event.clipboardData || window.clipboardData).getData('text');
            const enteredCountryCode = (this.maskDirective.elementRefValue.substr(0, input.selectionStart) +
                this.maskDirective.getMaskedString(pastedData, input.selectionStart)).substr(0, 2);
            this._setCountryCode(enteredCountryCode);
        };
        this.maskDirective.registerAfterInputHook(this._afterInputHook);
        this.maskDirective.registerBeforePasteHook(this._beforePasteHook);
        this.maskDirective.cvaModelChange.pipe(takeUntil(this._destroyed)).subscribe((value) => {
            const enteredCountryCode = this.maskDirective.getMaskedString(value).substr(0, 2);
            this._setCountryCode(enteredCountryCode);
        });
    }
    _setCountryCode(code) {
        code = code.toUpperCase();
        if (code.length === 2 && this._countryCode !== code) {
            if (IBAN.countries[code]) {
                this._countryCode = code;
                this.maskDirective.setMask(this._getMask(this._countryCode));
            }
            else {
                this._countryCode = null;
                this.maskDirective.setMask('SS');
            }
        }
    }
    ngOnInit() {
        // set only first two letters as I don't know a country yet
        this.maskDirective.mask = 'SS';
        this.maskDirective.convertTo = 'upper';
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    _getMask(countryCode) {
        // the countrySpecs of a country contain: countryCode ("DE"), length (22), structure ("F08F10")
        // and an example belonging to each country
        const countrySpecs = IBAN.countries[countryCode];
        // 'SS' for country code + '00' for IBAN checksum
        let mask = 'SS00';
        // split up after every third character
        const characterDefs = countrySpecs.structure.match(/.{1,3}/g);
        characterDefs.forEach((charDef) => {
            const character = charDef[0];
            const count = Number(charDef.substring(1, 3));
            switch (character) {
                // [0-9]
                case 'F':
                    mask += '0'.repeat(count);
                    break;
                // [0-9A-Za-z]
                case 'A':
                    mask += 'A'.repeat(count);
                    break;
                // [A-Z]
                // 'S' in nxMask does accept also [a-z].
                // There is no option for only accepting capital letters at the moment.
                case 'U':
                    mask += 'S'.repeat(count);
                    break;
            }
        });
        // insert whitespaces after every 4 characters
        mask = mask.match(/.{1,4}/g).join(' ');
        return mask;
    }
    _validateFn() {
        if (this._countryCodeValid()) {
            return { nxIbanInvalidCountryError: 'no valid country code' };
        }
        if (!IBAN.isValid(this.maskDirective.getUnmaskedValue())) {
            return { nxIbanParseError: 'no valid iban' };
        }
        return null;
    }
    /** @docs-private */
    validate() {
        return this.maskDirective.validateMask ? this._validateFn() : null;
    }
    _touch() {
        this.maskDirective._touch();
    }
    _countryCodeValid() {
        const enteredCountryCode = this._elementRef.nativeElement.value.substr(0, 2);
        return enteredCountryCode.length === 2 && !IBAN.countries[enteredCountryCode];
    }
}
NxIbanMaskDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxIbanMaskDirective, deps: [{ token: i0.ElementRef }, { token: forwardRef(() => NxMaskDirective) }], target: i0.ɵɵFactoryTarget.Directive });
NxIbanMaskDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxIbanMaskDirective, selector: "input[nxIbanMask]", host: { listeners: { "input": "_countryCodeValid() && _touch()" } }, providers: [NX_IBAN_MASK_VALIDATORS], exportAs: ["nxIbanMaskDirective"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxIbanMaskDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[nxIbanMask]',
                    exportAs: 'nxIbanMaskDirective',
                    providers: [NX_IBAN_MASK_VALIDATORS],
                    host: {
                        '(input)': '_countryCodeValid() && _touch()',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: NxMaskDirective, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => NxMaskDirective)]
                }] }]; } });

class NxMaskModule {
}
NxMaskModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMaskModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NxMaskModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMaskModule, declarations: [NxMaskDirective, NxIbanMaskDirective], imports: [CommonModule, NxFormfieldModule], exports: [NxFormfieldModule, NxMaskDirective, NxIbanMaskDirective] });
NxMaskModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMaskModule, imports: [[CommonModule, NxFormfieldModule], NxFormfieldModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMaskModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [CommonModule, NxFormfieldModule],
                    declarations: [NxMaskDirective, NxIbanMaskDirective],
                    exports: [NxFormfieldModule, NxMaskDirective, NxIbanMaskDirective],
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NX_IBAN_MASK_VALIDATORS, NX_MASK_VALIDATORS, NX_MASK_VALUE_ACCESSOR, NxIbanMaskDirective, NxMaskDirective, NxMaskModule };
//# sourceMappingURL=aposin-ng-aquila-mask.mjs.map
