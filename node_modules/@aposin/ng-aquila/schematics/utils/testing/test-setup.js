"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchematicTestSetup = exports.addLibrary = exports.createTestLibrary = exports.createApp = exports.createWorkspace = exports.createTestApp = exports.Collection = void 0;
const core_1 = require("@angular-devkit/core");
const testing_1 = require("@angular-devkit/core/node/testing");
const schematics_1 = require("@angular-devkit/schematics");
const testing_2 = require("@angular-devkit/schematics/testing");
const shx = require("shelljs");
var Collection;
(function (Collection) {
    Collection[Collection["SCHEMATICS"] = 1] = "SCHEMATICS";
    Collection[Collection["MIGRATIONS"] = 2] = "MIGRATIONS";
})(Collection = exports.Collection || (exports.Collection = {}));
async function createTestApp(runner, tree, appOptions = {}) {
    const workspaceTree = await createWorkspace(runner, tree);
    return createApp(runner, workspaceTree, appOptions);
}
exports.createTestApp = createTestApp;
async function createWorkspace(runner, tree) {
    return runner
        .runExternalSchematicAsync('@schematics/angular', 'workspace', {
        name: 'workspace',
        version: '6.0.0',
        newProjectRoot: 'projects',
    }, tree)
        .toPromise();
}
exports.createWorkspace = createWorkspace;
async function createApp(runner, tree, options = {}) {
    return runner.runExternalSchematicAsync('@schematics/angular', 'application', { name: 'aquila-testing', ...options }, tree).toPromise();
}
exports.createApp = createApp;
async function createTestLibrary(runner, tree, options = {}) {
    return runner.runExternalSchematicAsync('@schematics/angular', 'library', { name: 'aquila-testing-library' }, tree).toPromise();
}
exports.createTestLibrary = createTestLibrary;
/**
 * Reuses our own ng add and ng add setup project schematics to add the library.
 * Use the options parameter to change it to expert:
 * addLibrary({type: 'b2b'});
 *
 *
 * @param options
 * @param tree
 */
async function addLibrary(options, tree) {
    const aquilarunner = new testing_2.SchematicTestRunner('aquila', require.resolve('../../collection.json'));
    const tempTree = await aquilarunner.runSchematicAsync('ng-add', { type: 'b2c', ...options }, tree).toPromise();
    return aquilarunner.runSchematicAsync('ng-add-setup-project', { type: 'b2c', ...options }, tempTree).toPromise();
}
exports.addLibrary = addLibrary;
/**
 * Helper for setting up everything needed for the schematic tests.
 * It creates things like the TempScopedNodeJsSyncHost and exposes everything and
 * registers the beforeEach and afterEach hooks for jasmine.
 *
 * It also gives you access to functions:
 * + writeFile: makes it possibble to write to the
 *              tempFileSystemHost and also updates the hostTree
 * + syncTreeToFileSystem: syncs the whole app tree to the disk
 * + runMigration: call to run the schematic name you specified in the constructor
 *
 * Usage:
 * describe('my schematic tests', () => {
 *    const testSetup = new SchematicTestSetup('01-my-schematic-name');
 *
 *   it('should do something', async () => {
 *    testSetup.writeFile('/index.ts', `
      import {Foo} from '@aposin/ng-aquila';

      export class TestClass {}
      `);

       await testSetup.runMigration();
       expect(something).toBeTruthy();
 *   });
 * });
 *
 * You can also use destructuring to get the methods for some cleaner code:
 * const testSetup = new SchematicTestSetup('01-my-schematic-name');
 * let { writeFile, runMigration, warnOutput } = testSetup;
 *
 * WARNING: it doesn't work on properties like runner or appTree as they are undefined
 * at that time
 *
 */
class SchematicTestSetup {
    constructor(schematicName, collection = Collection.MIGRATIONS) {
        this.schematicName = schematicName;
        this.collection = collection;
        /**
         * Creates or overwrites a file on the disk and in the virtual Tree
         *
         * @param filePath
         * @param content
         */
        this.writeFile = (filePath, content) => {
            // Update the temp file system host to reflect the changes in the real file system.
            // This is still necessary since we depend on the real file system for parsing the
            // TypeScript project.
            this.tempFileSystemHost.sync.write((0, core_1.normalize)(filePath), core_1.virtualFs.stringToFileBuffer(content));
            if (this.hostTree.exists(filePath)) {
                this.hostTree.overwrite(filePath, content);
            }
            else {
                this.hostTree.create(filePath, content);
            }
        };
        /**
         * Syncs the whole virtual tree to the disk
         */
        this.syncTreeToFileSystem = () => {
            // Since the TypeScript compiler API expects all files to be present on the real file system, we
            // map every file in the app tree to a temporary location on the file system.
            this.appTree.files.forEach(f => this.writeFile(f, this.appTree.readContent(f)));
        };
        /**
         * Run your migration.
         */
        this.runMigration = async (options = {}) => this.runner.runSchematicAsync(this.schematicName, options, this.appTree).toPromise();
        this.setup();
    }
    setup() {
        beforeEach(async () => {
            const schematics = this.collection === Collection.MIGRATIONS ? require.resolve('../../migrations.json') : require.resolve('../../collection.json');
            this.runner = new testing_2.SchematicTestRunner('test', schematics);
            this.tempFileSystemHost = new testing_1.TempScopedNodeJsSyncHost();
            this.hostTree = new schematics_1.HostTree(this.tempFileSystemHost);
            // create whole test app
            this.appTree = await createTestApp(this.runner, this.hostTree, { name: 'aquila-testing' });
            const testAppTsconfigPath = 'projects/aquila-testing/tsconfig.app.json';
            // remove comments and parse json
            const testAppTsconfig = JSON.parse(this.appTree.readContent(testAppTsconfigPath).replace(/\/\*.*\*\//, ''));
            // include all TypeScript files in the project. Otherwise all test input
            // files won't be part of the program and cannot be migrated.
            testAppTsconfig.include.push('src/**/*.ts');
            this.appTree.overwrite(testAppTsconfigPath, JSON.stringify(testAppTsconfig, null, 2));
            this.syncTreeToFileSystem();
            this.warnOutput = [];
            this.infoOutput = [];
            this.errorOutput = [];
            this.runner.logger.subscribe(logEntry => {
                if (logEntry.level === 'warn') {
                    this.warnOutput.push(logEntry.message);
                }
                else if (logEntry.level === 'info') {
                    this.infoOutput.push(logEntry.message);
                }
                else if (logEntry.level === 'error') {
                    this.errorOutput.push(logEntry.message);
                }
            });
            this.previousWorkingDir = shx.pwd();
            this.tmpDirPath = (0, core_1.getSystemPath)(this.tempFileSystemHost.root);
            // Switch into the temporary directory path. This allows us to run
            // the schematic against our custom unit test tree.
            shx.cd(this.tmpDirPath);
        });
        afterEach(async () => {
            shx.cd(this.previousWorkingDir);
            shx.rm('-r', this.tmpDirPath);
        });
    }
    /**
     * Deletes file on the disk and in the virtual Tree
     *
     * @param filePath
     */
    deleteFile(filePath) {
        // Update the temp file system host to reflect the changes in the real file system.
        // This is still necessary since we depend on the real file system for parsing the
        // TypeScript project.
        this.tempFileSystemHost.sync.delete((0, core_1.normalize)(filePath));
        this.hostTree.delete(filePath);
    }
}
exports.SchematicTestSetup = SchematicTestSetup;
//# sourceMappingURL=test-setup.js.map