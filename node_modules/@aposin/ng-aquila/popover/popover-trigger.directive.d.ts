import { FocusMonitor, FocusTrapFactory } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';
import { BooleanInput } from '@angular/cdk/coercion';
import { OriginConnectionPosition, Overlay, OverlayConnectionPosition, ScrollStrategy } from '@angular/cdk/overlay';
import { Platform } from '@angular/cdk/platform';
import { AfterViewInit, ChangeDetectorRef, ElementRef, EventEmitter, InjectionToken, NgZone, OnDestroy, OnInit, ViewContainerRef } from '@angular/core';
import { EventManager } from '@angular/platform-browser';
import { NxPopoverComponent } from './popover.component';
import * as i0 from "@angular/core";
export declare type PopoverVerticalDirection = 'top' | 'bottom';
export declare type PopoverHorizontalDirection = 'left' | 'right';
export declare type PopoverDirection = PopoverHorizontalDirection | PopoverVerticalDirection;
export declare type PopoverTriggerType = 'click' | 'hover' | 'manual';
export declare type PopoverTriggerScrollStrategy = 'close' | 'reposition';
/** Injection token that determines the scroll handling while a popover is open. */
export declare const NX_POPOVER_SCROLL_STRATEGY: InjectionToken<() => ScrollStrategy>;
/** @docs-private */
export declare function NX_POPOVER_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay: Overlay): () => ScrollStrategy;
/** @docs-private */
export declare const NX_POPOVER_SCROLL_STRATEGY_PROVIDER: {
    provide: InjectionToken<() => ScrollStrategy>;
    useFactory: typeof NX_POPOVER_SCROLL_STRATEGY_PROVIDER_FACTORY;
    deps: (typeof Overlay)[];
};
/**
 * Creates an error to be thrown if the user provided an invalid popover direction.
 * @docs-private
 */
export declare function getNxPopoverInvalidDirectionError(direction: string): Error;
export declare class NxPopoverTriggerDirective implements AfterViewInit, OnDestroy, OnInit {
    #private;
    private overlay;
    private elementRef;
    private viewContainerRef;
    private eventManager;
    private _focusTrapFactory;
    private _focusMonitor;
    private _ngZone;
    private _platform;
    private _dir;
    private _defaultScrollStrategyFactory;
    private _cdr;
    private overlayRef;
    private portal;
    private _overlayDestroyed;
    private _show;
    private _closeable;
    private _positionStrategy;
    private _embeddedViewRef;
    private _modal;
    /** The class that traps and manages focus within the popover. */
    private _focusTrap;
    /** Element that was focused before the Popover was opened. Save this to restore upon close. */
    private _elementFocusedBeforePopoverWasOpened;
    private _manualListeners;
    private _possiblePopoverDirections;
    private _removeEventListener;
    closeOnLeftViewport: IntersectionObserver;
    /** @docs-private */
    id: string;
    /** An event is emitted if the visibility status of the popover changes. */
    changeShow: EventEmitter<boolean>;
    /** Whether to show or hide the popover. */
    set show(value: BooleanInput);
    get show(): BooleanInput;
    /** Whether to show a close button. By default a close icon is only shown for trigger type click. */
    set closeable(value: BooleanInput);
    get closeable(): boolean;
    /** Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'. */
    set closeOnClickOutside(value: BooleanInput);
    get closeOnClickOutside(): boolean;
    private _closeOnClickOutside;
    /** Links the trigger with the popover to open. */
    popover: NxPopoverComponent;
    /** Sets the desired direction to open the popover. E.g., right, left, bottom, top */
    direction: PopoverDirection;
    /** Whether the popover will be opened automatically. */
    popoverInitialVisible: boolean;
    /** An event is emitted when the visibility of the popopver changes. */
    visibleChange: EventEmitter<boolean>;
    /** Whether the popover opens in modal state. */
    set modal(value: BooleanInput);
    get modal(): boolean;
    /** Sets the way to trigger the popover. Options are hover, click, manual */
    trigger: PopoverTriggerType;
    /** Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin. */
    set scrollStrategy(value: PopoverTriggerScrollStrategy | null | undefined);
    get scrollStrategy(): PopoverTriggerScrollStrategy | null | undefined;
    private readonly _destroyed;
    /** Strategy factory that will be used to handle scrolling while the popover panel is open. */
    private _scrollStrategyFactory;
    constructor(overlay: Overlay, elementRef: ElementRef, viewContainerRef: ViewContainerRef, eventManager: EventManager, _focusTrapFactory: FocusTrapFactory, _focusMonitor: FocusMonitor, _ngZone: NgZone, _platform: Platform, _dir: Directionality | null, _defaultScrollStrategyFactory: () => ScrollStrategy, _cdr: ChangeDetectorRef);
    ngOnInit(): void;
    ngAfterViewInit(): void;
    ngOnDestroy(): void;
    /** @docs-private */
    get isOpen(): boolean | null;
    /** @docs-private */
    isCloseable(): boolean;
    /** Update the popover with the given position strategy. */
    updatePosition(): void;
    /** @docs-private */
    handleClick(): void;
    /** Open the popover instance. */
    open(): void;
    /** Close the popover instance. */
    close(): void;
    /** Toggle the popover instance. */
    toggle(): void;
    private openPopover;
    /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     */
    private _autoFocusFirstTabbableElement;
    private closePopover;
    private getScrollStrategyFactory;
    private createOverlay;
    private subscribeToPositions;
    private _subscribeToBackdropClick;
    private _subscribeToDetach;
    private _subscribeToAttach;
    private waitForClose;
    private positionOverlay;
    private positionArrow;
    private getPosition;
    /** Returns the focus to the element focused before the Popover was open. */
    private _returnFocusAfterPopover;
    /** Returns the main popover container of the injected content. */
    private getPopoverContainer;
    /**
     * Returns the origin position based on the user's direction preference.
     */
    _getOrigin(direction: PopoverDirection): OriginConnectionPosition;
    /** Returns the overlay position based on the user's direction preference */
    _getOverlayPosition(direction: PopoverDirection): OverlayConnectionPosition;
    /** Returns the overlay offset required by the user's direction preference */
    private _getOffset;
    /** Returns the opposite direction, using aquila popover direction naming: top, right, bottom, left */
    private _getInversePopoverDirection;
    /** Returns the opposite position, using angular position naming: top, bottom, start, end, center */
    private _getInversePosition;
    /** Returns an array of fallback positions for popover, following the algoritm:
     * 1) Slightly alternate preferred position if applicable. I.e. for 'top' try 'top-start' and 'top-end' positioning.
     * 2) Try the opposite position, i.e. for 'top' try 'bottom'.
     * 3) Slightly alternate opposite position, i.e. 'bottom-start', 'bottom-end'
     * 4) All remaining positions from positions list
     */
    private _getFallbackPositions;
    /** Calculates fallbacks for vertical popover positioning */
    private _getVerticalFallbackPositionPairs;
    /** Calculates fallbacks for horizontal popover positioning */
    private _getHorizontalFallbackPositionPairs;
    private _dirChangeHandler;
    get isRtl(): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<NxPopoverTriggerDirective, [null, null, null, null, null, null, null, null, { optional: true; }, null, null]>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NxPopoverTriggerDirective, "[nxPopoverTriggerFor]", ["nxPopoverTrigger"], { "show": "nxPopoverShow"; "closeable": "nxPopoverCloseable"; "closeOnClickOutside": "closeOnClickOutside"; "popover": "nxPopoverTriggerFor"; "direction": "nxPopoverDirection"; "popoverInitialVisible": "nxPopoverInitialVisible"; "visibleChange": "nxPopoverVisibleChange"; "modal": "nxPopoverModal"; "trigger": "nxPopoverTrigger"; "scrollStrategy": "nxPopoverScrollStrategy"; }, { "changeShow": "nxPopoverShowChange"; }, never>;
}
