/**
 * Provides a set of date validators that can be used by form controls.
 * @dynamic
 */
export class NxDateValidators {
    /** The form control validator for whether the input parses. */
    static parse(dateAdapter, dateFormats, input, strict, customParseFormat) {
        return () => {
            if (!input.value) {
                return null;
            }
            const parsedValue = dateAdapter.parse(input.value, customParseFormat || dateFormats.parse.dateInput, strict);
            const valid = parsedValue && dateAdapter.isValid(parsedValue);
            return valid ? null : { nxDatefieldParse: { text: input } };
        };
    }
    /** The form control validator for the min date. */
    static min(dateAdapter, min) {
        return (control) => {
            const controlValue = getValidDateOrNull(dateAdapter, dateAdapter.deserialize(control.value));
            return !min || !controlValue || dateAdapter.compareDate(min, controlValue) <= 0 ? null : { nxDatefieldMin: { min, actual: controlValue } };
        };
    }
    /** The form control validator for the max date. */
    static max(dateAdapter, max) {
        return (control) => {
            const controlValue = getValidDateOrNull(dateAdapter, dateAdapter.deserialize(control.value));
            return !max || !controlValue || dateAdapter.compareDate(max, controlValue) >= 0 ? null : { nxDatefieldMax: { max, actual: controlValue } };
        };
    }
    /** The form control validator for the date filter. */
    static filter(dateAdapter, dateFilter) {
        return (control) => {
            const controlValue = getValidDateOrNull(dateAdapter, dateAdapter.deserialize(control.value));
            return !dateFilter || !controlValue || dateFilter(controlValue) ? null : { nxDatefieldFilter: true };
        };
    }
}
function getValidDateOrNull(dateAdapter, obj) {
    return dateAdapter.isDateInstance(obj) && dateAdapter.isValid(obj) ? obj : null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS12YWxpZGF0b3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctYXF1aWxhL3NyYy9kYXRlZmllbGQvZGF0ZS12YWxpZGF0b3JzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUlBOzs7R0FHRztBQUNILE1BQU0sT0FBTyxnQkFBZ0I7SUFDekIsK0RBQStEO0lBQy9ELE1BQU0sQ0FBQyxLQUFLLENBQ1IsV0FBNkIsRUFDN0IsV0FBMEIsRUFDMUIsS0FBdUIsRUFDdkIsTUFBZSxFQUNmLGlCQUFvQztRQUVwQyxPQUFPLEdBQTRCLEVBQUU7WUFDakMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUU7Z0JBQ2QsT0FBTyxJQUFJLENBQUM7YUFDZjtZQUNELE1BQU0sV0FBVyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxpQkFBaUIsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUM3RyxNQUFNLEtBQUssR0FBRyxXQUFXLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM5RCxPQUFPLEtBQUssQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLGdCQUFnQixFQUFFLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUM7UUFDaEUsQ0FBQyxDQUFDO0lBQ04sQ0FBQztJQUVELG1EQUFtRDtJQUNuRCxNQUFNLENBQUMsR0FBRyxDQUFJLFdBQTZCLEVBQUUsR0FBTTtRQUMvQyxPQUFPLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZQUN6RCxNQUFNLFlBQVksR0FBRyxrQkFBa0IsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM3RixPQUFPLENBQUMsR0FBRyxJQUFJLENBQUMsWUFBWSxJQUFJLFdBQVcsQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLGNBQWMsRUFBRSxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLEVBQUUsQ0FBQztRQUMvSSxDQUFDLENBQUM7SUFDTixDQUFDO0lBRUQsbURBQW1EO0lBQ25ELE1BQU0sQ0FBQyxHQUFHLENBQUksV0FBNkIsRUFBRSxHQUFNO1FBQy9DLE9BQU8sQ0FBQyxPQUF3QixFQUEyQixFQUFFO1lBQ3pELE1BQU0sWUFBWSxHQUFHLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzdGLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxZQUFZLElBQUksV0FBVyxDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsY0FBYyxFQUFFLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsRUFBRSxDQUFDO1FBQy9JLENBQUMsQ0FBQztJQUNOLENBQUM7SUFFRCxzREFBc0Q7SUFDdEQsTUFBTSxDQUFDLE1BQU0sQ0FBSSxXQUE2QixFQUFFLFVBQXVDO1FBQ25GLE9BQU8sQ0FBQyxPQUF3QixFQUEyQixFQUFFO1lBQ3pELE1BQU0sWUFBWSxHQUFHLGtCQUFrQixDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzdGLE9BQU8sQ0FBQyxVQUFVLElBQUksQ0FBQyxZQUFZLElBQUksVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQUM7UUFDekcsQ0FBQyxDQUFDO0lBQ04sQ0FBQztDQUNKO0FBRUQsU0FBUyxrQkFBa0IsQ0FBSSxXQUE2QixFQUFFLEdBQVE7SUFDbEUsT0FBTyxXQUFXLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQ3BGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBYnN0cmFjdENvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvckZuIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBOeERhdGVBZGFwdGVyLCBOeERhdGVGb3JtYXRzIH0gZnJvbSAnLi9hZGFwdGVyJztcblxuLyoqXG4gKiBQcm92aWRlcyBhIHNldCBvZiBkYXRlIHZhbGlkYXRvcnMgdGhhdCBjYW4gYmUgdXNlZCBieSBmb3JtIGNvbnRyb2xzLlxuICogQGR5bmFtaWNcbiAqL1xuZXhwb3J0IGNsYXNzIE54RGF0ZVZhbGlkYXRvcnMge1xuICAgIC8qKiBUaGUgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3Igd2hldGhlciB0aGUgaW5wdXQgcGFyc2VzLiAqL1xuICAgIHN0YXRpYyBwYXJzZTxEPihcbiAgICAgICAgZGF0ZUFkYXB0ZXI6IE54RGF0ZUFkYXB0ZXI8RD4sXG4gICAgICAgIGRhdGVGb3JtYXRzOiBOeERhdGVGb3JtYXRzLFxuICAgICAgICBpbnB1dDogSFRNTElucHV0RWxlbWVudCxcbiAgICAgICAgc3RyaWN0OiBib29sZWFuLFxuICAgICAgICBjdXN0b21QYXJzZUZvcm1hdDogc3RyaW5nIHwgc3RyaW5nW10sXG4gICAgKTogVmFsaWRhdG9yRm4ge1xuICAgICAgICByZXR1cm4gKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgICAgICAgIGlmICghaW5wdXQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gZGF0ZUFkYXB0ZXIucGFyc2UoaW5wdXQudmFsdWUsIGN1c3RvbVBhcnNlRm9ybWF0IHx8IGRhdGVGb3JtYXRzLnBhcnNlLmRhdGVJbnB1dCwgc3RyaWN0KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkID0gcGFyc2VkVmFsdWUgJiYgZGF0ZUFkYXB0ZXIuaXNWYWxpZChwYXJzZWRWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdmFsaWQgPyBudWxsIDogeyBueERhdGVmaWVsZFBhcnNlOiB7IHRleHQ6IGlucHV0IH0gfTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogVGhlIGZvcm0gY29udHJvbCB2YWxpZGF0b3IgZm9yIHRoZSBtaW4gZGF0ZS4gKi9cbiAgICBzdGF0aWMgbWluPEQ+KGRhdGVBZGFwdGVyOiBOeERhdGVBZGFwdGVyPEQ+LCBtaW46IEQpOiBWYWxpZGF0b3JGbiB7XG4gICAgICAgIHJldHVybiAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbFZhbHVlID0gZ2V0VmFsaWREYXRlT3JOdWxsKGRhdGVBZGFwdGVyLCBkYXRlQWRhcHRlci5kZXNlcmlhbGl6ZShjb250cm9sLnZhbHVlKSk7XG4gICAgICAgICAgICByZXR1cm4gIW1pbiB8fCAhY29udHJvbFZhbHVlIHx8IGRhdGVBZGFwdGVyLmNvbXBhcmVEYXRlKG1pbiwgY29udHJvbFZhbHVlKSA8PSAwID8gbnVsbCA6IHsgbnhEYXRlZmllbGRNaW46IHsgbWluLCBhY3R1YWw6IGNvbnRyb2xWYWx1ZSB9IH07XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIFRoZSBmb3JtIGNvbnRyb2wgdmFsaWRhdG9yIGZvciB0aGUgbWF4IGRhdGUuICovXG4gICAgc3RhdGljIG1heDxEPihkYXRlQWRhcHRlcjogTnhEYXRlQWRhcHRlcjxEPiwgbWF4OiBEKTogVmFsaWRhdG9yRm4ge1xuICAgICAgICByZXR1cm4gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xWYWx1ZSA9IGdldFZhbGlkRGF0ZU9yTnVsbChkYXRlQWRhcHRlciwgZGF0ZUFkYXB0ZXIuZGVzZXJpYWxpemUoY29udHJvbC52YWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuICFtYXggfHwgIWNvbnRyb2xWYWx1ZSB8fCBkYXRlQWRhcHRlci5jb21wYXJlRGF0ZShtYXgsIGNvbnRyb2xWYWx1ZSkgPj0gMCA/IG51bGwgOiB7IG54RGF0ZWZpZWxkTWF4OiB7IG1heCwgYWN0dWFsOiBjb250cm9sVmFsdWUgfSB9O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKiBUaGUgZm9ybSBjb250cm9sIHZhbGlkYXRvciBmb3IgdGhlIGRhdGUgZmlsdGVyLiAqL1xuICAgIHN0YXRpYyBmaWx0ZXI8RD4oZGF0ZUFkYXB0ZXI6IE54RGF0ZUFkYXB0ZXI8RD4sIGRhdGVGaWx0ZXI6IChkYXRlOiBEIHwgbnVsbCkgPT4gYm9vbGVhbik6IFZhbGlkYXRvckZuIHtcbiAgICAgICAgcmV0dXJuIChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250cm9sVmFsdWUgPSBnZXRWYWxpZERhdGVPck51bGwoZGF0ZUFkYXB0ZXIsIGRhdGVBZGFwdGVyLmRlc2VyaWFsaXplKGNvbnRyb2wudmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybiAhZGF0ZUZpbHRlciB8fCAhY29udHJvbFZhbHVlIHx8IGRhdGVGaWx0ZXIoY29udHJvbFZhbHVlKSA/IG51bGwgOiB7IG54RGF0ZWZpZWxkRmlsdGVyOiB0cnVlIH07XG4gICAgICAgIH07XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRWYWxpZERhdGVPck51bGw8RD4oZGF0ZUFkYXB0ZXI6IE54RGF0ZUFkYXB0ZXI8RD4sIG9iajogYW55KTogRCB8IG51bGwge1xuICAgIHJldHVybiBkYXRlQWRhcHRlci5pc0RhdGVJbnN0YW5jZShvYmopICYmIGRhdGVBZGFwdGVyLmlzVmFsaWQob2JqKSA/IG9iaiA6IG51bGw7XG59XG4iXX0=