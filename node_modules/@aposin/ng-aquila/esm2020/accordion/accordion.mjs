import { CdkAccordion } from '@angular/cdk/accordion';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Directive, Input } from '@angular/core';
import * as i0 from "@angular/core";
const DEFAULT_TYPE = 'regular';
export class NxAccordionDirective extends CdkAccordion {
    constructor() {
        super(...arguments);
        this._style = 'regular';
    }
    /**
     * Value for the styling that should be chosen.
     * Default value: 'regular'
     */
    set style(value) {
        value = value ? value : DEFAULT_TYPE;
        const [newValue] = value.match(/regular|light|extra-light/) || [DEFAULT_TYPE];
        this._style = newValue;
    }
    get style() {
        return this._style;
    }
    /** Whether the negative set of styles should be used. */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
    }
    get negative() {
        return !!this._negative;
    }
}
NxAccordionDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxAccordionDirective, deps: null, target: i0.ɵɵFactoryTarget.Directive });
NxAccordionDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxAccordionDirective, selector: "nx-accordion", inputs: { style: ["nxStyle", "style"], negative: "negative" }, host: { attributes: { "role": "presentation" }, properties: { "class.nx-accordion": "true" } }, usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxAccordionDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'nx-accordion',
                    host: {
                        '[class.nx-accordion]': 'true',
                        role: 'presentation',
                    },
                }]
        }], propDecorators: { style: [{
                type: Input,
                args: ['nxStyle']
            }], negative: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWNjb3JkaW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctYXF1aWxhL3NyYy9hY2NvcmRpb24vYWNjb3JkaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN0RCxPQUFPLEVBQWdCLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBSWpELE1BQU0sWUFBWSxHQUFtQixTQUFTLENBQUM7QUFTL0MsTUFBTSxPQUFPLG9CQUFxQixTQUFRLFlBQVk7SUFQdEQ7O1FBUVksV0FBTSxHQUFtQixTQUFTLENBQUM7S0EyQjlDO0lBekJHOzs7T0FHRztJQUNILElBQ0ksS0FBSyxDQUFDLEtBQXFCO1FBQzNCLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDO1FBRXJDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLDJCQUEyQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQztRQUM5RSxJQUFJLENBQUMsTUFBTSxHQUFHLFFBQTBCLENBQUM7SUFDN0MsQ0FBQztJQUNELElBQUksS0FBSztRQUNMLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUN2QixDQUFDO0lBSUQseURBQXlEO0lBQ3pELElBQ0ksUUFBUSxDQUFDLEtBQW1CO1FBQzVCLElBQUksQ0FBQyxTQUFTLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUNELElBQUksUUFBUTtRQUNSLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDNUIsQ0FBQzs7aUhBM0JRLG9CQUFvQjtxR0FBcEIsb0JBQW9COzJGQUFwQixvQkFBb0I7a0JBUGhDLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUFFLGNBQWM7b0JBQ3hCLElBQUksRUFBRTt3QkFDRixzQkFBc0IsRUFBRSxNQUFNO3dCQUM5QixJQUFJLEVBQUUsY0FBYztxQkFDdkI7aUJBQ0o7OEJBU08sS0FBSztzQkFEUixLQUFLO3VCQUFDLFNBQVM7Z0JBZVosUUFBUTtzQkFEWCxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2RrQWNjb3JkaW9uIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2FjY29yZGlvbic7XG5pbXBvcnQgeyBCb29sZWFuSW5wdXQsIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFjY29yZGlvblN0eWxlIH0gZnJvbSAnLi9leHBhbnNpb24tcGFuZWwnO1xuXG5jb25zdCBERUZBVUxUX1RZUEU6IEFjY29yZGlvblN0eWxlID0gJ3JlZ3VsYXInO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ254LWFjY29yZGlvbicsXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLm54LWFjY29yZGlvbl0nOiAndHJ1ZScsXG4gICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxuICAgIH0sXG59KVxuZXhwb3J0IGNsYXNzIE54QWNjb3JkaW9uRGlyZWN0aXZlIGV4dGVuZHMgQ2RrQWNjb3JkaW9uIHtcbiAgICBwcml2YXRlIF9zdHlsZTogQWNjb3JkaW9uU3R5bGUgPSAncmVndWxhcic7XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBmb3IgdGhlIHN0eWxpbmcgdGhhdCBzaG91bGQgYmUgY2hvc2VuLlxuICAgICAqIERlZmF1bHQgdmFsdWU6ICdyZWd1bGFyJ1xuICAgICAqL1xuICAgIEBJbnB1dCgnbnhTdHlsZScpXG4gICAgc2V0IHN0eWxlKHZhbHVlOiBBY2NvcmRpb25TdHlsZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlID8gdmFsdWUgOiBERUZBVUxUX1RZUEU7XG5cbiAgICAgICAgY29uc3QgW25ld1ZhbHVlXSA9IHZhbHVlLm1hdGNoKC9yZWd1bGFyfGxpZ2h0fGV4dHJhLWxpZ2h0LykgfHwgW0RFRkFVTFRfVFlQRV07XG4gICAgICAgIHRoaXMuX3N0eWxlID0gbmV3VmFsdWUgYXMgQWNjb3JkaW9uU3R5bGU7XG4gICAgfVxuICAgIGdldCBzdHlsZSgpOiBBY2NvcmRpb25TdHlsZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9uZWdhdGl2ZTogYm9vbGVhbiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBuZWdhdGl2ZSBzZXQgb2Ygc3R5bGVzIHNob3VsZCBiZSB1c2VkLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IG5lZ2F0aXZlKHZhbHVlOiBCb29sZWFuSW5wdXQpIHtcbiAgICAgICAgdGhpcy5fbmVnYXRpdmUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbmVnYXRpdmUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX25lZ2F0aXZlO1xuICAgIH1cbn1cbiJdfQ==