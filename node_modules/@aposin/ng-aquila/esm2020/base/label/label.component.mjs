import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, Component, Inject, InjectionToken, Input, Optional } from '@angular/core';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
let nextId = 0;
const DEFAULT_SIZE = 'large';
export const LABEL_DEFAULT_OPTIONS = new InjectionToken('LABEL_DEFAULT_OPTIONS');
export class NxLabelComponent {
    constructor(_defaultOptions, _cdr) {
        this._defaultOptions = _defaultOptions;
        this._cdr = _cdr;
        this._stateChanges = new Subject();
        this._disabled = false;
        this._negative = false;
        this._for = null;
        this._id = `nx-label-${nextId++}`;
    }
    /** Sets the label to disabled */
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        this._stateChanges.next();
    }
    get disabled() {
        return this._disabled;
    }
    /** Sets the label to disabled */
    set negative(value) {
        this._negative = coerceBooleanProperty(value);
        this._stateChanges.next();
    }
    get negative() {
        return this._negative;
    }
    /** Sets the Id of the label */
    set id(value) {
        this._id = value;
    }
    get id() {
        return this._id;
    }
    /**
     * **Expert option**
     * Sets the appearance of the label */
    set size(value) {
        this._size = value;
        this._stateChanges.next();
    }
    get size() {
        return this._size || this._defaultOptions?.size || DEFAULT_SIZE;
    }
    /**
     * Sets the html `for` attribute on the label.
     */
    set for(value) {
        this._for = value;
        this._cdr.markForCheck();
        this._stateChanges.next();
    }
    get for() {
        return this._for;
    }
}
NxLabelComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxLabelComponent, deps: [{ token: LABEL_DEFAULT_OPTIONS, optional: true }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
NxLabelComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxLabelComponent, selector: "nx-label", inputs: { disabled: "disabled", negative: "negative", id: "id", size: "size", for: "for" }, host: { properties: { "attr.disabled": "disabled", "class.nx-label--negative": "negative", "class.nx-label--large": "size === \"large\"", "class.nx-label--small": "size === \"small\"" } }, ngImport: i0, template: "<label class=\"nx-label__content\" [for]=\"for\" [id]=\"id\">\n    <ng-content></ng-content>\n</label>\n", styles: [":host{display:block;color:var(--text-01)}:host.nx-label--small{font-size:var(--base-label-small-font-size);line-height:var(--base-label-small-line-height);font-weight:var(--base-label-small-font-weight);letter-spacing:var(--base-label-small-letter-spacing)}:host.nx-label--large{font-size:var(--base-label-large-font-size);line-height:var(--base-label-large-line-height);font-weight:var(--base-label-large-font-weight);letter-spacing:var(--base-label-large-letter-spacing)}:host[disabled=true] label{cursor:not-allowed}:host.nx-label--negative{color:var(--negative)}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxLabelComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-label', changeDetection: ChangeDetectionStrategy.OnPush, host: {
                        '[attr.disabled]': 'disabled',
                        '[class.nx-label--negative]': 'negative',
                        '[class.nx-label--large]': 'size === "large"',
                        '[class.nx-label--small]': 'size === "small"',
                    }, template: "<label class=\"nx-label__content\" [for]=\"for\" [id]=\"id\">\n    <ng-content></ng-content>\n</label>\n", styles: [":host{display:block;color:var(--text-01)}:host.nx-label--small{font-size:var(--base-label-small-font-size);line-height:var(--base-label-small-line-height);font-weight:var(--base-label-small-font-weight);letter-spacing:var(--base-label-small-letter-spacing)}:host.nx-label--large{font-size:var(--base-label-large-font-size);line-height:var(--base-label-large-line-height);font-weight:var(--base-label-large-font-weight);letter-spacing:var(--base-label-large-letter-spacing)}:host[disabled=true] label{cursor:not-allowed}:host.nx-label--negative{color:var(--negative)}\n"] }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [LABEL_DEFAULT_OPTIONS]
                }] }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { disabled: [{
                type: Input
            }], negative: [{
                type: Input
            }], id: [{
                type: Input
            }], size: [{
                type: Input
            }], for: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFiZWwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctYXF1aWxhL3NyYy9iYXNlL2xhYmVsL2xhYmVsLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWFxdWlsYS9zcmMvYmFzZS9sYWJlbC9sYWJlbC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWdCLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUUsT0FBTyxFQUFFLHVCQUF1QixFQUFxQixTQUFTLEVBQUUsTUFBTSxFQUFFLGNBQWMsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQy9ILE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBRS9CLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztBQVNmLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQztBQUU3QixNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLGNBQWMsQ0FBc0IsdUJBQXVCLENBQUMsQ0FBQztBQWF0RyxNQUFNLE9BQU8sZ0JBQWdCO0lBa0V6QixZQUErRCxlQUEyQyxFQUFVLElBQXVCO1FBQTVFLG9CQUFlLEdBQWYsZUFBZSxDQUE0QjtRQUFVLFNBQUksR0FBSixJQUFJLENBQW1CO1FBakVsSSxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFDckMsY0FBUyxHQUFHLEtBQUssQ0FBQztRQUNsQixjQUFTLEdBQUcsS0FBSyxDQUFDO1FBRWxCLFNBQUksR0FBa0IsSUFBSSxDQUFDO1FBQzNCLFFBQUcsR0FBRyxZQUFZLE1BQU0sRUFBRSxFQUFFLENBQUM7SUE0RHlHLENBQUM7SUExRC9JLGlDQUFpQztJQUNqQyxJQUNJLFFBQVEsQ0FBQyxLQUFtQjtRQUM1QixJQUFJLENBQUMsU0FBUyxHQUFHLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVELElBQUksUUFBUTtRQUNSLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUMxQixDQUFDO0lBRUQsaUNBQWlDO0lBQ2pDLElBQ0ksUUFBUSxDQUFDLEtBQW1CO1FBQzVCLElBQUksQ0FBQyxTQUFTLEdBQUcscUJBQXFCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQsSUFBSSxRQUFRO1FBQ1IsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQzFCLENBQUM7SUFFRCwrQkFBK0I7SUFDL0IsSUFDSSxFQUFFLENBQUMsS0FBYTtRQUNoQixJQUFJLENBQUMsR0FBRyxHQUFHLEtBQUssQ0FBQztJQUNyQixDQUFDO0lBRUQsSUFBSSxFQUFFO1FBQ0YsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7MENBRXNDO0lBQ3RDLElBQ0ksSUFBSSxDQUFDLEtBQXNCO1FBQzNCLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVELElBQUksSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksSUFBSSxZQUFZLENBQUM7SUFDcEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFDSSxHQUFHLENBQUMsS0FBb0I7UUFDeEIsSUFBSSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFDRCxJQUFJLEdBQUc7UUFDSCxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDckIsQ0FBQzs7NkdBaEVRLGdCQUFnQixrQkFrRU8scUJBQXFCO2lHQWxFNUMsZ0JBQWdCLHlVQzVCN0IsMEdBR0E7MkZEeUJhLGdCQUFnQjtrQkFaNUIsU0FBUzsrQkFDSSxVQUFVLG1CQUdILHVCQUF1QixDQUFDLE1BQU0sUUFDekM7d0JBQ0YsaUJBQWlCLEVBQUUsVUFBVTt3QkFDN0IsNEJBQTRCLEVBQUUsVUFBVTt3QkFDeEMseUJBQXlCLEVBQUUsa0JBQWtCO3dCQUM3Qyx5QkFBeUIsRUFBRSxrQkFBa0I7cUJBQ2hEOzswQkFvRVksUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxxQkFBcUI7NEVBeERqRCxRQUFRO3NCQURYLEtBQUs7Z0JBWUYsUUFBUTtzQkFEWCxLQUFLO2dCQVlGLEVBQUU7c0JBREwsS0FBSztnQkFhRixJQUFJO3NCQURQLEtBQUs7Z0JBY0YsR0FBRztzQkFETixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm9vbGVhbklucHV0LCBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEluamVjdCwgSW5qZWN0aW9uVG9rZW4sIElucHV0LCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5sZXQgbmV4dElkID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBMYWJlbERlZmF1bHRPcHRpb25zIHtcbiAgICAvKiogU2V0cyB0aGUgZGVmYXVsdCBhcHBlYXJhbmNlLiAob3B0aW9uYWwpICovXG4gICAgc2l6ZT86IExBQkVMX1NJWkVfVFlQRTtcbn1cblxuLyoqIE9wdGlvbnMgZm9yIHNpemluZyBvZiB0aGUgbGFiZWwuICovXG5leHBvcnQgdHlwZSBMQUJFTF9TSVpFX1RZUEUgPSAnc21hbGwnIHwgJ2xhcmdlJztcbmNvbnN0IERFRkFVTFRfU0laRSA9ICdsYXJnZSc7XG5cbmV4cG9ydCBjb25zdCBMQUJFTF9ERUZBVUxUX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48TGFiZWxEZWZhdWx0T3B0aW9ucz4oJ0xBQkVMX0RFRkFVTFRfT1BUSU9OUycpO1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdueC1sYWJlbCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2xhYmVsLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnbGFiZWwuY29tcG9uZW50LnNjc3MnXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBob3N0OiB7XG4gICAgICAgICdbYXR0ci5kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAnW2NsYXNzLm54LWxhYmVsLS1uZWdhdGl2ZV0nOiAnbmVnYXRpdmUnLFxuICAgICAgICAnW2NsYXNzLm54LWxhYmVsLS1sYXJnZV0nOiAnc2l6ZSA9PT0gXCJsYXJnZVwiJyxcbiAgICAgICAgJ1tjbGFzcy5ueC1sYWJlbC0tc21hbGxdJzogJ3NpemUgPT09IFwic21hbGxcIicsXG4gICAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTnhMYWJlbENvbXBvbmVudCB7XG4gICAgcmVhZG9ubHkgX3N0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcHJpdmF0ZSBfZGlzYWJsZWQgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9uZWdhdGl2ZSA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3NpemU6IExBQkVMX1NJWkVfVFlQRSB8IHVuZGVmaW5lZDtcbiAgICBwcml2YXRlIF9mb3I6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICAgIHByaXZhdGUgX2lkID0gYG54LWxhYmVsLSR7bmV4dElkKyt9YDtcblxuICAgIC8qKiBTZXRzIHRoZSBsYWJlbCB0byBkaXNhYmxlZCAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGRpc2FibGVkKHZhbHVlOiBCb29sZWFuSW5wdXQpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cblxuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cblxuICAgIC8qKiBTZXRzIHRoZSBsYWJlbCB0byBkaXNhYmxlZCAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IG5lZ2F0aXZlKHZhbHVlOiBCb29sZWFuSW5wdXQpIHtcbiAgICAgICAgdGhpcy5fbmVnYXRpdmUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cblxuICAgIGdldCBuZWdhdGl2ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25lZ2F0aXZlO1xuICAgIH1cblxuICAgIC8qKiBTZXRzIHRoZSBJZCBvZiB0aGUgbGFiZWwgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAqKkV4cGVydCBvcHRpb24qKlxuICAgICAqIFNldHMgdGhlIGFwcGVhcmFuY2Ugb2YgdGhlIGxhYmVsICovXG4gICAgQElucHV0KClcbiAgICBzZXQgc2l6ZSh2YWx1ZTogTEFCRUxfU0laRV9UWVBFKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fc3RhdGVDaGFuZ2VzLm5leHQoKTtcbiAgICB9XG5cbiAgICBnZXQgc2l6ZSgpOiBMQUJFTF9TSVpFX1RZUEUge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2l6ZSB8fCB0aGlzLl9kZWZhdWx0T3B0aW9ucz8uc2l6ZSB8fCBERUZBVUxUX1NJWkU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaHRtbCBgZm9yYCBhdHRyaWJ1dGUgb24gdGhlIGxhYmVsLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGZvcih2YWx1ZTogc3RyaW5nIHwgbnVsbCkge1xuICAgICAgICB0aGlzLl9mb3IgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZXMubmV4dCgpO1xuICAgIH1cbiAgICBnZXQgZm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIEBJbmplY3QoTEFCRUxfREVGQVVMVF9PUFRJT05TKSBwcml2YXRlIF9kZWZhdWx0T3B0aW9uczogTGFiZWxEZWZhdWx0T3B0aW9ucyB8IG51bGwsIHByaXZhdGUgX2NkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHt9XG59XG4iLCI8bGFiZWwgY2xhc3M9XCJueC1sYWJlbF9fY29udGVudFwiIFtmb3JdPVwiZm9yXCIgW2lkXT1cImlkXCI+XG4gICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuPC9sYWJlbD5cbiJdfQ==