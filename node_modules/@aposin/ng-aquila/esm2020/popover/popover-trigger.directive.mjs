var _NxPopoverTriggerDirective_scrollStrategy;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ENTER, SPACE } from '@angular/cdk/keycodes';
import { Overlay, OverlayConfig, } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { Directive, EventEmitter, Inject, InjectionToken, Input, Optional, Output, } from '@angular/core';
import { Subject } from 'rxjs';
import { filter, map, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/platform-browser";
import * as i3 from "@angular/cdk/a11y";
import * as i4 from "@angular/cdk/platform";
import * as i5 from "@angular/cdk/bidi";
let nextId = 0;
const BASE_OFFSET = 16;
/** Injection token that determines the scroll handling while a popover is open. */
export const NX_POPOVER_SCROLL_STRATEGY = new InjectionToken('nx-popover-scroll-strategy');
/** @docs-private */
export function NX_POPOVER_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.close();
}
/** @docs-private */
export const NX_POPOVER_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_POPOVER_SCROLL_STRATEGY,
    useFactory: NX_POPOVER_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
/**
 * Creates an error to be thrown if the user provided an invalid popover direction.
 * @docs-private
 */
export function getNxPopoverInvalidDirectionError(direction) {
    return Error(`Popover direction "${direction}" is invalid.`);
}
export class NxPopoverTriggerDirective {
    constructor(overlay, elementRef, viewContainerRef, eventManager, _focusTrapFactory, _focusMonitor, _ngZone, _platform, _dir, _defaultScrollStrategyFactory, _cdr) {
        this.overlay = overlay;
        this.elementRef = elementRef;
        this.viewContainerRef = viewContainerRef;
        this.eventManager = eventManager;
        this._focusTrapFactory = _focusTrapFactory;
        this._focusMonitor = _focusMonitor;
        this._ngZone = _ngZone;
        this._platform = _platform;
        this._dir = _dir;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this._cdr = _cdr;
        this._overlayDestroyed = new Subject();
        this._show = false;
        this._closeable = null;
        this._modal = false;
        /** Element that was focused before the Popover was opened. Save this to restore upon close. */
        this._elementFocusedBeforePopoverWasOpened = null;
        this._manualListeners = new Map();
        this._possiblePopoverDirections = ['bottom', 'top', 'left', 'right'];
        this.closeOnLeftViewport = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if (!entry.isIntersecting) {
                    this._ngZone.run(() => this.overlayRef?.detach());
                }
                this.closeOnLeftViewport.disconnect();
            });
        }, { threshold: 0.2 });
        /** @docs-private */
        this.id = 'nx-popover-' + nextId++;
        /** An event is emitted if the visibility status of the popover changes. */
        this.changeShow = new EventEmitter();
        this._closeOnClickOutside = true;
        /** Sets the desired direction to open the popover. E.g., right, left, bottom, top */
        this.direction = 'right';
        /** Whether the popover will be opened automatically. */
        this.popoverInitialVisible = false;
        /** An event is emitted when the visibility of the popopver changes. */
        this.visibleChange = new EventEmitter();
        // If nxPopoverTrigger equals to 'hover' the popover opens on mouseenter and closes on mouseout.
        // If nxPopoverTrigger equals to 'click' the popover opens on click and closes on a click of the close icon or pressing ESC key.
        // If nxPopoverTrigger equals to 'manual' the popover opens only when programatically requested.
        /** Sets the way to trigger the popover. Options are hover, click, manual */
        this.trigger = 'click';
        _NxPopoverTriggerDirective_scrollStrategy.set(this, void 0);
        this._destroyed = new Subject();
        /** Strategy factory that will be used to handle scrolling while the popover panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
        const element = elementRef.nativeElement;
        if (!this._platform.IOS && !this._platform.ANDROID) {
            this._manualListeners
                .set('mouseenter', () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            })
                .set('mouseleave', () => {
                if (this.trigger === 'hover') {
                    this.show = false;
                }
            })
                .set('keydown', (event) => {
                switch (event.keyCode) {
                    case SPACE:
                    case ENTER:
                        this.handleClick();
                        break;
                    default:
                }
            });
        }
        else {
            this._manualListeners.set('touchstart', () => {
                if (this.trigger === 'hover') {
                    this.show = true;
                }
            });
        }
        this._manualListeners.forEach((listener, event) => element.addEventListener(event, listener));
        this._focusMonitor
            .monitor(element)
            .pipe(takeUntil(this._destroyed))
            .subscribe(origin => {
            if (origin === 'keyboard' && this.trigger === 'hover') {
                this._ngZone.run(() => (this.show = true));
            }
        });
        this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(this._dirChangeHandler.bind(this));
    }
    /** Whether to show or hide the popover. */
    set show(value) {
        value = coerceBooleanProperty(value);
        if (this._show !== value) {
            this._show = value;
            if (this._show) {
                this.openPopover();
            }
            else {
                this.closePopover();
            }
        }
    }
    get show() {
        return this._show;
    }
    /** Whether to show a close button. By default a close icon is only shown for trigger type click. */
    set closeable(value) {
        this._closeable = coerceBooleanProperty(value);
        if (this.popover) {
            this.popover.showCloseButton = this.isCloseable();
        }
    }
    get closeable() {
        return this._closeable;
    }
    /** Whether the popover should be closed on click outside of the popover in the trigger modes 'manual' and 'click'. */
    set closeOnClickOutside(value) {
        this._closeOnClickOutside = coerceBooleanProperty(value);
    }
    get closeOnClickOutside() {
        return this._closeOnClickOutside;
    }
    /** Whether the popover opens in modal state. */
    set modal(value) {
        this._modal = coerceBooleanProperty(value);
    }
    get modal() {
        return this._modal;
    }
    /** Sets the scroll strategy. 'close' closes the popover on scroll while 'reposition' scrolls the popover with the origin. */
    set scrollStrategy(value) {
        if (__classPrivateFieldGet(this, _NxPopoverTriggerDirective_scrollStrategy, "f") !== value) {
            __classPrivateFieldSet(this, _NxPopoverTriggerDirective_scrollStrategy, value, "f");
            this._scrollStrategyFactory = value ? this.getScrollStrategyFactory(value) : this._defaultScrollStrategyFactory;
            this._cdr.markForCheck();
        }
    }
    get scrollStrategy() {
        return __classPrivateFieldGet(this, _NxPopoverTriggerDirective_scrollStrategy, "f");
    }
    ngOnInit() {
        this.popover.showCloseButton = this.isCloseable();
    }
    ngAfterViewInit() {
        this.popover.id = this.id;
        this._removeEventListener = this.eventManager.addGlobalEventListener('window', 'keyup.esc', () => {
            if (this.isOpen) {
                this.show = false;
            }
        });
        this.popover.closeButtonClick.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this.show = false;
        });
        if (this.popoverInitialVisible || this._show) {
            this.show = true;
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this.show = false;
        this._removeEventListener();
        this._focusMonitor.stopMonitoring(this.elementRef.nativeElement);
        // Clean up the event listeners set in the constructor
        this._manualListeners.forEach((listener, event) => {
            this.elementRef.nativeElement.removeEventListener(event, listener);
        });
        if (this.overlayRef) {
            this.overlayRef.dispose();
        }
        this._manualListeners.clear();
        this._overlayDestroyed.next();
        this._overlayDestroyed.complete();
    }
    /** @docs-private */
    get isOpen() {
        return this.overlayRef && this.createOverlay().hasAttached();
    }
    /** @docs-private */
    isCloseable() {
        return (this.trigger === 'click' && this._closeable === null) || !!this._closeable;
    }
    /** Update the popover with the given position strategy. */
    updatePosition() {
        if (this._positionStrategy) {
            this._positionStrategy.apply();
        }
    }
    /** @docs-private */
    handleClick() {
        if (this.trigger === 'click') {
            this.show = !this.isOpen;
        }
        else if (this.trigger === 'hover') {
            this.show = true;
        }
    }
    /** Open the popover instance. */
    open() {
        this.show = true;
    }
    /** Close the popover instance. */
    close() {
        this.show = false;
    }
    /** Toggle the popover instance. */
    toggle() {
        this.show = !this.show;
    }
    openPopover() {
        if (!this.createOverlay().hasAttached()) {
            this._embeddedViewRef = this.createOverlay().attach(this.portal);
            const element = this.getPopoverContainer();
            this._focusTrap = this._focusTrapFactory.create(element);
            this._elementFocusedBeforePopoverWasOpened = this.elementRef.nativeElement;
            this._focusMonitor.monitor(element.querySelector('.nx-popover__content'));
            const closeIcon = element.querySelector('.nx-popover__close-icon');
            if (closeIcon) {
                this._focusMonitor.monitor(closeIcon);
            }
            this._autoFocusFirstTabbableElement(element);
            // attach a close click listener only if it makes sense (ignore it on hover e.g.)
            if (this.closeOnClickOutside) {
                this.waitForClose();
            }
        }
    }
    /**
     * Autofocus the first tabbable element inside of the popover, if there is not a tabbable element,
     * focus the popover instead.
     */
    _autoFocusFirstTabbableElement(element) {
        this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {
            // If we didn't find any focusable elements inside the popover, focus the
            // container so the user can't tab into other elements behind it.
            if (!hasMovedFocus) {
                element.focus();
            }
        });
    }
    // detaches the overlay
    // we are listening to the detachments observable which will then emit the nxClosed event
    // on the popover component
    closePopover() {
        if (this.overlayRef.hasAttached()) {
            const element = this.getPopoverContainer();
            this._focusMonitor.stopMonitoring(element.querySelector('.nx-popover__content'));
            this._focusMonitor.stopMonitoring(element.querySelector('.nx-popover__close-icon'));
            this._returnFocusAfterPopover();
            this.overlayRef.detach();
            this._embeddedViewRef = null;
            this._focusTrap.destroy();
        }
    }
    getScrollStrategyFactory(scrollStrategy) {
        switch (scrollStrategy) {
            case 'reposition':
                return this.overlay.scrollStrategies.reposition;
            default:
                return this.overlay.scrollStrategies.close;
        }
    }
    createOverlay() {
        if (!this.overlayRef) {
            this.portal = new TemplatePortal(this.popover.templateRef, this.viewContainerRef);
            const overlayState = new OverlayConfig();
            overlayState.positionStrategy = this.getPosition();
            this._positionStrategy = overlayState.positionStrategy;
            overlayState.scrollStrategy = this._scrollStrategyFactory();
            overlayState.scrollStrategy.enable();
            overlayState.direction = this._dir?.value || 'ltr';
            if (this._modal) {
                overlayState.hasBackdrop = true;
            }
            this.overlayRef = this.overlay.create(overlayState);
            this.subscribeToPositions(overlayState.positionStrategy);
            this._subscribeToAttach();
            this._subscribeToDetach();
            if (this._modal && this._closeOnClickOutside) {
                this._subscribeToBackdropClick();
            }
        }
        return this.overlayRef;
    }
    subscribeToPositions(position) {
        position.positionChanges.pipe(takeUntil(this._overlayDestroyed)).subscribe(change => {
            const pair = change.connectionPair;
            this.positionOverlay(pair);
            this.positionArrow(pair);
            this.closeOnLeftViewport.observe(this.elementRef.nativeElement);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        });
    }
    // for modal popovers close the popover on backdrop clicks
    _subscribeToBackdropClick() {
        this.overlayRef.backdropClick()
            .pipe(takeUntil(this._overlayDestroyed))
            .subscribe(event => {
            this.show = false;
        });
    }
    // Emit the nxClosed and the show status change event on the popover component when the overlay detaches
    _subscribeToDetach() {
        this.overlayRef.detachments()
            .pipe(takeUntil(this._overlayDestroyed))
            .subscribe(data => {
            // This is an exception: when the popover is closed by a scrolling event,
            // then only the detached method is called but the show state variable remains unchanged.
            if (this.show) {
                this.show = false;
            }
            this.changeShow.emit(this._show);
            this.popover.emitClosedEvent();
        });
    }
    _subscribeToAttach() {
        this.overlayRef.attachments()
            .pipe(takeUntil(this._overlayDestroyed))
            .subscribe(data => {
            this.changeShow.emit(this._show);
        });
    }
    // subscribe to document clicks when trigger='click' to close the popover on clicks on the background
    waitForClose() {
        return this.overlayRef.outsidePointerEvents()
            .pipe(map(event => event.target), filter(target => !this.elementRef.nativeElement.contains(target)), takeUntil(this.popover.closed))
            .subscribe(() => {
            this.show = false;
        });
    }
    positionOverlay(pair) {
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this.popover.direction = this.isRtl ? 'left' : 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this.popover.direction = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this.popover.direction = this.isRtl ? 'right' : 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this.popover.direction = 'top';
        }
    }
    positionArrow(pair) {
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        const parentElementLeftOffset = this.overlayRef.overlayElement.parentElement.offsetLeft;
        const overlayElementLeftOffset = this.overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        const targetPosition = parentElementPositionX + parentElementWidth - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originX === pair.overlayX) {
            const direction = 'left';
            const arrowStyle = { left: '0' };
            arrowStyle[direction] = targetPosition + 'px';
            this.popover.arrowStyle = arrowStyle;
        }
        if ((pair.originY === 'bottom' || pair.originY === 'top') && pair.overlayX === 'center') {
            this.popover.arrowStyle = { left: targetPosition + 'px' };
        }
        if ((pair.originX === 'end' || pair.originX === 'start') && pair.overlayY === 'center') {
            this.popover.arrowStyle = { top: '50%' };
        }
    }
    getPosition() {
        const origin = this._getOrigin(this.direction);
        const overlay = this._getOverlayPosition(this.direction);
        const offset = this._getOffset(this.direction);
        const fallbacks = this._getFallbackPositions(this.direction);
        return this.overlay
            .position()
            .flexibleConnectedTo(this.elementRef)
            .withPositions([
            {
                ...origin,
                ...overlay,
                ...offset,
            },
            ...fallbacks,
        ])
            .withFlexibleDimensions(false);
    }
    /** Returns the focus to the element focused before the Popover was open. */
    _returnFocusAfterPopover() {
        const toFocus = this._elementFocusedBeforePopoverWasOpened;
        // We need the extra check, because IE can set the `activeElement` to null in some cases.
        if (toFocus && typeof toFocus.focus === 'function') {
            toFocus.focus();
        }
    }
    /** Returns the main popover container of the injected content. */
    getPopoverContainer() {
        return this.overlayRef.overlayElement.querySelector('.nx-popover');
    }
    /**
     * Returns the origin position based on the user's direction preference.
     */
    _getOrigin(direction) {
        switch (direction) {
            case 'top':
            case 'bottom': {
                return {
                    originX: 'center',
                    originY: direction,
                };
            }
            case 'left': {
                return {
                    originX: this.isRtl ? 'end' : 'start',
                    originY: 'center',
                };
            }
            case 'right': {
                return {
                    originX: this.isRtl ? 'start' : 'end',
                    originY: 'center',
                };
            }
            default: {
                throw getNxPopoverInvalidDirectionError(direction);
            }
        }
    }
    /** Returns the overlay position based on the user's direction preference */
    _getOverlayPosition(direction) {
        switch (direction) {
            case 'top':
            case 'bottom': {
                return {
                    overlayX: 'center',
                    overlayY: this._getInversePosition(direction),
                };
            }
            case 'left': {
                return {
                    overlayX: this.isRtl ? 'start' : 'end',
                    overlayY: 'center',
                };
            }
            case 'right': {
                return {
                    overlayX: this.isRtl ? 'end' : 'start',
                    overlayY: 'center',
                };
            }
            default: {
                throw getNxPopoverInvalidDirectionError(direction);
            }
        }
    }
    /** Returns the overlay offset required by the user's direction preference */
    _getOffset(direction) {
        switch (direction) {
            case 'top': {
                return {
                    offsetY: BASE_OFFSET * -1,
                };
            }
            case 'bottom': {
                return {
                    offsetY: BASE_OFFSET,
                };
            }
            case 'left': {
                return {
                    offsetX: BASE_OFFSET * -1,
                };
            }
            case 'right': {
                return {
                    offsetX: BASE_OFFSET,
                };
            }
            default: {
                throw getNxPopoverInvalidDirectionError(direction);
            }
        }
    }
    /** Returns the opposite direction, using aquila popover direction naming: top, right, bottom, left */
    _getInversePopoverDirection(direction) {
        const popoverDirectionPairs = {
            top: 'bottom',
            right: 'left',
            bottom: 'top',
            left: 'right',
        };
        return popoverDirectionPairs[direction];
    }
    /** Returns the opposite position, using angular position naming: top, bottom, start, end, center */
    _getInversePosition(position) {
        const positionPairs = {
            top: 'bottom',
            bottom: 'top',
            start: 'end',
            end: 'start',
            center: 'center',
        };
        return positionPairs[position];
    }
    /** Returns an array of fallback positions for popover, following the algoritm:
     * 1) Slightly alternate preferred position if applicable. I.e. for 'top' try 'top-start' and 'top-end' positioning.
     * 2) Try the opposite position, i.e. for 'top' try 'bottom'.
     * 3) Slightly alternate opposite position, i.e. 'bottom-start', 'bottom-end'
     * 4) All remaining positions from positions list
     */
    _getFallbackPositions(direction, possibleDirections = this._possiblePopoverDirections) {
        if (!direction) {
            return [];
        }
        const remainigDirections = possibleDirections.filter(possibleDirection => possibleDirection !== direction);
        let fallbackPositions = [];
        switch (direction) {
            case 'top':
            case 'bottom': {
                fallbackPositions = this._getVerticalFallbackPositionPairs(direction);
                break;
            }
            case 'left':
            case 'right': {
                fallbackPositions = this._getHorizontalFallbackPositionPairs(direction);
                break;
            }
        }
        const inverseDirection = this._getInversePopoverDirection(direction);
        const nextFallbackPosition = remainigDirections.includes(inverseDirection) ? inverseDirection : possibleDirections[0];
        return [...fallbackPositions, ...this._getFallbackPositions(nextFallbackPosition, remainigDirections)];
    }
    /** Calculates fallbacks for vertical popover positioning */
    _getVerticalFallbackPositionPairs(direction) {
        const isSelectedDirection = direction === this.direction;
        const verticalFallbackPositionPairs = [];
        const basePositionPair = {
            ...this._getOrigin(direction),
            ...this._getOverlayPosition(direction),
            ...this._getOffset(direction),
        };
        if (!isSelectedDirection) {
            // HINT: selected direction matches basePosition, so we don't need to repeat it in fallback
            verticalFallbackPositionPairs.push(basePositionPair);
        }
        verticalFallbackPositionPairs.push({
            ...basePositionPair,
            originX: 'start',
            overlayX: 'start',
        }, {
            ...basePositionPair,
            originX: 'end',
            overlayX: 'end',
        });
        return verticalFallbackPositionPairs;
    }
    /** Calculates fallbacks for horizontal popover positioning */
    _getHorizontalFallbackPositionPairs(direction) {
        const offset = this._getOffset(direction);
        return [
            {
                ...this._getOrigin(direction),
                ...this._getOverlayPosition(direction),
                ...offset,
            },
        ];
    }
    _dirChangeHandler() {
        if (this.overlayRef) {
            this.closePopover();
            this.overlayRef.dispose();
            this.overlayRef = null;
            this._overlayDestroyed.next();
        }
    }
    get isRtl() {
        return this._dir?.value === 'rtl';
    }
}
_NxPopoverTriggerDirective_scrollStrategy = new WeakMap();
NxPopoverTriggerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverTriggerDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.EventManager }, { token: i3.FocusTrapFactory }, { token: i3.FocusMonitor }, { token: i0.NgZone }, { token: i4.Platform }, { token: i5.Directionality, optional: true }, { token: NX_POPOVER_SCROLL_STRATEGY }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
NxPopoverTriggerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxPopoverTriggerDirective, selector: "[nxPopoverTriggerFor]", inputs: { show: ["nxPopoverShow", "show"], closeable: ["nxPopoverCloseable", "closeable"], closeOnClickOutside: "closeOnClickOutside", popover: ["nxPopoverTriggerFor", "popover"], direction: ["nxPopoverDirection", "direction"], popoverInitialVisible: ["nxPopoverInitialVisible", "popoverInitialVisible"], visibleChange: ["nxPopoverVisibleChange", "visibleChange"], modal: ["nxPopoverModal", "modal"], trigger: ["nxPopoverTrigger", "trigger"], scrollStrategy: ["nxPopoverScrollStrategy", "scrollStrategy"] }, outputs: { changeShow: "nxPopoverShowChange" }, host: { attributes: { "aria-haspopup": "true" }, listeners: { "click": "handleClick()" }, properties: { "attr.aria-expanded": "isOpen", "attr.aria-describedby": "isOpen ? id : null" } }, exportAs: ["nxPopoverTrigger"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxPopoverTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxPopoverTriggerFor]',
                    exportAs: 'nxPopoverTrigger',
                    host: {
                        '(click)': 'handleClick()',
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'isOpen',
                        '[attr.aria-describedby]': 'isOpen ? id : null',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.EventManager }, { type: i3.FocusTrapFactory }, { type: i3.FocusMonitor }, { type: i0.NgZone }, { type: i4.Platform }, { type: i5.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NX_POPOVER_SCROLL_STRATEGY]
                }] }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { changeShow: [{
                type: Output,
                args: ['nxPopoverShowChange']
            }], show: [{
                type: Input,
                args: ['nxPopoverShow']
            }], closeable: [{
                type: Input,
                args: ['nxPopoverCloseable']
            }], closeOnClickOutside: [{
                type: Input
            }], popover: [{
                type: Input,
                args: ['nxPopoverTriggerFor']
            }], direction: [{
                type: Input,
                args: ['nxPopoverDirection']
            }], popoverInitialVisible: [{
                type: Input,
                args: ['nxPopoverInitialVisible']
            }], visibleChange: [{
                type: Input,
                args: ['nxPopoverVisibleChange']
            }], modal: [{
                type: Input,
                args: ['nxPopoverModal']
            }], trigger: [{
                type: Input,
                args: ['nxPopoverTrigger']
            }], scrollStrategy: [{
                type: Input,
                args: ['nxPopoverScrollStrategy']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9wb3Zlci10cmlnZ2VyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWFxdWlsYS9zcmMvcG9wb3Zlci9wb3BvdmVyLXRyaWdnZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsT0FBTyxFQUFnQixxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVFLE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDckQsT0FBTyxFQUtILE9BQU8sRUFDUCxhQUFhLEdBTWhCLE1BQU0sc0JBQXNCLENBQUM7QUFFOUIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JELE9BQU8sRUFHSCxTQUFTLEVBR1QsWUFBWSxFQUNaLE1BQU0sRUFDTixjQUFjLEVBQ2QsS0FBSyxFQUlMLFFBQVEsRUFDUixNQUFNLEdBRVQsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7OztBQVV4RCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDZixNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFFdkIsbUZBQW1GO0FBQ25GLE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFHLElBQUksY0FBYyxDQUF1Qiw0QkFBNEIsQ0FBQyxDQUFDO0FBRWpILG9CQUFvQjtBQUNwQixNQUFNLFVBQVUsMkNBQTJDLENBQUMsT0FBZ0I7SUFDeEUsT0FBTyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLENBQUM7QUFDbEQsQ0FBQztBQUVELG9CQUFvQjtBQUNwQixNQUFNLENBQUMsTUFBTSxtQ0FBbUMsR0FBRztJQUMvQyxPQUFP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OzswQkFDUixNQUFNOzJCQUFDLDBCQUEwQjs0RUF6R3RDLFVBQVU7c0JBRFQsTUFBTTt1QkFBQyxxQkFBcUI7Z0JBS3pCLElBQUk7c0JBRFAsS0FBSzt1QkFBQyxlQUFlO2dCQW1CbEIsU0FBUztzQkFEWixLQUFLO3VCQUFDLG9CQUFvQjtnQkFjdkIsbUJBQW1CO3NCQUR0QixLQUFLO2dCQVlOLE9BQU87c0JBRE4sS0FBSzt1QkFBQyxxQkFBcUI7Z0JBSzVCLFNBQVM7c0JBRFIsS0FBSzt1QkFBQyxvQkFBb0I7Z0JBSzNCLHFCQUFxQjtzQkFEcEIsS0FBSzt1QkFBQyx5QkFBeUI7Z0JBS2hDLGFBQWE7c0JBRFosS0FBSzt1QkFBQyx3QkFBd0I7Z0JBSzNCLEtBQUs7c0JBRFIsS0FBSzt1QkFBQyxnQkFBZ0I7Z0JBYXZCLE9BQU87c0JBRE4sS0FBSzt1QkFBQyxrQkFBa0I7Z0JBS3JCLGNBQWM7c0JBRGpCLEtBQUs7dUJBQUMseUJBQXlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRm9jdXNNb25pdG9yLCBGb2N1c1RyYXAsIEZvY3VzVHJhcEZhY3RvcnkgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IEJvb2xlYW5JbnB1dCwgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7IEVOVEVSLCBTUEFDRSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQge1xuICAgIENvbm5lY3Rpb25Qb3NpdGlvblBhaXIsXG4gICAgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LFxuICAgIEhvcml6b250YWxDb25uZWN0aW9uUG9zLFxuICAgIE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbixcbiAgICBPdmVybGF5LFxuICAgIE92ZXJsYXlDb25maWcsXG4gICAgT3ZlcmxheUNvbm5lY3Rpb25Qb3NpdGlvbixcbiAgICBPdmVybGF5UmVmLFxuICAgIFBvc2l0aW9uU3RyYXRlZ3ksXG4gICAgU2Nyb2xsU3RyYXRlZ3ksXG4gICAgVmVydGljYWxDb25uZWN0aW9uUG9zLFxufSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEVtYmVkZGVkVmlld1JlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSW5qZWN0LFxuICAgIEluamVjdGlvblRva2VuLFxuICAgIElucHV0LFxuICAgIE5nWm9uZSxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEV2ZW50TWFuYWdlciB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBtYXAsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnhQb3BvdmVyQ29tcG9uZW50IH0gZnJvbSAnLi9wb3BvdmVyLmNvbXBvbmVudCc7XG5cbmV4cG9ydCBkZWNsYXJlIHR5cGUgUG9wb3ZlclZlcnRpY2FsRGlyZWN0aW9uID0gJ3RvcCcgfCAnYm90dG9tJztcbmV4cG9ydCBkZWNsYXJlIHR5cGUgUG9wb3Zlckhvcml6b250YWxEaXJlY3Rpb24gPSAnbGVmdCcgfCAncmlnaHQnO1xuZXhwb3J0IGRlY2xhcmUgdHlwZSBQb3BvdmVyRGlyZWN0aW9uID0gUG9wb3Zlckhvcml6b250YWxEaXJlY3Rpb24gfCBQb3BvdmVyVmVydGljYWxEaXJlY3Rpb247XG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJUcmlnZ2VyVHlwZSA9ICdjbGljaycgfCAnaG92ZXInIHwgJ21hbnVhbCc7XG5leHBvcnQgZGVjbGFyZSB0eXBlIFBvcG92ZXJUcmlnZ2VyU2Nyb2xsU3RyYXRlZ3kgPSAnY2xvc2UnIHwgJ3JlcG9zaXRpb24nO1xuXG5sZXQgbmV4dElkID0gMDtcbmNvbnN0IEJBU0VfT0ZGU0VUID0gMTY7XG5cbi8qKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBkZXRlcm1pbmVzIHRoZSBzY3JvbGwgaGFuZGxpbmcgd2hpbGUgYSBwb3BvdmVyIGlzIG9wZW4uICovXG5leHBvcnQgY29uc3QgTlhfUE9QT1ZFUl9TQ1JPTExfU1RSQVRFR1kgPSBuZXcgSW5qZWN0aW9uVG9rZW48KCkgPT4gU2Nyb2xsU3RyYXRlZ3k+KCdueC1wb3BvdmVyLXNjcm9sbC1zdHJhdGVneScpO1xuXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIE5YX1BPUE9WRVJfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSX0ZBQ1RPUlkob3ZlcmxheTogT3ZlcmxheSk6ICgpID0+IFNjcm9sbFN0cmF0ZWd5IHtcbiAgICByZXR1cm4gKCkgPT4gb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLmNsb3NlKCk7XG59XG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgY29uc3QgTlhfUE9QT1ZFUl9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVIgPSB7XG4gICAgcHJvdmlkZTogTlhfUE9QT1ZFUl9TQ1JPTExfU1RSQVRFR1ksXG4gICAgdXNlRmFjdG9yeTogTlhfUE9QT1ZFUl9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVJfRkFDVE9SWSxcbiAgICBkZXBzOiBbT3ZlcmxheV0sXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIGlmIHRoZSB1c2VyIHByb3ZpZGVkIGFuIGludmFsaWQgcG9wb3ZlciBkaXJlY3Rpb24uXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROeFBvcG92ZXJJbnZhbGlkRGlyZWN0aW9uRXJyb3IoZGlyZWN0aW9uOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gRXJyb3IoYFBvcG92ZXIgZGlyZWN0aW9uIFwiJHtkaXJlY3Rpb259XCIgaXMgaW52YWxpZC5gKTtcbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbbnhQb3BvdmVyVHJpZ2dlckZvcl0nLFxuICAgIGV4cG9ydEFzOiAnbnhQb3BvdmVyVHJpZ2dlcicsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGNsaWNrKSc6ICdoYW5kbGVDbGljaygpJyxcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiAndHJ1ZScsXG4gICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdpc09wZW4nLFxuICAgICAgICAnW2F0dHIuYXJpYS1kZXNjcmliZWRieV0nOiAnaXNPcGVuID8gaWQgOiBudWxsJyxcbiAgICB9LFxufSlcbmV4cG9ydCBjbGFzcyBOeFBvcG92ZXJUcmlnZ2VyRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95LCBPbkluaXQge1xuICAgIHByaXZhdGUgb3ZlcmxheVJlZiE6IE92ZXJsYXlSZWYgfCBudWxsO1xuICAgIHByaXZhdGUgcG9ydGFsITogVGVtcGxhdGVQb3J0YWw8YW55PjtcbiAgICBwcml2YXRlIF9vdmVybGF5RGVzdHJveWVkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwcml2YXRlIF9zaG93ID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfY2xvc2VhYmxlOiBib29sZWFuIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfcG9zaXRpb25TdHJhdGVneSE6IFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgcHJpdmF0ZSBfZW1iZWRkZWRWaWV3UmVmITogRW1iZWRkZWRWaWV3UmVmPGFueT4gfCBudWxsO1xuICAgIHByaXZhdGUgX21vZGFsID0gZmFsc2U7XG4gICAgLyoqIFRoZSBjbGFzcyB0aGF0IHRyYXBzIGFuZCBtYW5hZ2VzIGZvY3VzIHdpdGhpbiB0aGUgcG9wb3Zlci4gKi9cbiAgICBwcml2YXRlIF9mb2N1c1RyYXAhOiBGb2N1c1RyYXA7XG4gICAgLyoqIEVsZW1lbnQgdGhhdCB3YXMgZm9jdXNlZCBiZWZvcmUgdGhlIFBvcG92ZXIgd2FzIG9wZW5lZC4gU2F2ZSB0aGlzIHRvIHJlc3RvcmUgdXBvbiBjbG9zZS4gKi9cbiAgICBwcml2YXRlIF9lbGVtZW50Rm9jdXNlZEJlZm9yZVBvcG92ZXJXYXNPcGVuZWQ6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfbWFudWFsTGlzdGVuZXJzID0gbmV3IE1hcDxzdHJpbmcsIEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3Q+KCk7XG4gICAgcHJpdmF0ZSBfcG9zc2libGVQb3BvdmVyRGlyZWN0aW9uczogUG9wb3ZlckRpcmVjdGlvbltdID0gWydib3R0b20nLCAndG9wJywgJ2xlZnQnLCAncmlnaHQnXTtcbiAgICBwcml2YXRlIF9yZW1vdmVFdmVudExpc3RlbmVyITogKCkgPT4gdm9pZDtcblxuICAgIGNsb3NlT25MZWZ0Vmlld3BvcnQgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoXG4gICAgICAgIGVudHJpZXMgPT4ge1xuICAgICAgICAgICAgZW50cmllcy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5vdmVybGF5UmVmPy5kZXRhY2goKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VPbkxlZnRWaWV3cG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgeyB0aHJlc2hvbGQ6IDAuMiB9LFxuICAgICk7XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGlkID0gJ254LXBvcG92ZXItJyArIG5leHRJZCsrO1xuXG4gICAgLyoqIEFuIGV2ZW50IGlzIGVtaXR0ZWQgaWYgdGhlIHZpc2liaWxpdHkgc3RhdHVzIG9mIHRoZSBwb3BvdmVyIGNoYW5nZXMuICovXG4gICAgQE91dHB1dCgnbnhQb3BvdmVyU2hvd0NoYW5nZScpXG4gICAgY2hhbmdlU2hvdzogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIFdoZXRoZXIgdG8gc2hvdyBvciBoaWRlIHRoZSBwb3BvdmVyLiAqL1xuICAgIEBJbnB1dCgnbnhQb3BvdmVyU2hvdycpXG4gICAgc2V0IHNob3codmFsdWU6IEJvb2xlYW5JbnB1dCkge1xuICAgICAgICB2YWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9zaG93ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvdyA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Qb3BvdmVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2hvdygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Nob3c7XG4gICAgfVxuXG4gICAgLyoqIFdoZXRoZXIgdG8gc2hvdyBhIGNsb3NlIGJ1dHRvbi4gQnkgZGVmYXVsdCBhIGNsb3NlIGljb24gaXMgb25seSBzaG93biBmb3IgdHJpZ2dlciB0eXBlIGNsaWNrLiAqL1xuICAgIEBJbnB1dCgnbnhQb3BvdmVyQ2xvc2VhYmxlJylcbiAgICBzZXQgY2xvc2VhYmxlKHZhbHVlOiBCb29sZWFuSW5wdXQpIHtcbiAgICAgICAgdGhpcy5fY2xvc2VhYmxlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5wb3BvdmVyKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuc2hvd0Nsb3NlQnV0dG9uID0gdGhpcy5pc0Nsb3NlYWJsZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjbG9zZWFibGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWFibGUgYXMgYm9vbGVhbjtcbiAgICB9XG5cbiAgICAvKiogV2hldGhlciB0aGUgcG9wb3ZlciBzaG91bGQgYmUgY2xvc2VkIG9uIGNsaWNrIG91dHNpZGUgb2YgdGhlIHBvcG92ZXIgaW4gdGhlIHRyaWdnZXIgbW9kZXMgJ21hbnVhbCcgYW5kICdjbGljaycuICovXG4gICAgQElucHV0KClcbiAgICBzZXQgY2xvc2VPbkNsaWNrT3V0c2lkZSh2YWx1ZTogQm9vbGVhbklucHV0KSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlT25DbGlja091dHNpZGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgY2xvc2VPbkNsaWNrT3V0c2lkZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlT25DbGlja091dHNpZGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2xvc2VPbkNsaWNrT3V0c2lkZSA9IHRydWU7XG5cbiAgICAvKiogTGlua3MgdGhlIHRyaWdnZXIgd2l0aCB0aGUgcG9wb3ZlciB0byBvcGVuLiAqL1xuICAgIEBJbnB1dCgnbnhQb3BvdmVyVHJpZ2dlckZvcicpXG4gICAgcG9wb3ZlciE6IE54UG9wb3ZlckNvbXBvbmVudDtcblxuICAgIC8qKiBTZXRzIHRoZSBkZXNpcmVkIGRpcmVjdGlvbiB0byBvcGVuIHRoZSBwb3BvdmVyLiBFLmcuLCByaWdodCwgbGVmdCwgYm90dG9tLCB0b3AgKi9cbiAgICBASW5wdXQoJ254UG9wb3ZlckRpcmVjdGlvbicpXG4gICAgZGlyZWN0aW9uOiBQb3BvdmVyRGlyZWN0aW9uID0gJ3JpZ2h0JztcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBwb3BvdmVyIHdpbGwgYmUgb3BlbmVkIGF1dG9tYXRpY2FsbHkuICovXG4gICAgQElucHV0KCdueFBvcG92ZXJJbml0aWFsVmlzaWJsZScpXG4gICAgcG9wb3ZlckluaXRpYWxWaXNpYmxlID0gZmFsc2U7XG5cbiAgICAvKiogQW4gZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHRoZSB2aXNpYmlsaXR5IG9mIHRoZSBwb3BvcHZlciBjaGFuZ2VzLiAqL1xuICAgIEBJbnB1dCgnbnhQb3BvdmVyVmlzaWJsZUNoYW5nZScpXG4gICAgdmlzaWJsZUNoYW5nZTogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqIFdoZXRoZXIgdGhlIHBvcG92ZXIgb3BlbnMgaW4gbW9kYWwgc3RhdGUuICovXG4gICAgQElucHV0KCdueFBvcG92ZXJNb2RhbCcpXG4gICAgc2V0IG1vZGFsKHZhbHVlOiBCb29sZWFuSW5wdXQpIHtcbiAgICAgICAgdGhpcy5fbW9kYWwgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbW9kYWwoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RhbDtcbiAgICB9XG5cbiAgICAvLyBJZiBueFBvcG92ZXJUcmlnZ2VyIGVxdWFscyB0byAnaG92ZXInIHRoZSBwb3BvdmVyIG9wZW5zIG9uIG1vdXNlZW50ZXIgYW5kIGNsb3NlcyBvbiBtb3VzZW91dC5cbiAgICAvLyBJZiBueFBvcG92ZXJUcmlnZ2VyIGVxdWFscyB0byAnY2xpY2snIHRoZSBwb3BvdmVyIG9wZW5zIG9uIGNsaWNrIGFuZCBjbG9zZXMgb24gYSBjbGljayBvZiB0aGUgY2xvc2UgaWNvbiBvciBwcmVzc2luZyBFU0Mga2V5LlxuICAgIC8vIElmIG54UG9wb3ZlclRyaWdnZXIgZXF1YWxzIHRvICdtYW51YWwnIHRoZSBwb3BvdmVyIG9wZW5zIG9ubHkgd2hlbiBwcm9ncmFtYXRpY2FsbHkgcmVxdWVzdGVkLlxuICAgIC8qKiBTZXRzIHRoZSB3YXkgdG8gdHJpZ2dlciB0aGUgcG9wb3Zlci4gT3B0aW9ucyBhcmUgaG92ZXIsIGNsaWNrLCBtYW51YWwgKi9cbiAgICBASW5wdXQoJ254UG9wb3ZlclRyaWdnZXInKVxuICAgIHRyaWdnZXI6IFBvcG92ZXJUcmlnZ2VyVHlwZSA9ICdjbGljayc7XG5cbiAgICAvKiogU2V0cyB0aGUgc2Nyb2xsIHN0cmF0ZWd5LiAnY2xvc2UnIGNsb3NlcyB0aGUgcG9wb3ZlciBvbiBzY3JvbGwgd2hpbGUgJ3JlcG9zaXRpb24nIHNjcm9sbHMgdGhlIHBvcG92ZXIgd2l0aCB0aGUgb3JpZ2luLiAqL1xuICAgIEBJbnB1dCgnbnhQb3BvdmVyU2Nyb2xsU3RyYXRlZ3knKVxuICAgIHNldCBzY3JvbGxTdHJhdGVneSh2YWx1ZTogUG9wb3ZlclRyaWdnZXJTY3JvbGxTdHJhdGVneSB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHRoaXMuI3Njcm9sbFN0cmF0ZWd5ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy4jc2Nyb2xsU3RyYXRlZ3kgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFN0cmF0ZWd5RmFjdG9yeSA9IHZhbHVlID8gdGhpcy5nZXRTY3JvbGxTdHJhdGVneUZhY3RvcnkodmFsdWUpIDogdGhpcy5fZGVmYXVsdFNjcm9sbFN0cmF0ZWd5RmFjdG9yeTtcbiAgICAgICAgICAgIHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2Nyb2xsU3RyYXRlZ3koKTogUG9wb3ZlclRyaWdnZXJTY3JvbGxTdHJhdGVneSB8IG51bGwgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2Nyb2xsU3RyYXRlZ3k7XG4gICAgfVxuICAgICNzY3JvbGxTdHJhdGVneT86IFBvcG92ZXJUcmlnZ2VyU2Nyb2xsU3RyYXRlZ3kgfCBudWxsO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBfZGVzdHJveWVkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBTdHJhdGVneSBmYWN0b3J5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGhhbmRsZSBzY3JvbGxpbmcgd2hpbGUgdGhlIHBvcG92ZXIgcGFuZWwgaXMgb3Blbi4gKi9cbiAgICBwcml2YXRlIF9zY3JvbGxTdHJhdGVneUZhY3RvcnkgPSB0aGlzLl9kZWZhdWx0U2Nyb2xsU3RyYXRlZ3lGYWN0b3J5O1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByaXZhdGUgZXZlbnRNYW5hZ2VyOiBFdmVudE1hbmFnZXIsXG4gICAgICAgIHByaXZhdGUgX2ZvY3VzVHJhcEZhY3Rvcnk6IEZvY3VzVHJhcEZhY3RvcnksXG4gICAgICAgIHByaXZhdGUgX2ZvY3VzTW9uaXRvcjogRm9jdXNNb25pdG9yLFxuICAgICAgICBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSxcbiAgICAgICAgcHJpdmF0ZSBfcGxhdGZvcm06IFBsYXRmb3JtLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5IHwgbnVsbCxcbiAgICAgICAgQEluamVjdChOWF9QT1BPVkVSX1NDUk9MTF9TVFJBVEVHWSkgcHJpdmF0ZSBfZGVmYXVsdFNjcm9sbFN0cmF0ZWd5RmFjdG9yeTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3ksXG4gICAgICAgIHByaXZhdGUgX2NkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoIXRoaXMuX3BsYXRmb3JtLklPUyAmJiAhdGhpcy5fcGxhdGZvcm0uQU5EUk9JRCkge1xuICAgICAgICAgICAgdGhpcy5fbWFudWFsTGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgLnNldCgnbW91c2VlbnRlcicsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnNldCgnbW91c2VsZWF2ZScsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5zZXQoJ2tleWRvd24nLCAoZXZlbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgU1BBQ0U6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEVOVEVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21hbnVhbExpc3RlbmVycy5zZXQoJ3RvdWNoc3RhcnQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlciA9PT0gJ2hvdmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbWFudWFsTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyLCBldmVudCkgPT4gZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikpO1xuXG4gICAgICAgIHRoaXMuX2ZvY3VzTW9uaXRvclxuICAgICAgICAgICAgLm1vbml0b3IoZWxlbWVudClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZShvcmlnaW4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4gPT09ICdrZXlib2FyZCcgJiYgdGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4gKHRoaXMuc2hvdyA9IHRydWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9kaXI/LmNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUodGhpcy5fZGlyQ2hhbmdlSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5wb3BvdmVyLnNob3dDbG9zZUJ1dHRvbiA9IHRoaXMuaXNDbG9zZWFibGUoKTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMucG9wb3Zlci5pZCA9IHRoaXMuaWQ7XG5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHRoaXMuZXZlbnRNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ3dpbmRvdycsICdrZXl1cC5lc2MnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkgYXMgKCkgPT4gdm9pZDtcblxuICAgICAgICB0aGlzLnBvcG92ZXIuY2xvc2VCdXR0b25DbGljay5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLnBvcG92ZXJJbml0aWFsVmlzaWJsZSB8fCB0aGlzLl9zaG93KSB7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcigpO1xuICAgICAgICB0aGlzLl9mb2N1c01vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgbGlzdGVuZXJzIHNldCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgdGhpcy5fbWFudWFsTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxheVJlZikge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYW51YWxMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheURlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlEZXN0cm95ZWQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXlSZWYgJiYgdGhpcy5jcmVhdGVPdmVybGF5KCkuaGFzQXR0YWNoZWQoKTtcbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGlzQ2xvc2VhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKHRoaXMudHJpZ2dlciA9PT0gJ2NsaWNrJyAmJiB0aGlzLl9jbG9zZWFibGUgPT09IG51bGwpIHx8ICEhdGhpcy5fY2xvc2VhYmxlO1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGUgdGhlIHBvcG92ZXIgd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24gc3RyYXRlZ3kuICovXG4gICAgdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9wb3NpdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvblN0cmF0ZWd5LmFwcGx5KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGhhbmRsZUNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy50cmlnZ2VyID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSAhdGhpcy5pc09wZW47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmlnZ2VyID09PSAnaG92ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnNob3cgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIE9wZW4gdGhlIHBvcG92ZXIgaW5zdGFuY2UuICovXG4gICAgb3BlbigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKiogQ2xvc2UgdGhlIHBvcG92ZXIgaW5zdGFuY2UuICovXG4gICAgY2xvc2UoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKiBUb2dnbGUgdGhlIHBvcG92ZXIgaW5zdGFuY2UuICovXG4gICAgdG9nZ2xlKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNob3cgPSAhdGhpcy5zaG93O1xuICAgIH1cblxuICAgIHByaXZhdGUgb3BlblBvcG92ZXIoKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5jcmVhdGVPdmVybGF5KCkuaGFzQXR0YWNoZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmID0gdGhpcy5jcmVhdGVPdmVybGF5KCkuYXR0YWNoKHRoaXMucG9ydGFsKTtcblxuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0UG9wb3ZlckNvbnRhaW5lcigpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNUcmFwID0gdGhpcy5fZm9jdXNUcmFwRmFjdG9yeS5jcmVhdGUoZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZVBvcG92ZXJXYXNPcGVuZWQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuICAgICAgICAgICAgdGhpcy5fZm9jdXNNb25pdG9yLm1vbml0b3IoZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubngtcG9wb3Zlcl9fY29udGVudCcpIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlSWNvbjogSFRNTEVsZW1lbnQgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5ueC1wb3BvdmVyX19jbG9zZS1pY29uJykgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoY2xvc2VJY29uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNNb25pdG9yLm1vbml0b3IoY2xvc2VJY29uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fYXV0b0ZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIGF0dGFjaCBhIGNsb3NlIGNsaWNrIGxpc3RlbmVyIG9ubHkgaWYgaXQgbWFrZXMgc2Vuc2UgKGlnbm9yZSBpdCBvbiBob3ZlciBlLmcuKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2xvc2VPbkNsaWNrT3V0c2lkZSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdEZvckNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdXRvZm9jdXMgdGhlIGZpcnN0IHRhYmJhYmxlIGVsZW1lbnQgaW5zaWRlIG9mIHRoZSBwb3BvdmVyLCBpZiB0aGVyZSBpcyBub3QgYSB0YWJiYWJsZSBlbGVtZW50LFxuICAgICAqIGZvY3VzIHRoZSBwb3BvdmVyIGluc3RlYWQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfYXV0b0ZvY3VzRmlyc3RUYWJiYWJsZUVsZW1lbnQoZWxlbWVudDogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNUcmFwLmZvY3VzSW5pdGlhbEVsZW1lbnRXaGVuUmVhZHkoKS50aGVuKGhhc01vdmVkRm9jdXMgPT4ge1xuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55IGZvY3VzYWJsZSBlbGVtZW50cyBpbnNpZGUgdGhlIHBvcG92ZXIsIGZvY3VzIHRoZVxuICAgICAgICAgICAgLy8gY29udGFpbmVyIHNvIHRoZSB1c2VyIGNhbid0IHRhYiBpbnRvIG90aGVyIGVsZW1lbnRzIGJlaGluZCBpdC5cbiAgICAgICAgICAgIGlmICghaGFzTW92ZWRGb2N1cykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gZGV0YWNoZXMgdGhlIG92ZXJsYXlcbiAgICAvLyB3ZSBhcmUgbGlzdGVuaW5nIHRvIHRoZSBkZXRhY2htZW50cyBvYnNlcnZhYmxlIHdoaWNoIHdpbGwgdGhlbiBlbWl0IHRoZSBueENsb3NlZCBldmVudFxuICAgIC8vIG9uIHRoZSBwb3BvdmVyIGNvbXBvbmVudFxuICAgIHByaXZhdGUgY2xvc2VQb3BvdmVyKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5vdmVybGF5UmVmIS5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRQb3BvdmVyQ29udGFpbmVyKCk7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c01vbml0b3Iuc3RvcE1vbml0b3JpbmcoZWxlbWVudCEucXVlcnlTZWxlY3RvcignLm54LXBvcG92ZXJfX2NvbnRlbnQnKSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLl9mb2N1c01vbml0b3Iuc3RvcE1vbml0b3JpbmcoZWxlbWVudCEucXVlcnlTZWxlY3RvcignLm54LXBvcG92ZXJfX2Nsb3NlLWljb24nKSBhcyBIVE1MRWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JldHVybkZvY3VzQWZ0ZXJQb3BvdmVyKCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYhLmRldGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcC5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFNjcm9sbFN0cmF0ZWd5RmFjdG9yeShzY3JvbGxTdHJhdGVneTogUG9wb3ZlclRyaWdnZXJTY3JvbGxTdHJhdGVneSk6ICgpID0+IFNjcm9sbFN0cmF0ZWd5IHtcbiAgICAgICAgc3dpdGNoIChzY3JvbGxTdHJhdGVneSkge1xuICAgICAgICAgICAgY2FzZSAncmVwb3NpdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb247XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlT3ZlcmxheSgpOiBPdmVybGF5UmVmIHtcbiAgICAgICAgaWYgKCF0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMucG9wb3Zlci50ZW1wbGF0ZVJlZiwgdGhpcy52aWV3Q29udGFpbmVyUmVmKTtcbiAgICAgICAgICAgIGNvbnN0IG92ZXJsYXlTdGF0ZSA9IG5ldyBPdmVybGF5Q29uZmlnKCk7XG4gICAgICAgICAgICBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uU3RyYXRlZ3kgPSBvdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneTtcblxuICAgICAgICAgICAgb3ZlcmxheVN0YXRlLnNjcm9sbFN0cmF0ZWd5ID0gdGhpcy5fc2Nyb2xsU3RyYXRlZ3lGYWN0b3J5KCk7XG5cbiAgICAgICAgICAgIG92ZXJsYXlTdGF0ZS5zY3JvbGxTdHJhdGVneS5lbmFibGUoKTtcbiAgICAgICAgICAgIG92ZXJsYXlTdGF0ZS5kaXJlY3Rpb24gPSB0aGlzLl9kaXI/LnZhbHVlIHx8ICdsdHInO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kYWwpIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5U3RhdGUuaGFzQmFja2Ryb3AgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYgPSB0aGlzLm92ZXJsYXkuY3JlYXRlKG92ZXJsYXlTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZVRvUG9zaXRpb25zKG92ZXJsYXlTdGF0ZS5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk7XG4gICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmVUb0F0dGFjaCgpO1xuICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9EZXRhY2goKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9tb2RhbCAmJiB0aGlzLl9jbG9zZU9uQ2xpY2tPdXRzaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlVG9CYWNrZHJvcENsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheVJlZjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN1YnNjcmliZVRvUG9zaXRpb25zKHBvc2l0aW9uOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3kpOiB2b2lkIHtcbiAgICAgICAgcG9zaXRpb24ucG9zaXRpb25DaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX292ZXJsYXlEZXN0cm95ZWQpKS5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBjaGFuZ2UuY29ubmVjdGlvblBhaXI7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uT3ZlcmxheShwYWlyKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25BcnJvdyhwYWlyKTtcblxuICAgICAgICAgICAgdGhpcy5jbG9zZU9uTGVmdFZpZXdwb3J0Lm9ic2VydmUodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSBwb3NpdGlvbiBjaGFuZ2VzIGFycml2ZSB0b28gbGF0ZSxcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gdHJpZ2dlciB0aGUgY2hhbmdlIGRldGVjdGlvbiBtYW51YWxseVxuICAgICAgICAgICAgLy8gYXMgaXQncyBkZXRhY2hlZCBmcm9tIGFueSByZW5kZXIgaGllcmFyY2h5XG4gICAgICAgICAgICAvLyBhbmQgb25seSB1cGRhdGVkIGJ5IHRoZSBvdmVybGF5IHdoZW4gYXR0YWNoZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1iZWRkZWRWaWV3UmVmICYmICF0aGlzLl9lbWJlZGRlZFZpZXdSZWYuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gZm9yIG1vZGFsIHBvcG92ZXJzIGNsb3NlIHRoZSBwb3BvdmVyIG9uIGJhY2tkcm9wIGNsaWNrc1xuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvQmFja2Ryb3BDbGljaygpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5UmVmIS5iYWNrZHJvcENsaWNrKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vdmVybGF5RGVzdHJveWVkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRW1pdCB0aGUgbnhDbG9zZWQgYW5kIHRoZSBzaG93IHN0YXR1cyBjaGFuZ2UgZXZlbnQgb24gdGhlIHBvcG92ZXIgY29tcG9uZW50IHdoZW4gdGhlIG92ZXJsYXkgZGV0YWNoZXNcbiAgICBwcml2YXRlIF9zdWJzY3JpYmVUb0RldGFjaCgpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5UmVmIS5kZXRhY2htZW50cygpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fb3ZlcmxheURlc3Ryb3llZCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGRhdGEgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gZXhjZXB0aW9uOiB3aGVuIHRoZSBwb3BvdmVyIGlzIGNsb3NlZCBieSBhIHNjcm9sbGluZyBldmVudCxcbiAgICAgICAgICAgICAgICAvLyB0aGVuIG9ubHkgdGhlIGRldGFjaGVkIG1ldGhvZCBpcyBjYWxsZWQgYnV0IHRoZSBzaG93IHN0YXRlIHZhcmlhYmxlIHJlbWFpbnMgdW5jaGFuZ2VkLlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNob3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU2hvdy5lbWl0KHRoaXMuX3Nob3cpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9wb3Zlci5lbWl0Q2xvc2VkRXZlbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3N1YnNjcmliZVRvQXR0YWNoKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlSZWYhLmF0dGFjaG1lbnRzKClcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLl9vdmVybGF5RGVzdHJveWVkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoZGF0YSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VTaG93LmVtaXQodGhpcy5fc2hvdyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBzdWJzY3JpYmUgdG8gZG9jdW1lbnQgY2xpY2tzIHdoZW4gdHJpZ2dlcj0nY2xpY2snIHRvIGNsb3NlIHRoZSBwb3BvdmVyIG9uIGNsaWNrcyBvbiB0aGUgYmFja2dyb3VuZFxuICAgIHByaXZhdGUgd2FpdEZvckNsb3NlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdmVybGF5UmVmIS5vdXRzaWRlUG9pbnRlckV2ZW50cygpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoZXZlbnQgPT4gZXZlbnQudGFyZ2V0KSxcbiAgICAgICAgICAgICAgICBmaWx0ZXIodGFyZ2V0ID0+ICF0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQpKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5wb3BvdmVyLmNsb3NlZCksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgcG9zaXRpb25PdmVybGF5KHBhaXI6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIpIHtcbiAgICAgICAgaWYgKHBhaXIub3JpZ2luWCA9PT0gJ2VuZCcgJiYgcGFpci5vdmVybGF5WCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmRpcmVjdGlvbiA9IHRoaXMuaXNSdGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB9IGVsc2UgaWYgKHBhaXIub3JpZ2luWSA9PT0gJ2JvdHRvbScgJiYgcGFpci5vdmVybGF5WSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5kaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfSBlbHNlIGlmIChwYWlyLm9yaWdpblggPT09ICdzdGFydCcgJiYgcGFpci5vdmVybGF5WCA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHRoaXMucG9wb3Zlci5kaXJlY3Rpb24gPSB0aGlzLmlzUnRsID8gJ3JpZ2h0JyA6ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChwYWlyLm9yaWdpblkgPT09ICd0b3AnICYmIHBhaXIub3ZlcmxheVkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuZGlyZWN0aW9uID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBvc2l0aW9uQXJyb3cocGFpcjogQ29ubmVjdGlvblBvc2l0aW9uUGFpcikge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50UG9zaXRpb25YID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudFdpZHRoID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLyAyO1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50TGVmdE9mZnNldCA9IHRoaXMub3ZlcmxheVJlZiEub3ZlcmxheUVsZW1lbnQucGFyZW50RWxlbWVudCEub2Zmc2V0TGVmdDtcbiAgICAgICAgY29uc3Qgb3ZlcmxheUVsZW1lbnRMZWZ0T2Zmc2V0ID0gdGhpcy5vdmVybGF5UmVmIS5vdmVybGF5RWxlbWVudC5vZmZzZXRMZWZ0O1xuXG4gICAgICAgIC8vIGNhbGN1bGF0aW9uIGZvciB4IHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgZWxlbWVudC4gSW4gdGhpcyBjYXNlLCBvdmVybGF5IGxlZnQgb2Zmc2V0IGlzIHRoZSBvbmUgdGhpbmcgdG8gY29uc2lkZXIuXG4gICAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gcGFyZW50RWxlbWVudFBvc2l0aW9uWCArIHBhcmVudEVsZW1lbnRXaWR0aCAtIChwYXJlbnRFbGVtZW50TGVmdE9mZnNldCArIG92ZXJsYXlFbGVtZW50TGVmdE9mZnNldCk7XG4gICAgICAgIGlmIChwYWlyLm9yaWdpblggPT09IHBhaXIub3ZlcmxheVgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgICAgIGNvbnN0IGFycm93U3R5bGUgPSB7IGxlZnQ6ICcwJyB9O1xuXG4gICAgICAgICAgICBhcnJvd1N0eWxlW2RpcmVjdGlvbl0gPSB0YXJnZXRQb3NpdGlvbiArICdweCc7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuYXJyb3dTdHlsZSA9IGFycm93U3R5bGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChwYWlyLm9yaWdpblkgPT09ICdib3R0b20nIHx8IHBhaXIub3JpZ2luWSA9PT0gJ3RvcCcpICYmIHBhaXIub3ZlcmxheVggPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICB0aGlzLnBvcG92ZXIuYXJyb3dTdHlsZSA9IHsgbGVmdDogdGFyZ2V0UG9zaXRpb24gKyAncHgnIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHBhaXIub3JpZ2luWCA9PT0gJ2VuZCcgfHwgcGFpci5vcmlnaW5YID09PSAnc3RhcnQnKSAmJiBwYWlyLm92ZXJsYXlZID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGhpcy5wb3BvdmVyLmFycm93U3R5bGUgPSB7IHRvcDogJzUwJScgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0UG9zaXRpb24oKTogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5fZ2V0T3JpZ2luKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3Qgb3ZlcmxheSA9IHRoaXMuX2dldE92ZXJsYXlQb3NpdGlvbih0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2dldE9mZnNldCh0aGlzLmRpcmVjdGlvbik7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrcyA9IHRoaXMuX2dldEZhbGxiYWNrUG9zaXRpb25zKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheVxuICAgICAgICAgICAgLnBvc2l0aW9uKClcbiAgICAgICAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuZWxlbWVudFJlZilcbiAgICAgICAgICAgIC53aXRoUG9zaXRpb25zKFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgLi4ub3ZlcmxheSxcbiAgICAgICAgICAgICAgICAgICAgLi4ub2Zmc2V0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uZmFsbGJhY2tzLFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIC53aXRoRmxleGlibGVEaW1lbnNpb25zKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgZm9jdXMgdG8gdGhlIGVsZW1lbnQgZm9jdXNlZCBiZWZvcmUgdGhlIFBvcG92ZXIgd2FzIG9wZW4uICovXG4gICAgcHJpdmF0ZSBfcmV0dXJuRm9jdXNBZnRlclBvcG92ZXIoKSB7XG4gICAgICAgIGNvbnN0IHRvRm9jdXMgPSB0aGlzLl9lbGVtZW50Rm9jdXNlZEJlZm9yZVBvcG92ZXJXYXNPcGVuZWQ7XG4gICAgICAgIC8vIFdlIG5lZWQgdGhlIGV4dHJhIGNoZWNrLCBiZWNhdXNlIElFIGNhbiBzZXQgdGhlIGBhY3RpdmVFbGVtZW50YCB0byBudWxsIGluIHNvbWUgY2FzZXMuXG4gICAgICAgIGlmICh0b0ZvY3VzICYmIHR5cGVvZiB0b0ZvY3VzLmZvY3VzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b0ZvY3VzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgbWFpbiBwb3BvdmVyIGNvbnRhaW5lciBvZiB0aGUgaW5qZWN0ZWQgY29udGVudC4gKi9cbiAgICBwcml2YXRlIGdldFBvcG92ZXJDb250YWluZXIoKTogSFRNTEVsZW1lbnQgfCBudWxsIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3ZlcmxheVJlZiEub3ZlcmxheUVsZW1lbnQucXVlcnlTZWxlY3RvcignLm54LXBvcG92ZXInKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvcmlnaW4gcG9zaXRpb24gYmFzZWQgb24gdGhlIHVzZXIncyBkaXJlY3Rpb24gcHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBfZ2V0T3JpZ2luKGRpcmVjdGlvbjogUG9wb3ZlckRpcmVjdGlvbik6IE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbiB7XG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpblg6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5ZOiBkaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luWDogdGhpcy5pc1J0bCA/ICdlbmQnIDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpblg6IHRoaXMuaXNSdGwgPyAnc3RhcnQnIDogJ2VuZCcsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0TnhQb3BvdmVySW52YWxpZERpcmVjdGlvbkVycm9yKGRpcmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgb3ZlcmxheSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdXNlcidzIGRpcmVjdGlvbiBwcmVmZXJlbmNlICovXG4gICAgX2dldE92ZXJsYXlQb3NpdGlvbihkaXJlY3Rpb246IFBvcG92ZXJEaXJlY3Rpb24pOiBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uIHtcbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5WTogdGhpcy5fZ2V0SW52ZXJzZVBvc2l0aW9uKGRpcmVjdGlvbikgYXMgVmVydGljYWxDb25uZWN0aW9uUG9zLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsZWZ0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlYOiB0aGlzLmlzUnRsID8gJ3N0YXJ0JyA6ICdlbmQnLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlYOiB0aGlzLmlzUnRsID8gJ2VuZCcgOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBnZXROeFBvcG92ZXJJbnZhbGlkRGlyZWN0aW9uRXJyb3IoZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBvdmVybGF5IG9mZnNldCByZXF1aXJlZCBieSB0aGUgdXNlcidzIGRpcmVjdGlvbiBwcmVmZXJlbmNlICovXG4gICAgcHJpdmF0ZSBfZ2V0T2Zmc2V0KGRpcmVjdGlvbjogUG9wb3ZlckRpcmVjdGlvbikge1xuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAndG9wJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFk6IEJBU0VfT0ZGU0VUICogLTEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiBCQVNFX09GRlNFVCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBCQVNFX09GRlNFVCAqIC0xLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRYOiBCQVNFX09GRlNFVCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IGdldE54UG9wb3ZlckludmFsaWREaXJlY3Rpb25FcnJvcihkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwgdXNpbmcgYXF1aWxhIHBvcG92ZXIgZGlyZWN0aW9uIG5hbWluZzogdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0ICovXG4gICAgcHJpdmF0ZSBfZ2V0SW52ZXJzZVBvcG92ZXJEaXJlY3Rpb24oZGlyZWN0aW9uOiBQb3BvdmVyRGlyZWN0aW9uKTogUG9wb3ZlckRpcmVjdGlvbiB7XG4gICAgICAgIGNvbnN0IHBvcG92ZXJEaXJlY3Rpb25QYWlycyA9IHtcbiAgICAgICAgICAgIHRvcDogJ2JvdHRvbScsXG4gICAgICAgICAgICByaWdodDogJ2xlZnQnLFxuICAgICAgICAgICAgYm90dG9tOiAndG9wJyxcbiAgICAgICAgICAgIGxlZnQ6ICdyaWdodCcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwb3BvdmVyRGlyZWN0aW9uUGFpcnNbZGlyZWN0aW9uXSBhcyBQb3BvdmVyRGlyZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiwgdXNpbmcgYW5ndWxhciBwb3NpdGlvbiBuYW1pbmc6IHRvcCwgYm90dG9tLCBzdGFydCwgZW5kLCBjZW50ZXIgKi9cbiAgICBwcml2YXRlIF9nZXRJbnZlcnNlUG9zaXRpb24ocG9zaXRpb246IHN0cmluZyk6IFZlcnRpY2FsQ29ubmVjdGlvblBvcyB8IEhvcml6b250YWxDb25uZWN0aW9uUG9zIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25QYWlyczogeyBbazogc3RyaW5nXTogVmVydGljYWxDb25uZWN0aW9uUG9zIHwgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MgfSA9IHtcbiAgICAgICAgICAgIHRvcDogJ2JvdHRvbScsXG4gICAgICAgICAgICBib3R0b206ICd0b3AnLFxuICAgICAgICAgICAgc3RhcnQ6ICdlbmQnLFxuICAgICAgICAgICAgZW5kOiAnc3RhcnQnLFxuICAgICAgICAgICAgY2VudGVyOiAnY2VudGVyJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uUGFpcnNbcG9zaXRpb25dO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIGFuIGFycmF5IG9mIGZhbGxiYWNrIHBvc2l0aW9ucyBmb3IgcG9wb3ZlciwgZm9sbG93aW5nIHRoZSBhbGdvcml0bTpcbiAgICAgKiAxKSBTbGlnaHRseSBhbHRlcm5hdGUgcHJlZmVycmVkIHBvc2l0aW9uIGlmIGFwcGxpY2FibGUuIEkuZS4gZm9yICd0b3AnIHRyeSAndG9wLXN0YXJ0JyBhbmQgJ3RvcC1lbmQnIHBvc2l0aW9uaW5nLlxuICAgICAqIDIpIFRyeSB0aGUgb3Bwb3NpdGUgcG9zaXRpb24sIGkuZS4gZm9yICd0b3AnIHRyeSAnYm90dG9tJy5cbiAgICAgKiAzKSBTbGlnaHRseSBhbHRlcm5hdGUgb3Bwb3NpdGUgcG9zaXRpb24sIGkuZS4gJ2JvdHRvbS1zdGFydCcsICdib3R0b20tZW5kJ1xuICAgICAqIDQpIEFsbCByZW1haW5pbmcgcG9zaXRpb25zIGZyb20gcG9zaXRpb25zIGxpc3RcbiAgICAgKi9cbiAgICBwcml2YXRlIF9nZXRGYWxsYmFja1Bvc2l0aW9ucyhcbiAgICAgICAgZGlyZWN0aW9uOiBQb3BvdmVyRGlyZWN0aW9uLFxuICAgICAgICBwb3NzaWJsZURpcmVjdGlvbnM6IFBvcG92ZXJEaXJlY3Rpb25bXSA9IHRoaXMuX3Bvc3NpYmxlUG9wb3ZlckRpcmVjdGlvbnMsXG4gICAgKTogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdIHtcbiAgICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW1haW5pZ0RpcmVjdGlvbnMgPSBwb3NzaWJsZURpcmVjdGlvbnMuZmlsdGVyKHBvc3NpYmxlRGlyZWN0aW9uID0+IHBvc3NpYmxlRGlyZWN0aW9uICE9PSBkaXJlY3Rpb24pO1xuICAgICAgICBsZXQgZmFsbGJhY2tQb3NpdGlvbnM6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSA9IFtdO1xuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6IHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja1Bvc2l0aW9ucyA9IHRoaXMuX2dldFZlcnRpY2FsRmFsbGJhY2tQb3NpdGlvblBhaXJzKGRpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0Jzoge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrUG9zaXRpb25zID0gdGhpcy5fZ2V0SG9yaXpvbnRhbEZhbGxiYWNrUG9zaXRpb25QYWlycyhkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW52ZXJzZURpcmVjdGlvbiA9IHRoaXMuX2dldEludmVyc2VQb3BvdmVyRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICAgIGNvbnN0IG5leHRGYWxsYmFja1Bvc2l0aW9uID0gcmVtYWluaWdEaXJlY3Rpb25zLmluY2x1ZGVzKGludmVyc2VEaXJlY3Rpb24pID8gaW52ZXJzZURpcmVjdGlvbiA6IHBvc3NpYmxlRGlyZWN0aW9uc1swXTtcbiAgICAgICAgcmV0dXJuIFsuLi5mYWxsYmFja1Bvc2l0aW9ucywgLi4udGhpcy5fZ2V0RmFsbGJhY2tQb3NpdGlvbnMobmV4dEZhbGxiYWNrUG9zaXRpb24sIHJlbWFpbmlnRGlyZWN0aW9ucyldO1xuICAgIH1cblxuICAgIC8qKiBDYWxjdWxhdGVzIGZhbGxiYWNrcyBmb3IgdmVydGljYWwgcG9wb3ZlciBwb3NpdGlvbmluZyAqL1xuICAgIHByaXZhdGUgX2dldFZlcnRpY2FsRmFsbGJhY2tQb3NpdGlvblBhaXJzKGRpcmVjdGlvbjogUG9wb3ZlclZlcnRpY2FsRGlyZWN0aW9uKTogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdIHtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZERpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gdGhpcy5kaXJlY3Rpb247XG4gICAgICAgIGNvbnN0IHZlcnRpY2FsRmFsbGJhY2tQb3NpdGlvblBhaXJzOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10gPSBbXTtcbiAgICAgICAgY29uc3QgYmFzZVBvc2l0aW9uUGFpciA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2dldE9yaWdpbihkaXJlY3Rpb24pLFxuICAgICAgICAgICAgLi4udGhpcy5fZ2V0T3ZlcmxheVBvc2l0aW9uKGRpcmVjdGlvbiksXG4gICAgICAgICAgICAuLi50aGlzLl9nZXRPZmZzZXQoZGlyZWN0aW9uKSxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWlzU2VsZWN0ZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIEhJTlQ6IHNlbGVjdGVkIGRpcmVjdGlvbiBtYXRjaGVzIGJhc2VQb3NpdGlvbiwgc28gd2UgZG9uJ3QgbmVlZCB0byByZXBlYXQgaXQgaW4gZmFsbGJhY2tcbiAgICAgICAgICAgIHZlcnRpY2FsRmFsbGJhY2tQb3NpdGlvblBhaXJzLnB1c2goYmFzZVBvc2l0aW9uUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgdmVydGljYWxGYWxsYmFja1Bvc2l0aW9uUGFpcnMucHVzaChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlUG9zaXRpb25QYWlyLFxuICAgICAgICAgICAgICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmJhc2VQb3NpdGlvblBhaXIsXG4gICAgICAgICAgICAgICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHZlcnRpY2FsRmFsbGJhY2tQb3NpdGlvblBhaXJzO1xuICAgIH1cblxuICAgIC8qKiBDYWxjdWxhdGVzIGZhbGxiYWNrcyBmb3IgaG9yaXpvbnRhbCBwb3BvdmVyIHBvc2l0aW9uaW5nICovXG4gICAgcHJpdmF0ZSBfZ2V0SG9yaXpvbnRhbEZhbGxiYWNrUG9zaXRpb25QYWlycyhkaXJlY3Rpb246IFBvcG92ZXJIb3Jpem9udGFsRGlyZWN0aW9uKTogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fZ2V0T2Zmc2V0KGRpcmVjdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9nZXRPcmlnaW4oZGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9nZXRPdmVybGF5UG9zaXRpb24oZGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAuLi5vZmZzZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2RpckNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VQb3BvdmVyKCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5UmVmID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlEZXN0cm95ZWQubmV4dCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IGlzUnRsKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyPy52YWx1ZSA9PT0gJ3J0bCc7XG4gICAgfVxufVxuIl19