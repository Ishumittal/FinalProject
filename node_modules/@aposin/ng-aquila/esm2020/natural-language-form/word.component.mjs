import { OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal } from '@angular/cdk/portal';
import { ChangeDetectionStrategy, Component, ContentChild, ContentChildren, HostBinding, Input, ViewChild, } from '@angular/core';
import { NxDropdownComponent } from '@aposin/ng-aquila/dropdown';
import { NxFormfieldControl, NxFormfieldErrorDirective } from '@aposin/ng-aquila/formfield';
import { getFontShorthand } from '@aposin/ng-aquila/utils';
import { Subject } from 'rxjs';
import { startWith, takeUntil } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@aposin/ng-aquila/popover";
import * as i3 from "@angular/common";
export class NxWordComponent {
    constructor(
    /** @docs-private */ elementRef, _cdr, _renderer, _overlay, _viewContainerRef, _overlayPositionBuilder) {
        this.elementRef = elementRef;
        this._cdr = _cdr;
        this._renderer = _renderer;
        this._overlay = _overlay;
        this._viewContainerRef = _viewContainerRef;
        this._overlayPositionBuilder = _overlayPositionBuilder;
        /** @docs-private */
        this.inputChanges = new Subject();
        this._hasErrors = false;
        /** @docs-private */
        this.currentTextWidth = 0;
        // this will apply different min-widths to our component through our styles
        /** Provide a hint for a minimal width. The actual size will be determined for inputs for each change. */
        this.size = 'regular';
        /**
         * A word doesn't have a set place to show labels.
         * In order to be accessible, you have to provide a label with this property.
         * It will be attached to the given input through `aria-label`.
         */
        this.label = '';
        this._destroyed = new Subject();
    }
    ngOnInit() {
        this.setupErrorPopover();
    }
    ngAfterContentInit() {
        this._validateControlChild();
        this._control.stateChanges.pipe(startWith(null), takeUntil(this._destroyed)).subscribe(() => {
            this._hasErrors = this._control.errorState;
            this.updateErrorPopoverState();
            this._cdr.markForCheck();
        });
        // if we have a ngcontrol available stick to its valueChanges subject
        if (this._control.ngControl) {
            this._control.ngControl.valueChanges.pipe(takeUntil(this._destroyed)).subscribe(value => {
                this.updateCurrentTextWidth();
                this.inputChanges.next();
            });
            // in any other case it is a bre input and input changes are signaled through simple state changes
        }
        else {
            this._control.stateChanges.pipe(takeUntil(this._destroyed)).subscribe(value => {
                this.updateCurrentTextWidth();
                this.inputChanges.next();
            });
        }
        this._control.setAriaLabel(this.label);
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        if (this._overlayRef) {
            this._overlayRef.dispose();
        }
    }
    /**
    @docs-private
    Calculate the width of the full text given by the input,
    that value is bound to this component so it can grow.

    The involved input is known to have a width of 100% an will fit the additional space given
    which completes the auto growing behavior.
  */
    updateCurrentTextWidth() {
        // provide the canvas only lazy
        if (!this.measureCanvas) {
            this.measureCanvas = this._renderer.createElement('canvas');
        }
        const ctx = this.measureCanvas.getContext('2d');
        const inputRef = this._control.elementRef;
        const styles = window.getComputedStyle(inputRef.nativeElement);
        ctx.font = getFontShorthand(styles);
        const metrics = ctx.measureText(this._control.value);
        // add 1px (cursor width) to prevent jumping of the text on blur.
        const newWidth = metrics.width + parseInt(styles.paddingRight, 10) + parseInt(styles.paddingLeft, 10) + 1;
        // This should be injected via @Host to get an exact reference to NxNaturalLanguageFormComponent
        // Works as promised as long as there is not other tag around the word. Not expected but possible.
        const parent = this.elementRef.nativeElement.parentElement;
        const parentMeasurement = parent.getBoundingClientRect();
        // Limit to own given minimal width
        this.currentTextWidth = Math.max(parseInt(styles.minWidth, 10), newWidth);
        // Limit to container width
        this.currentTextWidth = Math.min(this.currentTextWidth, parentMeasurement.width);
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    }
    /** @docs-private */
    repositionError() {
        if (this._overlayRef.hasAttached()) {
            this._overlayState.positionStrategy.apply();
        }
    }
    // Fail if the required control is missing.
    _validateControlChild() {
        if (!this._control) {
            throw new Error('NxWordComponent requires an NxFormfieldControl compatible input.');
        }
    }
    /** @docs-private */
    getConnectedOverlayOrigin() {
        return this.elementRef;
    }
    /** @docs-private */
    get isFocused() {
        return this._control.focused;
    }
    /** @docs-private */
    get isFilled() {
        return !this._control.empty;
    }
    /** @docs-private */
    get hasDropdown() {
        return Boolean(this._dropdown);
    }
    updateErrorPopoverState() {
        if (this._hasErrors && this._errorChildren.length > 0) {
            this.showPopover();
        }
        else {
            this.hidePopover();
        }
    }
    setupErrorPopover() {
        const positionStrategy = this._overlayPositionBuilder
            .flexibleConnectedTo(this.elementRef)
            .withLockedPosition(true)
            .withFlexibleDimensions(false)
            .withPush(true)
            .withPositions([
            {
                originX: 'center',
                originY: 'top',
                overlayX: 'center',
                overlayY: 'bottom',
            },
            {
                originX: 'center',
                originY: 'bottom',
                overlayX: 'center',
                overlayY: 'top',
            },
        ])
            .withDefaultOffsetY(-8);
        this._overlayState = new OverlayConfig();
        this._overlayState.positionStrategy = positionStrategy;
        this._overlayState.scrollStrategy = this._overlay.scrollStrategies.reposition();
        this._overlayRef = this._overlay.create(this._overlayState);
        this._overlayState.positionStrategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe(change => {
            const pair = change.connectionPair;
            this.positionArrow(pair);
            // These position changes arrive too late,
            // We have to trigger the change detection manually
            // as it's detached from any render hierarchy
            // and only updated by the overlay when attached.
            if (this._embeddedViewRef && !this._embeddedViewRef.destroyed) {
                this._embeddedViewRef.detectChanges();
            }
        });
    }
    positionArrow(pair) {
        const parentElementPositionX = this.elementRef.nativeElement.getBoundingClientRect().left;
        const parentElementWidth = this.elementRef.nativeElement.getBoundingClientRect().width / 2;
        const parentElementLeftOffset = this._overlayRef.overlayElement.parentElement.offsetLeft;
        const overlayElementLeftOffset = this._overlayRef.overlayElement.offsetLeft;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        const targetPosition = parentElementPositionX + parentElementWidth - (parentElementLeftOffset + overlayElementLeftOffset);
        if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this._popover.direction = 'top';
        }
        else {
            this._popover.direction = 'bottom';
        }
        this._popover.arrowStyle = { left: targetPosition + 'px' };
    }
    showPopover() {
        if (!this._overlayRef.hasAttached()) {
            const tooltipPortal = new TemplatePortal(this._popover.templateRef, this._viewContainerRef);
            this._embeddedViewRef = this._overlayRef.attach(tooltipPortal);
        }
    }
    hidePopover() {
        this._overlayRef.detach();
    }
}
NxWordComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxWordComponent, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: i0.Renderer2 }, { token: i1.Overlay }, { token: i0.ViewContainerRef }, { token: i1.OverlayPositionBuilder }], target: i0.ɵɵFactoryTarget.Component });
NxWordComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxWordComponent, selector: "nx-word", inputs: { size: ["nxSize", "size"], label: ["nxLabel", "label"] }, host: { properties: { "class.size-short": "size == \"short\"", "class.size-regular": "size == \"regular\"", "class.size-long": "size == \"long\"", "class.has-error": "_hasErrors", "class.is-focused": "isFocused", "class.is-filled": "isFilled", "class.has-dropdown": "hasDropdown", "style.width.px": "this.currentTextWidth" } }, queries: [{ propertyName: "_control", first: true, predicate: NxFormfieldControl, descendants: true }, { propertyName: "_dropdown", first: true, predicate: NxDropdownComponent, descendants: true }, { propertyName: "_errorChildren", predicate: NxFormfieldErrorDirective }], viewQueries: [{ propertyName: "_popover", first: true, predicate: ["popover"], descendants: true, static: true }], ngImport: i0, template: "<div>\n    <!-- We only allow formfield controls here -->\n    <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n        <ng-content select=\"[nxInput]\"></ng-content>\n    </div>\n    <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popover>\n    <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>\n", styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;hyphens:none;width:100%;margin:0 4px}:host .nx-word__inner-wrapper{border-bottom-width:2px;border-bottom-style:solid;border-bottom-color:var(--natural-language-form-border-color)}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width: 991px){:host.size-long{min-width:280px}}@media (max-width: 703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:none;box-shadow:none}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:var(--natural-language-form-active-color);font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom-width:2px;border-bottom-style:solid;border-bottom-color:var(--natural-language-form-border-color)}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-nx-spacer(4xs)}@media (max-width: 991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}}:host ::ng-deep nx-dropdown.is-filled,:host ::ng-deep nx-dropdown.has-focus{color:var(--natural-language-form-active-color);border-color:var(--natural-language-form-active-border-color)}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-focused) .nx-word__inner-wrapper,:host(.is-filled) .nx-word__inner-wrapper{border-color:var(--natural-language-form-active-border-color)}:host(.has-error) .nx-word__inner-wrapper{border-color:var(--natural-language-form-error-border-color)}:host.has-error ::ng-deep nx-dropdown{color:var(--natural-language-form-error-color);border-color:var(--natural-language-form-error-border-color)}:host.has-error ::ng-deep .c-input.has-error{color:var(--natural-language-form-error-color)}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:var(--negative);color:var(--negative)}:host-context(.is-negative) ::ng-deep .c-input,:host-context(.is-negative) ::ng-deep .c-input.has-error{color:var(--negative)}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:var(--negative)}.nx-word__inner-wrapper{height:var(--natural-language-form-large-line-height)}@media (max-width: 991px){.nx-word__inner-wrapper{height:var(--natural-language-form-small-line-height)}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:var(--natural-language-form-small-line-height)}@media screen and (-ms-high-contrast: active){.nx-word__inner-wrapper,::ng-deep nx-dropdown{border-bottom-color:buttonText!important}:host(.is-focused) .nx-word__inner-wrapper,:host(.is-focused) ::ng-deep nx-dropdown{border-bottom-color:highlight!important}}\n"], components: [{ type: i2.NxPopoverComponent, selector: "nx-popover", outputs: ["nxClosed"], exportAs: ["nxPopover"] }], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxWordComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-word', host: {
                        '[class.size-short]': 'size == "short"',
                        '[class.size-regular]': 'size == "regular"',
                        '[class.size-long]': 'size == "long"',
                        '[class.has-error]': '_hasErrors',
                        '[class.is-focused]': 'isFocused',
                        '[class.is-filled]': 'isFilled',
                        '[class.has-dropdown]': 'hasDropdown',
                    }, changeDetection: ChangeDetectionStrategy.OnPush, template: "<div>\n    <!-- We only allow formfield controls here -->\n    <div *ngIf=\"!hasDropdown\" class=\"nx-word__inner-wrapper\">\n        <ng-content select=\"[nxInput]\"></ng-content>\n    </div>\n    <ng-content select=\"nx-dropdown\"></ng-content>\n</div>\n\n<nx-popover #popover>\n    <ng-content select=\"[nxError]\"></ng-content>\n</nx-popover>\n", styles: [":host{display:inline-block;position:relative;font-weight:400;text-align:center;-webkit-hyphens:none;hyphens:none;width:100%;margin:0 4px}:host .nx-word__inner-wrapper{border-bottom-width:2px;border-bottom-style:solid;border-bottom-color:var(--natural-language-form-border-color)}:host.size-short{min-width:80px}:host.size-regular{min-width:152px}:host.size-long{min-width:360px}@media (max-width: 991px){:host.size-long{min-width:280px}}@media (max-width: 703px){:host.size-long{min-width:248px}}:host ::ng-deep .c-input{display:inline-block;text-align:inherit;font-size:inherit;line-height:inherit;background:0 0;color:inherit;border:none;outline:0;margin:0;width:100%;max-width:100%;height:auto;box-shadow:none;padding:0 8px}:host ::ng-deep .c-input.is-focused{outline:none;box-shadow:none}:host ::ng-deep .c-input.is-filled,:host ::ng-deep .c-input.is-focused{color:var(--natural-language-form-active-color);font-weight:400}:host ::ng-deep .c-input.is-disabled{cursor:not-allowed}:host ::ng-deep .c-input::-ms-clear{display:none}:host ::ng-deep nx-dropdown{position:relative;border-bottom-width:2px;border-bottom-style:solid;border-bottom-color:var(--natural-language-form-border-color)}:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:inherit;margin-bottom:-nx-spacer(4xs)}@media (max-width: 991px){:host ::ng-deep nx-dropdown .nx-dropdown__container{font-size:26px}}:host ::ng-deep nx-dropdown.is-filled,:host ::ng-deep nx-dropdown.has-focus{color:var(--natural-language-form-active-color);border-color:var(--natural-language-form-active-border-color)}:host ::ng-deep nx-dropdown .nx-dropdown__icon{line-height:inherit}:host ::ng-deep .nx-word__input-wrapper{width:100%}:host(.is-focused) .nx-word__inner-wrapper,:host(.is-filled) .nx-word__inner-wrapper{border-color:var(--natural-language-form-active-border-color)}:host(.has-error) .nx-word__inner-wrapper{border-color:var(--natural-language-form-error-border-color)}:host.has-error ::ng-deep nx-dropdown{color:var(--natural-language-form-error-color);border-color:var(--natural-language-form-error-border-color)}:host.has-error ::ng-deep .c-input.has-error{color:var(--natural-language-form-error-color)}:host-context(.is-negative) ::ng-deep .nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown,:host-context(.is-negative) ::ng-deep nx-dropdown.is-filled{border-color:var(--negative);color:var(--negative)}:host-context(.is-negative) ::ng-deep .c-input,:host-context(.is-negative) ::ng-deep .c-input.has-error{color:var(--negative)}:host-context(.is-negative) .nx-word__inner-wrapper{border-color:var(--negative)}.nx-word__inner-wrapper{height:var(--natural-language-form-large-line-height)}@media (max-width: 991px){.nx-word__inner-wrapper{height:var(--natural-language-form-small-line-height)}}:host-context(.nx-natural-language-form--small) .nx-word__inner-wrapper{height:var(--natural-language-form-small-line-height)}@media screen and (-ms-high-contrast: active){.nx-word__inner-wrapper,::ng-deep nx-dropdown{border-bottom-color:buttonText!important}:host(.is-focused) .nx-word__inner-wrapper,:host(.is-focused) ::ng-deep nx-dropdown{border-bottom-color:highlight!important}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i0.Renderer2 }, { type: i1.Overlay }, { type: i0.ViewContainerRef }, { type: i1.OverlayPositionBuilder }]; }, propDecorators: { _control: [{
                type: ContentChild,
                args: [NxFormfieldControl]
            }], _errorChildren: [{
                type: ContentChildren,
                args: [NxFormfieldErrorDirective]
            }], _popover: [{
                type: ViewChild,
                args: ['popover', { static: true }]
            }], _dropdown: [{
                type: ContentChild,
                args: [NxDropdownComponent]
            }], currentTextWidth: [{
                type: HostBinding,
                args: ['style.width.px']
            }], size: [{
                type: Input,
                args: ['nxSize']
            }], label: [{
                type: Input,
                args: ['nxLabel']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid29yZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL25hdHVyYWwtbGFuZ3VhZ2UtZm9ybS93b3JkLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWFxdWlsYS9zcmMvbmF0dXJhbC1sYW5ndWFnZS1mb3JtL3dvcmQuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFzRSxhQUFhLEVBQXNDLE1BQU0sc0JBQXNCLENBQUM7QUFDN0osT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3JELE9BQU8sRUFFSCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULFlBQVksRUFDWixlQUFlLEVBR2YsV0FBVyxFQUNYLEtBQUssRUFLTCxTQUFTLEdBRVosTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDakUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLHlCQUF5QixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFFNUYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDM0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7OztBQW9CdEQsTUFBTSxPQUFPLGVBQWU7SUFpQ3hCO0lBQ0ksb0JBQW9CLENBQVEsVUFBc0IsRUFDMUMsSUFBdUIsRUFDdkIsU0FBb0IsRUFDcEIsUUFBaUIsRUFDakIsaUJBQW1DLEVBQ25DLHVCQUErQztRQUwzQixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQzFDLFNBQUksR0FBSixJQUFJLENBQW1CO1FBQ3ZCLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDcEIsYUFBUSxHQUFSLFFBQVEsQ0FB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QUFmLGVBQWUsZ2VBV1Ysa0JBQWtCLDRFQUdsQixtQkFBbUIsb0VBRmhCLHlCQUF5QixnSkN6RDlDLDhWQVdBOzJGRGtDYSxlQUFlO2tCQWYzQixTQUFTOytCQUNJLFNBQVMsUUFHYjt3QkFDRixvQkFBb0IsRUFBRSxpQkFBaUI7d0JBQ3ZDLHNCQUFzQixFQUFFLG1CQUFtQjt3QkFDM0MsbUJBQW1CLEVBQUUsZ0JBQWdCO3dCQUNyQyxtQkFBbUIsRUFBRSxZQUFZO3dCQUNqQyxvQkFBb0IsRUFBRSxXQUFXO3dCQUNqQyxtQkFBbUIsRUFBRSxVQUFVO3dCQUMvQixzQkFBc0IsRUFBRSxhQUFhO3FCQUN4QyxtQkFDZ0IsdUJBQXVCLENBQUMsTUFBTTttUEFhYixRQUFRO3NCQUF6QyxZQUFZO3VCQUFDLGtCQUFrQjtnQkFDWSxjQUFjO3NCQUF6RCxlQUFlO3VCQUFDLHlCQUF5QjtnQkFDRixRQUFRO3NCQUEvQyxTQUFTO3VCQUFDLFNBQVMsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7Z0JBQ0gsU0FBUztzQkFBM0MsWUFBWTt1QkFBQyxtQkFBbUI7Z0JBSWpDLGdCQUFnQjtzQkFEZixXQUFXO3VCQUFDLGdCQUFnQjtnQkFLWixJQUFJO3NCQUFwQixLQUFLO3VCQUFDLFFBQVE7Z0JBT0csS0FBSztzQkFBdEIsS0FBSzt1QkFBQyxTQUFTIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGlvblBvc2l0aW9uUGFpciwgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5LCBPdmVybGF5LCBPdmVybGF5Q29uZmlnLCBPdmVybGF5UG9zaXRpb25CdWlsZGVyLCBPdmVybGF5UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEVtYmVkZGVkVmlld1JlZixcbiAgICBIb3N0QmluZGluZyxcbiAgICBJbnB1dCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdDb250YWluZXJSZWYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTnhEcm9wZG93bkNvbXBvbmVudCB9IGZyb20gJ0BhcG9zaW4vbmctYXF1aWxhL2Ryb3Bkb3duJztcbmltcG9ydCB7IE54Rm9ybWZpZWxkQ29udHJvbCwgTnhGb3JtZmllbGRFcnJvckRpcmVjdGl2ZSB9IGZyb20gJ0BhcG9zaW4vbmctYXF1aWxhL2Zvcm1maWVsZCc7XG5pbXBvcnQgeyBOeFBvcG92ZXJDb21wb25lbnQgfSBmcm9tICdAYXBvc2luL25nLWFxdWlsYS9wb3BvdmVyJztcbmltcG9ydCB7IGdldEZvbnRTaG9ydGhhbmQgfSBmcm9tICdAYXBvc2luL25nLWFxdWlsYS91dGlscyc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzdGFydFdpdGgsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqIFR5cGUgdG8gZGV0ZXJtaW5lIHRoZSBtaW5pbWFsIHdpZHRoIG9mIGEgd29yZC4gKi9cbmV4cG9ydCB0eXBlIFNJWkVTID0gJ3JlZ3VsYXInIHwgJ3Nob3J0JyB8ICdsb25nJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdueC13b3JkJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3dvcmQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWyd3b3JkLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgaG9zdDoge1xuICAgICAgICAnW2NsYXNzLnNpemUtc2hvcnRdJzogJ3NpemUgPT0gXCJzaG9ydFwiJyxcbiAgICAgICAgJ1tjbGFzcy5zaXplLXJlZ3VsYXJdJzogJ3NpemUgPT0gXCJyZWd1bGFyXCInLFxuICAgICAgICAnW2NsYXNzLnNpemUtbG9uZ10nOiAnc2l6ZSA9PSBcImxvbmdcIicsXG4gICAgICAgICdbY2xhc3MuaGFzLWVycm9yXSc6ICdfaGFzRXJyb3JzJyxcbiAgICAgICAgJ1tjbGFzcy5pcy1mb2N1c2VkXSc6ICdpc0ZvY3VzZWQnLFxuICAgICAgICAnW2NsYXNzLmlzLWZpbGxlZF0nOiAnaXNGaWxsZWQnLFxuICAgICAgICAnW2NsYXNzLmhhcy1kcm9wZG93bl0nOiAnaGFzRHJvcGRvd24nLFxuICAgIH0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE54V29yZENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgICBwcml2YXRlIG1lYXN1cmVDYW52YXMhOiBIVE1MQ2FudmFzRWxlbWVudDtcblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgaW5wdXRDaGFuZ2VzID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgX2hhc0Vycm9ycyA9IGZhbHNlO1xuICAgIHByaXZhdGUgX292ZXJsYXlSZWYhOiBPdmVybGF5UmVmO1xuICAgIHByaXZhdGUgX2VtYmVkZGVkVmlld1JlZiE6IEVtYmVkZGVkVmlld1JlZjxhbnk+O1xuICAgIHByaXZhdGUgX292ZXJsYXlTdGF0ZSE6IE92ZXJsYXlDb25maWc7XG5cbiAgICBAQ29udGVudENoaWxkKE54Rm9ybWZpZWxkQ29udHJvbCkgX2NvbnRyb2whOiBOeEZvcm1maWVsZENvbnRyb2w8YW55PjtcbiAgICBAQ29udGVudENoaWxkcmVuKE54Rm9ybWZpZWxkRXJyb3JEaXJlY3RpdmUpIF9lcnJvckNoaWxkcmVuITogUXVlcnlMaXN0PE54Rm9ybWZpZWxkRXJyb3JEaXJlY3RpdmU+O1xuICAgIEBWaWV3Q2hpbGQoJ3BvcG92ZXInLCB7IHN0YXRpYzogdHJ1ZSB9KSBfcG9wb3ZlciE6IE54UG9wb3ZlckNvbXBvbmVudDtcbiAgICBAQ29udGVudENoaWxkKE54RHJvcGRvd25Db21wb25lbnQpIF9kcm9wZG93biE6IE54RHJvcGRvd25Db21wb25lbnQ7XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUud2lkdGgucHgnKVxuICAgIGN1cnJlbnRUZXh0V2lkdGggPSAwO1xuXG4gICAgLy8gdGhpcyB3aWxsIGFwcGx5IGRpZmZlcmVudCBtaW4td2lkdGhzIHRvIG91ciBjb21wb25lbnQgdGhyb3VnaCBvdXIgc3R5bGVzXG4gICAgLyoqIFByb3ZpZGUgYSBoaW50IGZvciBhIG1pbmltYWwgd2lkdGguIFRoZSBhY3R1YWwgc2l6ZSB3aWxsIGJlIGRldGVybWluZWQgZm9yIGlucHV0cyBmb3IgZWFjaCBjaGFuZ2UuICovXG4gICAgQElucHV0KCdueFNpemUnKSBzaXplOiBTSVpFUyA9ICdyZWd1bGFyJztcblxuICAgIC8qKlxuICAgICAqIEEgd29yZCBkb2Vzbid0IGhhdmUgYSBzZXQgcGxhY2UgdG8gc2hvdyBsYWJlbHMuXG4gICAgICogSW4gb3JkZXIgdG8gYmUgYWNjZXNzaWJsZSwgeW91IGhhdmUgdG8gcHJvdmlkZSBhIGxhYmVsIHdpdGggdGhpcyBwcm9wZXJ0eS5cbiAgICAgKiBJdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBnaXZlbiBpbnB1dCB0aHJvdWdoIGBhcmlhLWxhYmVsYC5cbiAgICAgKi9cbiAgICBASW5wdXQoJ254TGFiZWwnKSBsYWJlbCA9ICcnO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBfZGVzdHJveWVkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAvKiogQGRvY3MtcHJpdmF0ZSAqLyBwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBfY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgcHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgcHJpdmF0ZSBfb3ZlcmxheVBvc2l0aW9uQnVpbGRlcjogT3ZlcmxheVBvc2l0aW9uQnVpbGRlcixcbiAgICApIHt9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXR1cEVycm9yUG9wb3ZlcigpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGVDb250cm9sQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5fY29udHJvbC5zdGF0ZUNoYW5nZXMucGlwZShzdGFydFdpdGgobnVsbCksIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5faGFzRXJyb3JzID0gdGhpcy5fY29udHJvbC5lcnJvclN0YXRlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFcnJvclBvcG92ZXJTdGF0ZSgpO1xuICAgICAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbmdjb250cm9sIGF2YWlsYWJsZSBzdGljayB0byBpdHMgdmFsdWVDaGFuZ2VzIHN1YmplY3RcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRyb2wubmdDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250cm9sLm5nQ29udHJvbC52YWx1ZUNoYW5nZXMhLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDdXJyZW50VGV4dFdpZHRoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dENoYW5nZXMubmV4dCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpbiBhbnkgb3RoZXIgY2FzZSBpdCBpcyBhIGJyZSBpbnB1dCBhbmQgaW5wdXQgY2hhbmdlcyBhcmUgc2lnbmFsZWQgdGhyb3VnaCBzaW1wbGUgc3RhdGUgY2hhbmdlc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29udHJvbC5zdGF0ZUNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRUZXh0V2lkdGgoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0Q2hhbmdlcy5uZXh0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRyb2wuc2V0QXJpYUxhYmVsISh0aGlzLmxhYmVsKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkLm5leHQoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgQGRvY3MtcHJpdmF0ZVxuICAgIENhbGN1bGF0ZSB0aGUgd2lkdGggb2YgdGhlIGZ1bGwgdGV4dCBnaXZlbiBieSB0aGUgaW5wdXQsXG4gICAgdGhhdCB2YWx1ZSBpcyBib3VuZCB0byB0aGlzIGNvbXBvbmVudCBzbyBpdCBjYW4gZ3Jvdy5cblxuICAgIFRoZSBpbnZvbHZlZCBpbnB1dCBpcyBrbm93biB0byBoYXZlIGEgd2lkdGggb2YgMTAwJSBhbiB3aWxsIGZpdCB0aGUgYWRkaXRpb25hbCBzcGFjZSBnaXZlblxuICAgIHdoaWNoIGNvbXBsZXRlcyB0aGUgYXV0byBncm93aW5nIGJlaGF2aW9yLlxuICAqL1xuICAgIHVwZGF0ZUN1cnJlbnRUZXh0V2lkdGgoKSB7XG4gICAgICAgIC8vIHByb3ZpZGUgdGhlIGNhbnZhcyBvbmx5IGxhenlcbiAgICAgICAgaWYgKCF0aGlzLm1lYXN1cmVDYW52YXMpIHtcbiAgICAgICAgICAgIHRoaXMubWVhc3VyZUNhbnZhcyA9IHRoaXMuX3JlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5tZWFzdXJlQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGNvbnN0IGlucHV0UmVmID0gdGhpcy5fY29udHJvbC5lbGVtZW50UmVmO1xuICAgICAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShpbnB1dFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgY3R4IS5mb250ID0gZ2V0Rm9udFNob3J0aGFuZChzdHlsZXMpO1xuXG4gICAgICAgIGNvbnN0IG1ldHJpY3MgPSBjdHghLm1lYXN1cmVUZXh0KHRoaXMuX2NvbnRyb2wudmFsdWUpO1xuICAgICAgICAvLyBhZGQgMXB4IChjdXJzb3Igd2lkdGgpIHRvIHByZXZlbnQganVtcGluZyBvZiB0aGUgdGV4dCBvbiBibHVyLlxuICAgICAgICBjb25zdCBuZXdXaWR0aCA9IG1ldHJpY3Mud2lkdGggKyBwYXJzZUludChzdHlsZXMucGFkZGluZ1JpZ2h0LCAxMCkgKyBwYXJzZUludChzdHlsZXMucGFkZGluZ0xlZnQsIDEwKSArIDE7XG5cbiAgICAgICAgLy8gVGhpcyBzaG91bGQgYmUgaW5qZWN0ZWQgdmlhIEBIb3N0IHRvIGdldCBhbiBleGFjdCByZWZlcmVuY2UgdG8gTnhOYXR1cmFsTGFuZ3VhZ2VGb3JtQ29tcG9uZW50XG4gICAgICAgIC8vIFdvcmtzIGFzIHByb21pc2VkIGFzIGxvbmcgYXMgdGhlcmUgaXMgbm90IG90aGVyIHRhZyBhcm91bmQgdGhlIHdvcmQuIE5vdCBleHBlY3RlZCBidXQgcG9zc2libGUuXG4gICAgICAgIGNvbnN0IHBhcmVudDogSFRNTEVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBjb25zdCBwYXJlbnRNZWFzdXJlbWVudCA9IHBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAvLyBMaW1pdCB0byBvd24gZ2l2ZW4gbWluaW1hbCB3aWR0aFxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0V2lkdGggPSBNYXRoLm1heChwYXJzZUludChzdHlsZXMubWluV2lkdGgsIDEwKSwgbmV3V2lkdGgpO1xuXG4gICAgICAgIC8vIExpbWl0IHRvIGNvbnRhaW5lciB3aWR0aFxuICAgICAgICB0aGlzLmN1cnJlbnRUZXh0V2lkdGggPSBNYXRoLm1pbih0aGlzLmN1cnJlbnRUZXh0V2lkdGgsIHBhcmVudE1lYXN1cmVtZW50LndpZHRoKTtcblxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSEuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgcmVwb3NpdGlvbkVycm9yKCkge1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5U3RhdGUucG9zaXRpb25TdHJhdGVneSEuYXBwbHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhaWwgaWYgdGhlIHJlcXVpcmVkIGNvbnRyb2wgaXMgbWlzc2luZy5cbiAgICBwcm90ZWN0ZWQgX3ZhbGlkYXRlQ29udHJvbENoaWxkKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRyb2wpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTnhXb3JkQ29tcG9uZW50IHJlcXVpcmVzIGFuIE54Rm9ybWZpZWxkQ29udHJvbCBjb21wYXRpYmxlIGlucHV0LicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBnZXRDb25uZWN0ZWRPdmVybGF5T3JpZ2luKCk6IEVsZW1lbnRSZWYge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGlzRm9jdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRyb2wuZm9jdXNlZDtcbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGdldCBpc0ZpbGxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9jb250cm9sLmVtcHR5O1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGhhc0Ryb3Bkb3duKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9kcm9wZG93bik7XG4gICAgfVxuXG4gICAgdXBkYXRlRXJyb3JQb3BvdmVyU3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNFcnJvcnMgJiYgdGhpcy5fZXJyb3JDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dQb3BvdmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpZGVQb3BvdmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXR1cEVycm9yUG9wb3ZlcigpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25TdHJhdGVneSA9IHRoaXMuX292ZXJsYXlQb3NpdGlvbkJ1aWxkZXJcbiAgICAgICAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuZWxlbWVudFJlZilcbiAgICAgICAgICAgIC53aXRoTG9ja2VkUG9zaXRpb24odHJ1ZSlcbiAgICAgICAgICAgIC53aXRoRmxleGlibGVEaW1lbnNpb25zKGZhbHNlKVxuICAgICAgICAgICAgLndpdGhQdXNoKHRydWUpXG4gICAgICAgICAgICAud2l0aFBvc2l0aW9ucyhbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luWTogJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVk6ICdib3R0b20nLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luWTogJ2JvdHRvbScsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlYOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVk6ICd0b3AnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKVxuICAgICAgICAgICAgLndpdGhEZWZhdWx0T2Zmc2V0WSgtOCk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcmxheVN0YXRlID0gbmV3IE92ZXJsYXlDb25maWcoKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgPSBwb3NpdGlvblN0cmF0ZWd5O1xuICAgICAgICB0aGlzLl9vdmVybGF5U3RhdGUuc2Nyb2xsU3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUodGhpcy5fb3ZlcmxheVN0YXRlKTtcblxuICAgICAgICAodGhpcy5fb3ZlcmxheVN0YXRlLnBvc2l0aW9uU3RyYXRlZ3kgYXMgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5KS5wb3NpdGlvbkNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSkuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWlyID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkFycm93KHBhaXIpO1xuXG4gICAgICAgICAgICAvLyBUaGVzZSBwb3NpdGlvbiBjaGFuZ2VzIGFycml2ZSB0b28gbGF0ZSxcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gdHJpZ2dlciB0aGUgY2hhbmdlIGRldGVjdGlvbiBtYW51YWxseVxuICAgICAgICAgICAgLy8gYXMgaXQncyBkZXRhY2hlZCBmcm9tIGFueSByZW5kZXIgaGllcmFyY2h5XG4gICAgICAgICAgICAvLyBhbmQgb25seSB1cGRhdGVkIGJ5IHRoZSBvdmVybGF5IHdoZW4gYXR0YWNoZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5fZW1iZWRkZWRWaWV3UmVmICYmICF0aGlzLl9lbWJlZGRlZFZpZXdSZWYuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvbkFycm93KHBhaXI6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudFBvc2l0aW9uWCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnRXaWR0aCA9IHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudExlZnRPZmZzZXQgPSB0aGlzLl9vdmVybGF5UmVmLm92ZXJsYXlFbGVtZW50LnBhcmVudEVsZW1lbnQhLm9mZnNldExlZnQ7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlFbGVtZW50TGVmdE9mZnNldCA9IHRoaXMuX292ZXJsYXlSZWYub3ZlcmxheUVsZW1lbnQub2Zmc2V0TGVmdDtcblxuICAgICAgICAvLyBjYWxjdWxhdGlvbiBmb3IgeCBwb3NpdGlvbiBvZiB0aGUgcGFyZW50IGVsZW1lbnQuIEluIHRoaXMgY2FzZSwgb3ZlcmxheSBsZWZ0IG9mZnNldCBpcyB0aGUgb25lIHRoaW5nIHRvIGNvbnNpZGVyLlxuICAgICAgICBjb25zdCB0YXJnZXRQb3NpdGlvbiA9IHBhcmVudEVsZW1lbnRQb3NpdGlvblggKyBwYXJlbnRFbGVtZW50V2lkdGggLSAocGFyZW50RWxlbWVudExlZnRPZmZzZXQgKyBvdmVybGF5RWxlbWVudExlZnRPZmZzZXQpO1xuXG4gICAgICAgIGlmIChwYWlyLm9yaWdpblkgPT09ICd0b3AnICYmIHBhaXIub3ZlcmxheVkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BvdmVyLmRpcmVjdGlvbiA9ICd0b3AnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcG9wb3Zlci5kaXJlY3Rpb24gPSAnYm90dG9tJztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BvcG92ZXIuYXJyb3dTdHlsZSA9IHsgbGVmdDogdGFyZ2V0UG9zaXRpb24gKyAncHgnIH07XG4gICAgfVxuXG4gICAgc2hvd1BvcG92ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZi5oYXNBdHRhY2hlZCgpKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sdGlwUG9ydGFsID0gbmV3IFRlbXBsYXRlUG9ydGFsKHRoaXMuX3BvcG92ZXIudGVtcGxhdGVSZWYsIHRoaXMuX3ZpZXdDb250YWluZXJSZWYpO1xuICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3UmVmID0gdGhpcy5fb3ZlcmxheVJlZi5hdHRhY2godG9vbHRpcFBvcnRhbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoaWRlUG9wb3ZlcigpIHtcbiAgICAgICAgdGhpcy5fb3ZlcmxheVJlZi5kZXRhY2goKTtcbiAgICB9XG59XG4iLCI8ZGl2PlxuICAgIDwhLS0gV2Ugb25seSBhbGxvdyBmb3JtZmllbGQgY29udHJvbHMgaGVyZSAtLT5cbiAgICA8ZGl2ICpuZ0lmPVwiIWhhc0Ryb3Bkb3duXCIgY2xhc3M9XCJueC13b3JkX19pbm5lci13cmFwcGVyXCI+XG4gICAgICAgIDxuZy1jb250ZW50IHNlbGVjdD1cIltueElucHV0XVwiPjwvbmctY29udGVudD5cbiAgICA8L2Rpdj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJueC1kcm9wZG93blwiPjwvbmctY29udGVudD5cbjwvZGl2PlxuXG48bngtcG9wb3ZlciAjcG9wb3Zlcj5cbiAgICA8bmctY29udGVudCBzZWxlY3Q9XCJbbnhFcnJvcl1cIj48L25nLWNvbnRlbnQ+XG48L254LXBvcG92ZXI+XG4iXX0=