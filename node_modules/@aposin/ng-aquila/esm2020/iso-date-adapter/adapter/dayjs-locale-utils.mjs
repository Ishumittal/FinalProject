import dayjs from 'dayjs';
import supportedLocales from 'dayjs/locale.json';
/**
 * This function turns a well-formatted locale into one that is known to dayjs.
 * To figure out what is known to dayjs this function makes use of the file `locale.json`
 * that is part of any dayjs relase (see https://day.js.org/docs/en/i18n/i18n).
 * To match the locale it follows the "lookup" logic specified in the RFC for
 * "Matching of Language Tags" (see https://www.rfc-editor.org/info/rfc4647).
 *
 * @example en-GB -> en-gb, en-US -> en, de-DE -> de, de-CH -> de-ch
 * @param localeId a "language-range" following the BCP 47 standard
 * @returns a "language-range" that is supported by dayjs
 */
export function convertToDayjsLocale(localeId) {
    let dayjsLocale = supportedLocales.find(locale => locale.key === localeId.toLowerCase());
    if (!dayjsLocale && localeId.includes('-')) {
        let localeParts = localeId.toLowerCase().split('-');
        while (localeParts.length > 0) {
            dayjsLocale = supportedLocales.find(locale => locale.key === localeParts.join('-'));
            if (dayjsLocale) {
                console.warn(`The locale '${localeId}' is not known to dayjs. Using closest match '${dayjsLocale.key}' instead.`);
                break;
            }
            localeParts = localeParts.slice(0, localeParts.length - 1);
        }
    }
    if (!dayjsLocale) {
        console.warn(`The locale '${localeId}' is not known to dayjs. Using the default 'en'.`);
        dayjsLocale = { key: 'en', name: '' };
    }
    return dayjsLocale.key;
}
/**
 * This function uses a dynamic import to load the dayjs data for the requested locale
 * and returns the localeData for this locale.
 *
 * @param localeId a "language-range" following the BCP 47 standard
 * @returns a Promise that resolves with the dayjs localeData for the given locale
 */
export async function getDayjsLocaleData(localeId) {
    return import(`dayjs/locale/${localeId}.js`)
        .then(() => dayjs().locale(localeId).localeData())
        .catch(() => {
        console.warn(`The requested dayjs locale '${localeId}' could not be loaded.`);
        // return the global localeData as fallback
        return dayjs.localeData();
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF5anMtbG9jYWxlLXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctYXF1aWxhL3NyYy9pc28tZGF0ZS1hZGFwdGVyL2FkYXB0ZXIvZGF5anMtbG9jYWxlLXV0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxNQUFNLE9BQU8sQ0FBQztBQUMxQixPQUFPLGdCQUFnQixNQUFNLG1CQUFtQixDQUFDO0FBRWpEOzs7Ozs7Ozs7O0dBVUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsUUFBZ0I7SUFDakQsSUFBSSxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsS0FBSyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUV6RixJQUFJLENBQUMsV0FBVyxJQUFJLFFBQVEsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDeEMsSUFBSSxXQUFXLEdBQUcsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNwRCxPQUFPLFdBQVcsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzNCLFdBQVcsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsR0FBRyxLQUFLLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNwRixJQUFJLFdBQVcsRUFBRTtnQkFDYixPQUFPLENBQUMsSUFBSSxDQUFDLGVBQWUsUUFBUSxpREFBaUQsV0FBVyxDQUFDLEdBQUcsWUFBWSxDQUFDLENBQUM7Z0JBQ2xILE1BQU07YUFDVDtZQUNELFdBQVcsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQzlEO0tBQ0o7SUFFRCxJQUFJLENBQUMsV0FBVyxFQUFFO1FBQ2QsT0FBTyxDQUFDLElBQUksQ0FBQyxlQUFlLFFBQVEsa0RBQWtELENBQUMsQ0FBQztRQUN4RixXQUFXLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUUsQ0FBQztLQUN6QztJQUVELE9BQU8sV0FBVyxDQUFDLEdBQUcsQ0FBQztBQUMzQixDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxDQUFDLEtBQUssVUFBVSxrQkFBa0IsQ0FBQyxRQUFnQjtJQUNyRCxPQUFPLE1BQU0sQ0FBQyxnQkFBZ0IsUUFBUSxLQUFLLENBQUM7U0FDdkMsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxVQUFVLEVBQUUsQ0FBQztTQUNqRCxLQUFLLENBQUMsR0FBRyxFQUFFO1FBQ1IsT0FBTyxDQUFDLElBQUksQ0FBQywrQkFBK0IsUUFBUSx3QkFBd0IsQ0FBQyxDQUFDO1FBQzlFLDJDQUEyQztRQUMzQyxPQUFPLEtBQUssQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUM5QixDQUFDLENBQUMsQ0FBQztBQUNYLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZGF5anMgZnJvbSAnZGF5anMnO1xuaW1wb3J0IHN1cHBvcnRlZExvY2FsZXMgZnJvbSAnZGF5anMvbG9jYWxlLmpzb24nO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdHVybnMgYSB3ZWxsLWZvcm1hdHRlZCBsb2NhbGUgaW50byBvbmUgdGhhdCBpcyBrbm93biB0byBkYXlqcy5cbiAqIFRvIGZpZ3VyZSBvdXQgd2hhdCBpcyBrbm93biB0byBkYXlqcyB0aGlzIGZ1bmN0aW9uIG1ha2VzIHVzZSBvZiB0aGUgZmlsZSBgbG9jYWxlLmpzb25gXG4gKiB0aGF0IGlzIHBhcnQgb2YgYW55IGRheWpzIHJlbGFzZSAoc2VlIGh0dHBzOi8vZGF5LmpzLm9yZy9kb2NzL2VuL2kxOG4vaTE4bikuXG4gKiBUbyBtYXRjaCB0aGUgbG9jYWxlIGl0IGZvbGxvd3MgdGhlIFwibG9va3VwXCIgbG9naWMgc3BlY2lmaWVkIGluIHRoZSBSRkMgZm9yXG4gKiBcIk1hdGNoaW5nIG9mIExhbmd1YWdlIFRhZ3NcIiAoc2VlIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL2luZm8vcmZjNDY0NykuXG4gKlxuICogQGV4YW1wbGUgZW4tR0IgLT4gZW4tZ2IsIGVuLVVTIC0+IGVuLCBkZS1ERSAtPiBkZSwgZGUtQ0ggLT4gZGUtY2hcbiAqIEBwYXJhbSBsb2NhbGVJZCBhIFwibGFuZ3VhZ2UtcmFuZ2VcIiBmb2xsb3dpbmcgdGhlIEJDUCA0NyBzdGFuZGFyZFxuICogQHJldHVybnMgYSBcImxhbmd1YWdlLXJhbmdlXCIgdGhhdCBpcyBzdXBwb3J0ZWQgYnkgZGF5anNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0RheWpzTG9jYWxlKGxvY2FsZUlkOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGxldCBkYXlqc0xvY2FsZSA9IHN1cHBvcnRlZExvY2FsZXMuZmluZChsb2NhbGUgPT4gbG9jYWxlLmtleSA9PT0gbG9jYWxlSWQudG9Mb3dlckNhc2UoKSk7XG5cbiAgICBpZiAoIWRheWpzTG9jYWxlICYmIGxvY2FsZUlkLmluY2x1ZGVzKCctJykpIHtcbiAgICAgICAgbGV0IGxvY2FsZVBhcnRzID0gbG9jYWxlSWQudG9Mb3dlckNhc2UoKS5zcGxpdCgnLScpO1xuICAgICAgICB3aGlsZSAobG9jYWxlUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZGF5anNMb2NhbGUgPSBzdXBwb3J0ZWRMb2NhbGVzLmZpbmQobG9jYWxlID0+IGxvY2FsZS5rZXkgPT09IGxvY2FsZVBhcnRzLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICBpZiAoZGF5anNMb2NhbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBsb2NhbGUgJyR7bG9jYWxlSWR9JyBpcyBub3Qga25vd24gdG8gZGF5anMuIFVzaW5nIGNsb3Nlc3QgbWF0Y2ggJyR7ZGF5anNMb2NhbGUua2V5fScgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZVBhcnRzID0gbG9jYWxlUGFydHMuc2xpY2UoMCwgbG9jYWxlUGFydHMubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRheWpzTG9jYWxlKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgVGhlIGxvY2FsZSAnJHtsb2NhbGVJZH0nIGlzIG5vdCBrbm93biB0byBkYXlqcy4gVXNpbmcgdGhlIGRlZmF1bHQgJ2VuJy5gKTtcbiAgICAgICAgZGF5anNMb2NhbGUgPSB7IGtleTogJ2VuJywgbmFtZTogJycgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF5anNMb2NhbGUua2V5O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gdXNlcyBhIGR5bmFtaWMgaW1wb3J0IHRvIGxvYWQgdGhlIGRheWpzIGRhdGEgZm9yIHRoZSByZXF1ZXN0ZWQgbG9jYWxlXG4gKiBhbmQgcmV0dXJucyB0aGUgbG9jYWxlRGF0YSBmb3IgdGhpcyBsb2NhbGUuXG4gKlxuICogQHBhcmFtIGxvY2FsZUlkIGEgXCJsYW5ndWFnZS1yYW5nZVwiIGZvbGxvd2luZyB0aGUgQkNQIDQ3IHN0YW5kYXJkXG4gKiBAcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBkYXlqcyBsb2NhbGVEYXRhIGZvciB0aGUgZ2l2ZW4gbG9jYWxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXREYXlqc0xvY2FsZURhdGEobG9jYWxlSWQ6IHN0cmluZyk6IFByb21pc2U8ZGF5anMuSW5zdGFuY2VMb2NhbGVEYXRhUmV0dXJuPiB7XG4gICAgcmV0dXJuIGltcG9ydChgZGF5anMvbG9jYWxlLyR7bG9jYWxlSWR9LmpzYClcbiAgICAgICAgLnRoZW4oKCkgPT4gZGF5anMoKS5sb2NhbGUobG9jYWxlSWQpLmxvY2FsZURhdGEoKSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIHJlcXVlc3RlZCBkYXlqcyBsb2NhbGUgJyR7bG9jYWxlSWR9JyBjb3VsZCBub3QgYmUgbG9hZGVkLmApO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBnbG9iYWwgbG9jYWxlRGF0YSBhcyBmYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuIGRheWpzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgfSk7XG59XG4iXX0=