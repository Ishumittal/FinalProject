import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ESCAPE } from '@angular/cdk/keycodes';
import { Overlay, } from '@angular/cdk/overlay';
import { ComponentPortal } from '@angular/cdk/portal';
import { Directive, Inject, InjectionToken, Input, Optional } from '@angular/core';
import { Subject } from 'rxjs';
import { take, takeUntil } from 'rxjs/operators';
import { NxTooltipComponent } from './tooltip.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/cdk/scrolling";
import * as i3 from "@angular/cdk/platform";
import * as i4 from "@angular/cdk/a11y";
import * as i5 from "@angular/cdk/bidi";
const BASE_OFFSET = 12;
/** Injection token that determines the scroll handling while a tooltip is open. */
export const NX_TOOLTIP_SCROLL_STRATEGY = new InjectionToken('nx-tooltip-scroll-strategy');
/** @docs-private */
export function NX_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/** @docs-private */
export const NX_TOOLTIP_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_TOOLTIP_SCROLL_STRATEGY,
    useFactory: NX_TOOLTIP_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
/**
 * CSS class that will be attached to the overlay panel.
 * @docs-private
 */
export const NX_TOOLTIP_PANEL_CLASS = 'nx-tooltip-panel';
/**
 * Creates an error to be thrown if the user provided an invalid tooltip position.
 * @docs-private
 */
export function getNxTooltipInvalidPositionError(position) {
    return Error(`Tooltip position "${position}" is invalid.`);
}
/** Injection token to be used to override the default options for `nxTooltip`. */
export const NX_TOOLTIP_DEFAULT_OPTIONS = new InjectionToken('nx-tooltip-default-options', {
    providedIn: 'root',
    factory: NX_TOOLTIP_DEFAULT_OPTIONS_FACTORY,
});
export function NX_TOOLTIP_DEFAULT_OPTIONS_FACTORY() {
    return {
        showDelay: 200,
        hideDelay: 200,
        touchendHideDelay: 1500,
    };
}
/**
 * Directive that attaches a tooltip to the host element.
 *
 */
export class NxTooltipDirective {
    constructor(_overlay, _elementRef, _scrollDispatcher, _viewContainerRef, _ngZone, platform, _ariaDescriber, _focusMonitor, _dir, _defaultOptions, _defaultScrollStrategyFactory) {
        this._overlay = _overlay;
        this._elementRef = _elementRef;
        this._scrollDispatcher = _scrollDispatcher;
        this._viewContainerRef = _viewContainerRef;
        this._ngZone = _ngZone;
        this._ariaDescriber = _ariaDescriber;
        this._focusMonitor = _focusMonitor;
        this._dir = _dir;
        this._defaultOptions = _defaultOptions;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this._position = 'bottom';
        this._disabled = false;
        this._selectable = false;
        this._possibleTooltipPositions = ['bottom', 'top', 'left', 'right'];
        /** The default delay in ms before showing the tooltip after show is called */
        this.showDelay = this._defaultOptions.showDelay;
        /** The default delay in ms before hiding the tooltip after hide is called */
        this.hideDelay = this._defaultOptions.hideDelay;
        this._message = '';
        /** Strategy factory that will be used to handle scrolling while the tooltip panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
        this._manualListeners = new Map();
        this._destroyed = new Subject();
        this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(this._dirChangeHandler.bind(this));
        const element = _elementRef.nativeElement;
        // The mouse events shouldn't be bound on mobile devices, because they can prevent the
        // first tap from firing its click event or can cause the tooltip to open for clicks.
        if (!platform.IOS && !platform.ANDROID) {
            this._manualListeners.set('mouseenter', () => this.show()).set('mouseleave', () => this.hide());
        }
        else {
            // Fall back to showing on `touchstart`, otherwise
            // there's no way for the user to trigger the tooltip on a touch device.
            this._manualListeners.set('touchstart', () => this.show());
        }
        this._manualListeners.forEach((listener, event) => element.addEventListener(event, listener));
        _focusMonitor
            .monitor(_elementRef)
            .pipe(takeUntil(this._destroyed))
            .subscribe(origin => {
            // Note that the focus monitor runs outside the Angular zone.
            if (!origin) {
                _ngZone.run(() => this.hide(0));
            }
            else if (origin === 'keyboard') {
                _ngZone.run(() => this.show());
            }
        });
        if (_defaultOptions?.position) {
            this.position = _defaultOptions.position;
        }
    }
    /** Allows the user to define the position of the tooltip relative to the parent element */
    get position() {
        return this._position;
    }
    set position(value) {
        if (value !== this._position) {
            this._position = value;
            if (this._overlayRef) {
                this._updatePosition();
                if (this._tooltipInstance) {
                    this._tooltipInstance.position = this._position;
                    this._tooltipInstance.show(0);
                }
                this._overlayRef.updatePosition();
            }
        }
    }
    /** Disables the display of the tooltip. */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        this._disabled = coerceBooleanProperty(value);
        // If tooltip is disabled, hide immediately.
        if (this._disabled) {
            this.hide(0);
        }
    }
    /** Allows selection of text within tooltip trigger
     *  NOTE: inputs and textareas always remain selectable, ignoring this input.
     */
    get selectable() {
        return this._selectable;
    }
    set selectable(value) {
        const oldValue = this._selectable;
        this._selectable = coerceBooleanProperty(value);
        if (this._selectable !== oldValue) {
            this._updateSelectabilityStyles();
        }
    }
    /** The message to be displayed in the tooltip */
    get message() {
        return this._message;
    }
    set message(value) {
        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this._message);
        // If the message is not a string (e.g. number), convert it to a string and trim it.
        this._message = value != null ? `${value}`.trim() : '';
        if (!this._message && this._isTooltipVisible()) {
            this.hide(0);
        }
        else {
            this._updateTooltipMessage();
            this._ariaDescriber.describe(this._elementRef.nativeElement, this.message);
        }
    }
    ngOnInit() {
        this._updateSelectabilityStyles();
    }
    /**
     * Dispose the tooltip when destroyed.
     */
    ngOnDestroy() {
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._tooltipInstance = null;
        }
        // Clean up the event listeners set in the constructor
        this._manualListeners.forEach((listener, event) => {
            this._elementRef.nativeElement.removeEventListener(event, listener);
        });
        this._manualListeners.clear();
        this._destroyed.next();
        this._destroyed.complete();
        this._ariaDescriber.removeDescription(this._elementRef.nativeElement, this.message);
        this._focusMonitor.stopMonitoring(this._elementRef);
    }
    /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show or 0ms if no input */
    show(delay = this.showDelay) {
        if (this.disabled || !this.message || (this._isTooltipVisible() && !this._tooltipInstance?.isDelayed())) {
            return;
        }
        const overlayRef = this._createOverlay();
        this._detach();
        this._portal = this._portal || new ComponentPortal(NxTooltipComponent, this._viewContainerRef);
        this._embeddedViewRef = overlayRef.attach(this._portal);
        this._tooltipInstance = this._embeddedViewRef.instance;
        this._tooltipInstance
            .afterHidden()
            .pipe(takeUntil(this._destroyed))
            .subscribe(() => this._detach());
        this._updateTooltipMessage();
        this._tooltipInstance.show(delay);
    }
    /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide or 0ms if no input */
    hide(delay = this.hideDelay) {
        if (this._tooltipInstance) {
            this._tooltipInstance.hide(delay);
        }
    }
    /** Shows/hides the tooltip */
    toggle() {
        this._isTooltipVisible() ? this.hide() : this.show();
    }
    /** Returns true if the tooltip is currently visible to the user */
    _isTooltipVisible() {
        return !!this._tooltipInstance && this._tooltipInstance.isVisible();
    }
    /** Handles the keydown events on the host element. */
    _handleKeydown(e) {
        if (this._isTooltipVisible() && e.keyCode === ESCAPE) {
            e.stopPropagation();
            this.hide(0);
        }
    }
    /** Handles the touchend events on the host element. */
    _handleTouchend() {
        this.hide(this._defaultOptions?.touchendHideDelay);
    }
    /**
     * Setup styling-specific things
     */
    _updateSelectabilityStyles() {
        const element = this._elementRef.nativeElement;
        const elementStyle = element.style;
        const isSelectable = element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA' || this._selectable;
        const userSelect = isSelectable ? 'auto' : 'none';
        elementStyle.webkitUserSelect = elementStyle.userSelect = elementStyle.msUserSelect = userSelect;
    }
    /** Create the overlay config and position strategy */
    _createOverlay() {
        if (this._overlayRef && !!this._overlayRef.hostElement) {
            return this._overlayRef;
        }
        const scrollableAncestors = this._scrollDispatcher.getAncestorScrollContainers(this._elementRef);
        // Create connected position strategy that listens for scroll events to reposition.
        const strategy = this._overlay.position().flexibleConnectedTo(this._elementRef).withLockedPosition(true).withFlexibleDimensions(false).withPush(true);
        strategy.withScrollableContainers(scrollableAncestors);
        strategy.positionChanges.pipe(takeUntil(this._destroyed)).subscribe(change => {
            if (this._tooltipInstance) {
                const pair = change.connectionPair;
                this._ngZone.run(() => this._positionArrow(pair));
                if (change.scrollableViewProperties.isOverlayClipped && this._tooltipInstance.isVisible()) {
                    // After position changes occur and the overlay is clipped by
                    // a parent scrollable then close the tooltip.
                    this._ngZone.run(() => this.hide(0));
                }
            }
        });
        this._overlayRef = this._overlay.create({
            direction: this._dir?.value || 'ltr',
            positionStrategy: strategy,
            panelClass: NX_TOOLTIP_PANEL_CLASS,
            scrollStrategy: this._scrollStrategyFactory(),
            disposeOnNavigation: true,
        });
        this._updatePosition();
        this._overlayRef
            .detachments()
            .pipe(takeUntil(this._destroyed))
            .subscribe(() => this._detach());
        return this._overlayRef;
    }
    /** Detaches the currently-attached tooltip. */
    _detach() {
        if (this._overlayRef?.hasAttached()) {
            this._overlayRef.detach();
        }
        this._tooltipInstance = null;
    }
    /** Updates the position of the current tooltip. */
    _updatePosition() {
        if (!this._overlayRef) {
            return;
        }
        const position = this._overlayRef.getConfig().positionStrategy;
        const origin = this._getOrigin(this.position);
        const overlay = this._getOverlayPosition(this.position);
        const offset = this._getOffset(this.position);
        const fallbacks = this._getFallbackPositions(this.position);
        position.withPositions([
            {
                ...origin,
                ...overlay,
                ...offset,
            },
            ...fallbacks,
        ]);
    }
    /**
     * Returns the origin position based on the user's position preference.
     */
    _getOrigin(position) {
        switch (position) {
            case 'top':
            case 'bottom': {
                return {
                    originX: 'center',
                    originY: position,
                };
            }
            case 'left': {
                return {
                    originX: this._isLtr ? 'start' : 'end',
                    originY: 'center',
                };
            }
            case 'right': {
                return {
                    originX: this._isLtr ? 'end' : 'start',
                    originY: 'center',
                };
            }
            default: {
                throw getNxTooltipInvalidPositionError(position);
            }
        }
    }
    /** Returns the overlay position based on the user's preference */
    _getOverlayPosition(position) {
        switch (position) {
            case 'top':
            case 'bottom': {
                return {
                    overlayX: 'center',
                    overlayY: this._getInversePosition(position),
                };
            }
            case 'left': {
                return {
                    overlayX: this._isLtr ? 'end' : 'start',
                    overlayY: 'center',
                };
            }
            case 'right': {
                return {
                    overlayX: this._isLtr ? 'start' : 'end',
                    overlayY: 'center',
                };
            }
            default: {
                throw getNxTooltipInvalidPositionError(position);
            }
        }
    }
    /** Returns the overlay offset required by the user's position preference */
    _getOffset(position) {
        switch (position) {
            case 'top': {
                return {
                    offsetY: BASE_OFFSET * -1,
                };
            }
            case 'bottom': {
                return {
                    offsetY: BASE_OFFSET,
                };
            }
            case 'left': {
                return {
                    offsetX: BASE_OFFSET * -1,
                };
            }
            case 'right': {
                return {
                    offsetX: BASE_OFFSET,
                };
            }
            default: {
                throw getNxTooltipInvalidPositionError(position);
            }
        }
    }
    /** Returns the opposite position, using aquila tooltip position naming: top, right, bottom, left */
    _getInverseTooltipPosition(position) {
        const tooltopPositionPairs = {
            top: 'bottom',
            right: 'left',
            bottom: 'top',
            left: 'right',
        };
        return tooltopPositionPairs[position];
    }
    /** Returns the opposite position, using angular position naming: top, bottom, start, end, center */
    _getInversePosition(position) {
        const positionPairs = {
            top: 'bottom',
            bottom: 'top',
            start: 'end',
            end: 'start',
            center: 'center',
        };
        return positionPairs[position];
    }
    /** Returns an array of fallback positions for tooltip, following the algoritm:
     * 1) Slightly alternate preferred position if applicable. I.e. for 'top' try 'top-start' and 'top-end' positioning.
     * 2) Try the opposite position, i.e. for 'top' try 'bottom'.
     * 3) Slightly alternate opposite position, i.e. 'bottom-start', 'bottom-end'
     * 4) All remaining positions from positions list
     */
    _getFallbackPositions(position, possiblePositions = this._possibleTooltipPositions) {
        if (!position) {
            return [];
        }
        const remainigPositions = possiblePositions.filter(possiblePosition => possiblePosition !== position);
        let fallbackPositions = [];
        switch (position) {
            case 'top':
            case 'bottom': {
                fallbackPositions = this._getVerticalFallbackPositionPairs(position);
                break;
            }
            case 'left':
            case 'right': {
                fallbackPositions = this._getHorizontalFallbackPositionPairs(position);
                break;
            }
        }
        const inversePosition = this._getInverseTooltipPosition(position);
        const nextFallbackPosition = remainigPositions.includes(inversePosition) ? inversePosition : possiblePositions[0];
        return [...fallbackPositions, ...this._getFallbackPositions(nextFallbackPosition, remainigPositions)];
    }
    /** Calculates fallbacks for vertical tooltip positioning */
    _getVerticalFallbackPositionPairs(position) {
        const isSelectedPosition = position === this.position;
        const verticalFallbackPositionPairs = [];
        const basePositionPair = {
            ...this._getOrigin(position),
            ...this._getOverlayPosition(position),
            ...this._getOffset(position),
        };
        if (!isSelectedPosition) {
            // HINT: selected position matches basePosition, so we don't need to repeat it in fallback
            verticalFallbackPositionPairs.push(basePositionPair);
        }
        verticalFallbackPositionPairs.push({
            ...basePositionPair,
            originX: 'start',
            overlayX: 'start',
        }, {
            ...basePositionPair,
            originX: 'end',
            overlayX: 'end',
        });
        return verticalFallbackPositionPairs;
    }
    /** Calculates fallbacks for horizontal tooltip positioning */
    _getHorizontalFallbackPositionPairs(position) {
        const offset = this._getOffset(position);
        return [
            {
                ...this._getOrigin(position),
                ...this._getOverlayPosition(position),
                ...offset,
            },
        ];
    }
    /** Updates the tooltip message and repositions the overlay according to the new message length */
    _updateTooltipMessage() {
        // Must wait for the message to be painted to the tooltip so that the overlay can properly
        // calculate the correct positioning based on the size of the text.
        if (this._tooltipInstance) {
            this._tooltipInstance.message = this.message;
            this._ngZone.onMicrotaskEmpty
                .asObservable()
                .pipe(take(1), takeUntil(this._destroyed))
                .subscribe(() => {
                if (this._tooltipInstance && this._overlayRef) {
                    this._overlayRef.updatePosition();
                }
            });
        }
    }
    _positionArrow(pair) {
        if (!this._overlayRef || !this._tooltipInstance) {
            return;
        }
        const parentElementPositionX = this._elementRef.nativeElement.getBoundingClientRect().left;
        const parentElementWidth = this._elementRef.nativeElement.getBoundingClientRect().width / 2;
        const overlayElementLeftOffset = this._overlayRef.overlayElement.getBoundingClientRect().left;
        // calculation for x position of the parent element. In this case, overlay left offset is the one thing to consider.
        const targetPosition = parentElementPositionX + parentElementWidth - overlayElementLeftOffset;
        if (pair.originX === pair.overlayX) {
            const arrowStyle = { left: targetPosition + 'px' };
            this._tooltipInstance.arrowStyle = arrowStyle;
        }
        if (pair.originX === 'end' && pair.overlayX === 'start') {
            this._tooltipInstance.arrowStyle = {
                top: '50%',
            };
            this._tooltipInstance.position = 'right';
        }
        else if (pair.originY === 'bottom' && pair.overlayY === 'top') {
            this._tooltipInstance.arrowStyle = {
                left: targetPosition + 'px',
            };
            this._tooltipInstance.position = 'bottom';
        }
        else if (pair.originX === 'start' && pair.overlayX === 'end') {
            this._tooltipInstance.arrowStyle = {
                top: '50%',
            };
            this._tooltipInstance.position = 'left';
        }
        else if (pair.originY === 'top' && pair.overlayY === 'bottom') {
            this._tooltipInstance.arrowStyle = {
                left: targetPosition + 'px',
            };
            this._tooltipInstance.position = 'top';
        }
    }
    _dirChangeHandler(value) {
        if (this._overlayRef) {
            this.hide(0);
            this._overlayRef.setDirection(value);
            this._updatePosition();
        }
    }
    get _isLtr() {
        return !this._dir || this._dir.value === 'ltr';
    }
}
NxTooltipDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTooltipDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i2.ScrollDispatcher }, { token: i0.ViewContainerRef }, { token: i0.NgZone }, { token: i3.Platform }, { token: i4.AriaDescriber }, { token: i4.FocusMonitor }, { token: i5.Directionality, optional: true }, { token: NX_TOOLTIP_DEFAULT_OPTIONS, optional: true }, { token: NX_TOOLTIP_SCROLL_STRATEGY }], target: i0.ɵɵFactoryTarget.Directive });
NxTooltipDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxTooltipDirective, selector: "[nxTooltip]", inputs: { position: ["nxTooltipPosition", "position"], disabled: ["nxTooltipDisabled", "disabled"], selectable: ["nxTooltipSelectable", "selectable"], showDelay: ["nxTooltipShowDelay", "showDelay"], hideDelay: ["nxTooltipHideDelay", "hideDelay"], message: ["nxTooltip", "message"] }, host: { listeners: { "keydown": "_handleKeydown($event)", "touchend": "_handleTouchend()" } }, exportAs: ["nxTooltip"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTooltipDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxTooltip]',
                    exportAs: 'nxTooltip',
                    host: {
                        '(keydown)': '_handleKeydown($event)',
                        '(touchend)': '_handleTouchend()',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i2.ScrollDispatcher }, { type: i0.ViewContainerRef }, { type: i0.NgZone }, { type: i3.Platform }, { type: i4.AriaDescriber }, { type: i4.FocusMonitor }, { type: i5.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [NX_TOOLTIP_DEFAULT_OPTIONS]
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NX_TOOLTIP_SCROLL_STRATEGY]
                }] }]; }, propDecorators: { position: [{
                type: Input,
                args: ['nxTooltipPosition']
            }], disabled: [{
                type: Input,
                args: ['nxTooltipDisabled']
            }], selectable: [{
                type: Input,
                args: ['nxTooltipSelectable']
            }], showDelay: [{
                type: Input,
                args: ['nxTooltipShowDelay']
            }], hideDelay: [{
                type: Input,
                args: ['nxTooltipHideDelay']
            }], message: [{
                type: Input,
                args: ['nxTooltip']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbHRpcC5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL3Rvb2x0aXAvdG9vbHRpcC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFnQixxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUMvQyxPQUFPLEVBS0gsT0FBTyxHQUtWLE1BQU0sc0JBQXNCLENBQUM7QUFFOUIsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXRELE9BQU8sRUFBZ0IsU0FBUyxFQUFjLE1BQU0sRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUE2QixRQUFRLEVBQW9CLE1BQU0sZUFBZSxDQUFDO0FBQzFKLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVqRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQzs7Ozs7OztBQUV6RCxNQUFNLFdBQVcsR0FBRyxFQUFFLENBQUM7QUFTdkIsbUZBQW1GO0FBQ25GLE1BQU0sQ0FBQyxNQUFNLDBCQUEwQixHQUFHLElBQUksY0FBYyxDQUF1Qiw0QkFBNEIsQ0FBQyxDQUFDO0FBRWpILG9CQUFvQjtBQUNwQixNQUFNLFVBQVUsMkNBQTJDLENBQUMsT0FBZ0I7SUFDeEUsT0FBTyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDdkQsQ0FBQztBQUVELG9CQUFvQjtBQUNwQixNQUFNLENBQUMsTUFBTSxtQ0FBbUMsR0FBRztJQUMvQyxPQUFPLEVBQUUsMEJBQTBCO0lBQ25DLFVBQVUsRUFBRSwyQ0FBMkM7SUFDdkQsSUFBSSxFQUFF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LFFBQVEsRUFBRSxXQUFXO29CQUNyQixJQUFJLEVBQUU7d0JBQ0YsV0FBVyxFQUFFLHdCQUF3Qjt3QkFDckMsWUFBWSxFQUFFLG1CQUFtQjtxQkFDcEM7aUJBQ0o7OzBCQTBHUSxRQUFROzswQkFDUixRQUFROzswQkFBSSxNQUFNOzJCQUFDLDBCQUEwQjs7MEJBQzdDLE1BQU07MkJBQUMsMEJBQTBCOzRDQTlGbEMsUUFBUTtzQkFEWCxLQUFLO3VCQUFDLG1CQUFtQjtnQkF1QnRCLFFBQVE7c0JBRFgsS0FBSzt1QkFBQyxtQkFBbUI7Z0JBaUJ0QixVQUFVO3NCQURiLEtBQUs7dUJBQUMscUJBQXFCO2dCQWFDLFNBQVM7c0JBQXJDLEtBQUs7dUJBQUMsb0JBQW9CO2dCQUdFLFNBQVM7c0JBQXJDLEtBQUs7dUJBQUMsb0JBQW9CO2dCQU12QixPQUFPO3NCQURWLEtBQUs7dUJBQUMsV0FBVyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFyaWFEZXNjcmliZXIsIEZvY3VzTW9uaXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9hMTF5JztcbmltcG9ydCB7IERpcmVjdGlvbiwgRGlyZWN0aW9uYWxpdHkgfSBmcm9tICdAYW5ndWxhci9jZGsvYmlkaSc7XG5pbXBvcnQgeyBCb29sZWFuSW5wdXQsIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBFU0NBUEUgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHtcbiAgICBDb25uZWN0aW9uUG9zaXRpb25QYWlyLFxuICAgIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSxcbiAgICBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyxcbiAgICBPcmlnaW5Db25uZWN0aW9uUG9zaXRpb24sXG4gICAgT3ZlcmxheSxcbiAgICBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uLFxuICAgIE92ZXJsYXlSZWYsXG4gICAgU2Nyb2xsU3RyYXRlZ3ksXG4gICAgVmVydGljYWxDb25uZWN0aW9uUG9zLFxufSBmcm9tICdAYW5ndWxhci9jZGsvb3ZlcmxheSc7XG5pbXBvcnQgeyBQbGF0Zm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wbGF0Zm9ybSc7XG5pbXBvcnQgeyBDb21wb25lbnRQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IFNjcm9sbERpc3BhdGNoZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvc2Nyb2xsaW5nJztcbmltcG9ydCB7IENvbXBvbmVudFJlZiwgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbmplY3QsIEluamVjdGlvblRva2VuLCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksIE9uSW5pdCwgT3B0aW9uYWwsIFZpZXdDb250YWluZXJSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2UsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnhUb29sdGlwQ29tcG9uZW50IH0gZnJvbSAnLi90b29sdGlwLmNvbXBvbmVudCc7XG5cbmNvbnN0IEJBU0VfT0ZGU0VUID0gMTI7XG5cbi8qKlxuICogUG9zc2libGUgcG9zaXRpb25zIG9mIHRoZSB0b29sdGlwLlxuICovXG5leHBvcnQgdHlwZSBUb29sdGlwUG9zaXRpb24gPSBUb29sdGlwVmVydGljYWxQb3NpdGlvbiB8IFRvb2x0aXBIb3Jpem9udGFsUG9zaXRpb247XG5leHBvcnQgdHlwZSBUb29sdGlwSG9yaXpvbnRhbFBvc2l0aW9uID0gJ2xlZnQnIHwgJ3JpZ2h0JztcbmV4cG9ydCB0eXBlIFRvb2x0aXBWZXJ0aWNhbFBvc2l0aW9uID0gJ3RvcCcgfCAnYm90dG9tJztcblxuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGRldGVybWluZXMgdGhlIHNjcm9sbCBoYW5kbGluZyB3aGlsZSBhIHRvb2x0aXAgaXMgb3Blbi4gKi9cbmV4cG9ydCBjb25zdCBOWF9UT09MVElQX1NDUk9MTF9TVFJBVEVHWSA9IG5ldyBJbmplY3Rpb25Ub2tlbjwoKSA9PiBTY3JvbGxTdHJhdGVneT4oJ254LXRvb2x0aXAtc2Nyb2xsLXN0cmF0ZWd5Jyk7XG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gTlhfVE9PTFRJUF9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVJfRkFDVE9SWShvdmVybGF5OiBPdmVybGF5KTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3kge1xuICAgIHJldHVybiAoKSA9PiBvdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xufVxuXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGNvbnN0IE5YX1RPT0xUSVBfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IE5YX1RPT0xUSVBfU0NST0xMX1NUUkFURUdZLFxuICAgIHVzZUZhY3Rvcnk6IE5YX1RPT0xUSVBfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSX0ZBQ1RPUlksXG4gICAgZGVwczogW092ZXJsYXldLFxufTtcblxuLyoqXG4gKiBDU1MgY2xhc3MgdGhhdCB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBvdmVybGF5IHBhbmVsLlxuICogQGRvY3MtcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgTlhfVE9PTFRJUF9QQU5FTF9DTEFTUyA9ICdueC10b29sdGlwLXBhbmVsJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVycm9yIHRvIGJlIHRocm93biBpZiB0aGUgdXNlciBwcm92aWRlZCBhbiBpbnZhbGlkIHRvb2x0aXAgcG9zaXRpb24uXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROeFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcihwb3NpdGlvbjogc3RyaW5nKSB7XG4gICAgcmV0dXJuIEVycm9yKGBUb29sdGlwIHBvc2l0aW9uIFwiJHtwb3NpdGlvbn1cIiBpcyBpbnZhbGlkLmApO1xufVxuXG4vKiogRGVmYXVsdCBgbnhUb29sdGlwYCBvcHRpb25zIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4uICovXG5leHBvcnQgaW50ZXJmYWNlIE54VG9vbHRpcERlZmF1bHRPcHRpb25zIHtcbiAgICAvKiogVGhlIGRlZmF1bHQgZGVsYXkgaW4gbXMgYmVmb3JlIHNob3dpbmcgdGhlIHRvb2x0aXAgYWZ0ZXIgc2hvdyBpcyBjYWxsZWQgKi9cbiAgICBzaG93RGVsYXk6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgZGVmYXVsdCBkZWxheSBpbiBtcyBiZWZvcmUgaGlkaW5nIHRoZSB0b29sdGlwIGFmdGVyIGhpZGUgaXMgY2FsbGVkICovXG4gICAgaGlkZURlbGF5OiBudW1iZXI7XG5cbiAgICAvKiogVGhlIGRlZmF1bHQgZGVsYXkgaW4gbXMgYmVmb3JlIGhpZGluZyB0aGUgdG9vbHRpcCBvbiB0b3VjaCBkZXZpY2VzICovXG4gICAgdG91Y2hlbmRIaWRlRGVsYXk6IG51bWJlcjtcblxuICAgIC8qKiBUaGUgZGVmYXVsdCBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCAqL1xuICAgIHBvc2l0aW9uPzogVG9vbHRpcFBvc2l0aW9uO1xufVxuXG4vKiogSW5qZWN0aW9uIHRva2VuIHRvIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYG54VG9vbHRpcGAuICovXG5leHBvcnQgY29uc3QgTlhfVE9PTFRJUF9ERUZBVUxUX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48TnhUb29sdGlwRGVmYXVsdE9wdGlvbnM+KCdueC10b29sdGlwLWRlZmF1bHQtb3B0aW9ucycsIHtcbiAgICBwcm92aWRlZEluOiAncm9vdCcsXG4gICAgZmFjdG9yeTogTlhfVE9PTFRJUF9ERUZBVUxUX09QVElPTlNfRkFDVE9SWSxcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gTlhfVE9PTFRJUF9ERUZBVUxUX09QVElPTlNfRkFDVE9SWSgpOiBOeFRvb2x0aXBEZWZhdWx0T3B0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2hvd0RlbGF5OiAyMDAsXG4gICAgICAgIGhpZGVEZWxheTogMjAwLFxuICAgICAgICB0b3VjaGVuZEhpZGVEZWxheTogMTUwMCxcbiAgICB9O1xufVxuXG4vKipcbiAqIERpcmVjdGl2ZSB0aGF0IGF0dGFjaGVzIGEgdG9vbHRpcCB0byB0aGUgaG9zdCBlbGVtZW50LlxuICpcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbbnhUb29sdGlwXScsXG4gICAgZXhwb3J0QXM6ICdueFRvb2x0aXAnLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJyhrZXlkb3duKSc6ICdfaGFuZGxlS2V5ZG93bigkZXZlbnQpJyxcbiAgICAgICAgJyh0b3VjaGVuZCknOiAnX2hhbmRsZVRvdWNoZW5kKCknLFxuICAgIH0sXG59KVxuZXhwb3J0IGNsYXNzIE54VG9vbHRpcERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25Jbml0IHtcbiAgICBfb3ZlcmxheVJlZiE6IE92ZXJsYXlSZWYgfCBudWxsO1xuICAgIF90b29sdGlwSW5zdGFuY2UhOiBOeFRvb2x0aXBDb21wb25lbnQgfCBudWxsO1xuXG4gICAgcHJpdmF0ZSBfcG9ydGFsITogQ29tcG9uZW50UG9ydGFsPE54VG9vbHRpcENvbXBvbmVudD47XG4gICAgcHJpdmF0ZSBfcG9zaXRpb246IFRvb2x0aXBQb3NpdGlvbiA9ICdib3R0b20nO1xuICAgIHByaXZhdGUgX2Rpc2FibGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfc2VsZWN0YWJsZSA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2VtYmVkZGVkVmlld1JlZiE6IENvbXBvbmVudFJlZjxOeFRvb2x0aXBDb21wb25lbnQ+O1xuICAgIHByaXZhdGUgX3Bvc3NpYmxlVG9vbHRpcFBvc2l0aW9uczogVG9vbHRpcFBvc2l0aW9uW10gPSBbJ2JvdHRvbScsICd0b3AnLCAnbGVmdCcsICdyaWdodCddO1xuXG4gICAgLyoqIEFsbG93cyB0aGUgdXNlciB0byBkZWZpbmUgdGhlIHBvc2l0aW9uIG9mIHRoZSB0b29sdGlwIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgZWxlbWVudCAqL1xuICAgIEBJbnB1dCgnbnhUb29sdGlwUG9zaXRpb24nKVxuICAgIGdldCBwb3NpdGlvbigpOiBUb29sdGlwUG9zaXRpb24ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XG4gICAgfVxuICAgIHNldCBwb3NpdGlvbih2YWx1ZTogVG9vbHRpcFBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLnBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5zaG93KDApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYudXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBEaXNhYmxlcyB0aGUgZGlzcGxheSBvZiB0aGUgdG9vbHRpcC4gKi9cbiAgICBASW5wdXQoJ254VG9vbHRpcERpc2FibGVkJylcbiAgICBnZXQgZGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlOiBCb29sZWFuSW5wdXQpIHtcbiAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuXG4gICAgICAgIC8vIElmIHRvb2x0aXAgaXMgZGlzYWJsZWQsIGhpZGUgaW1tZWRpYXRlbHkuXG4gICAgICAgIGlmICh0aGlzLl9kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEFsbG93cyBzZWxlY3Rpb24gb2YgdGV4dCB3aXRoaW4gdG9vbHRpcCB0cmlnZ2VyXG4gICAgICogIE5PVEU6IGlucHV0cyBhbmQgdGV4dGFyZWFzIGFsd2F5cyByZW1haW4gc2VsZWN0YWJsZSwgaWdub3JpbmcgdGhpcyBpbnB1dC5cbiAgICAgKi9cbiAgICBASW5wdXQoJ254VG9vbHRpcFNlbGVjdGFibGUnKVxuICAgIGdldCBzZWxlY3RhYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0YWJsZTtcbiAgICB9XG4gICAgc2V0IHNlbGVjdGFibGUodmFsdWU6IEJvb2xlYW5JbnB1dCkge1xuICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMuX3NlbGVjdGFibGU7XG4gICAgICAgIHRoaXMuX3NlbGVjdGFibGUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0YWJsZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNlbGVjdGFiaWxpdHlTdHlsZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBUaGUgZGVmYXVsdCBkZWxheSBpbiBtcyBiZWZvcmUgc2hvd2luZyB0aGUgdG9vbHRpcCBhZnRlciBzaG93IGlzIGNhbGxlZCAqL1xuICAgIEBJbnB1dCgnbnhUb29sdGlwU2hvd0RlbGF5Jykgc2hvd0RlbGF5OiBudW1iZXIgPSB0aGlzLl9kZWZhdWx0T3B0aW9ucyEuc2hvd0RlbGF5O1xuXG4gICAgLyoqIFRoZSBkZWZhdWx0IGRlbGF5IGluIG1zIGJlZm9yZSBoaWRpbmcgdGhlIHRvb2x0aXAgYWZ0ZXIgaGlkZSBpcyBjYWxsZWQgKi9cbiAgICBASW5wdXQoJ254VG9vbHRpcEhpZGVEZWxheScpIGhpZGVEZWxheTogbnVtYmVyID0gdGhpcy5fZGVmYXVsdE9wdGlvbnMhLmhpZGVEZWxheTtcblxuICAgIHByaXZhdGUgX21lc3NhZ2UgPSAnJztcblxuICAgIC8qKiBUaGUgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgKi9cbiAgICBASW5wdXQoJ254VG9vbHRpcCcpXG4gICAgZ2V0IG1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgfVxuICAgIHNldCBtZXNzYWdlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fYXJpYURlc2NyaWJlci5yZW1vdmVEZXNjcmlwdGlvbih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMuX21lc3NhZ2UpO1xuXG4gICAgICAgIC8vIElmIHRoZSBtZXNzYWdlIGlzIG5vdCBhIHN0cmluZyAoZS5nLiBudW1iZXIpLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nIGFuZCB0cmltIGl0LlxuICAgICAgICB0aGlzLl9tZXNzYWdlID0gdmFsdWUgIT0gbnVsbCA/IGAke3ZhbHVlfWAudHJpbSgpIDogJyc7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tZXNzYWdlICYmIHRoaXMuX2lzVG9vbHRpcFZpc2libGUoKSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlKDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVG9vbHRpcE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMuX2FyaWFEZXNjcmliZXIuZGVzY3JpYmUodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFN0cmF0ZWd5IGZhY3RvcnkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gaGFuZGxlIHNjcm9sbGluZyB3aGlsZSB0aGUgdG9vbHRpcCBwYW5lbCBpcyBvcGVuLiAqL1xuICAgIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5RmFjdG9yeSA9IHRoaXMuX2RlZmF1bHRTY3JvbGxTdHJhdGVneUZhY3Rvcnk7XG5cbiAgICBwcml2YXRlIF9tYW51YWxMaXN0ZW5lcnMgPSBuZXcgTWFwPHN0cmluZywgRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdD4oKTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2Rlc3Ryb3llZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIHByaXZhdGUgX3Njcm9sbERpc3BhdGNoZXI6IFNjcm9sbERpc3BhdGNoZXIsXG4gICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByaXZhdGUgX25nWm9uZTogTmdab25lLFxuICAgICAgICBwbGF0Zm9ybTogUGxhdGZvcm0sXG4gICAgICAgIHByaXZhdGUgX2FyaWFEZXNjcmliZXI6IEFyaWFEZXNjcmliZXIsXG4gICAgICAgIHByaXZhdGUgX2ZvY3VzTW9uaXRvcjogRm9jdXNNb25pdG9yLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5IHwgbnVsbCxcbiAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChOWF9UT09MVElQX0RFRkFVTFRfT1BUSU9OUykgcHJpdmF0ZSBfZGVmYXVsdE9wdGlvbnM6IE54VG9vbHRpcERlZmF1bHRPcHRpb25zIHwgbnVsbCxcbiAgICAgICAgQEluamVjdChOWF9UT09MVElQX1NDUk9MTF9TVFJBVEVHWSkgcHJpdmF0ZSBfZGVmYXVsdFNjcm9sbFN0cmF0ZWd5RmFjdG9yeTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3ksXG4gICAgKSB7XG4gICAgICAgIHRoaXMuX2Rpcj8uY2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSh0aGlzLl9kaXJDaGFuZ2VIYW5kbGVyLmJpbmQodGhpcykpO1xuXG4gICAgICAgIGNvbnN0IGVsZW1lbnQ6IEhUTUxFbGVtZW50ID0gX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcblxuICAgICAgICAvLyBUaGUgbW91c2UgZXZlbnRzIHNob3VsZG4ndCBiZSBib3VuZCBvbiBtb2JpbGUgZGV2aWNlcywgYmVjYXVzZSB0aGV5IGNhbiBwcmV2ZW50IHRoZVxuICAgICAgICAvLyBmaXJzdCB0YXAgZnJvbSBmaXJpbmcgaXRzIGNsaWNrIGV2ZW50IG9yIGNhbiBjYXVzZSB0aGUgdG9vbHRpcCB0byBvcGVuIGZvciBjbGlja3MuXG4gICAgICAgIGlmICghcGxhdGZvcm0uSU9TICYmICFwbGF0Zm9ybS5BTkRST0lEKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW51YWxMaXN0ZW5lcnMuc2V0KCdtb3VzZWVudGVyJywgKCkgPT4gdGhpcy5zaG93KCkpLnNldCgnbW91c2VsZWF2ZScsICgpID0+IHRoaXMuaGlkZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byBzaG93aW5nIG9uIGB0b3VjaHN0YXJ0YCwgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIHdheSBmb3IgdGhlIHVzZXIgdG8gdHJpZ2dlciB0aGUgdG9vbHRpcCBvbiBhIHRvdWNoIGRldmljZS5cbiAgICAgICAgICAgIHRoaXMuX21hbnVhbExpc3RlbmVycy5zZXQoJ3RvdWNoc3RhcnQnLCAoKSA9PiB0aGlzLnNob3coKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9tYW51YWxMaXN0ZW5lcnMuZm9yRWFjaCgobGlzdGVuZXIsIGV2ZW50KSA9PiBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKSk7XG5cbiAgICAgICAgX2ZvY3VzTW9uaXRvclxuICAgICAgICAgICAgLm1vbml0b3IoX2VsZW1lbnRSZWYpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUob3JpZ2luID0+IHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlIGZvY3VzIG1vbml0b3IgcnVucyBvdXRzaWRlIHRoZSBBbmd1bGFyIHpvbmUuXG4gICAgICAgICAgICAgICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgX25nWm9uZS5ydW4oKCkgPT4gdGhpcy5oaWRlKDApKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbiA9PT0gJ2tleWJvYXJkJykge1xuICAgICAgICAgICAgICAgICAgICBfbmdab25lLnJ1bigoKSA9PiB0aGlzLnNob3coKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKF9kZWZhdWx0T3B0aW9ucz8ucG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBfZGVmYXVsdE9wdGlvbnMucG9zaXRpb247XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2VsZWN0YWJpbGl0eVN0eWxlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERpc3Bvc2UgdGhlIHRvb2x0aXAgd2hlbiBkZXN0cm95ZWQuXG4gICAgICovXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbGVhbiB1cCB0aGUgZXZlbnQgbGlzdGVuZXJzIHNldCBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgdGhpcy5fbWFudWFsTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyLCBldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX21hbnVhbExpc3RlbmVycy5jbGVhcigpO1xuXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuXG4gICAgICAgIHRoaXMuX2FyaWFEZXNjcmliZXIucmVtb3ZlRGVzY3JpcHRpb24odGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCB0aGlzLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLl9mb2N1c01vbml0b3Iuc3RvcE1vbml0b3JpbmcodGhpcy5fZWxlbWVudFJlZik7XG4gICAgfVxuXG4gICAgLyoqIFNob3dzIHRoZSB0b29sdGlwIGFmdGVyIHRoZSBkZWxheSBpbiBtcywgZGVmYXVsdHMgdG8gdG9vbHRpcC1kZWxheS1zaG93IG9yIDBtcyBpZiBubyBpbnB1dCAqL1xuICAgIHNob3coZGVsYXk6IG51bWJlciA9IHRoaXMuc2hvd0RlbGF5KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkIHx8ICF0aGlzLm1lc3NhZ2UgfHwgKHRoaXMuX2lzVG9vbHRpcFZpc2libGUoKSAmJiAhdGhpcy5fdG9vbHRpcEluc3RhbmNlPy5pc0RlbGF5ZWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLl9jcmVhdGVPdmVybGF5KCk7XG5cbiAgICAgICAgdGhpcy5fZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuX3BvcnRhbCA9IHRoaXMuX3BvcnRhbCB8fCBuZXcgQ29tcG9uZW50UG9ydGFsKE54VG9vbHRpcENvbXBvbmVudCwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld1JlZiA9IG92ZXJsYXlSZWYuYXR0YWNoKHRoaXMuX3BvcnRhbCk7XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSA9IHRoaXMuX2VtYmVkZGVkVmlld1JlZi5pbnN0YW5jZTtcbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlXG4gICAgICAgICAgICAuYWZ0ZXJIaWRkZW4oKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2RldGFjaCgpKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVG9vbHRpcE1lc3NhZ2UoKTtcbiAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLnNob3coZGVsYXkpO1xuICAgIH1cblxuICAgIC8qKiBIaWRlcyB0aGUgdG9vbHRpcCBhZnRlciB0aGUgZGVsYXkgaW4gbXMsIGRlZmF1bHRzIHRvIHRvb2x0aXAtZGVsYXktaGlkZSBvciAwbXMgaWYgbm8gaW5wdXQgKi9cbiAgICBoaWRlKGRlbGF5OiBudW1iZXIgPSB0aGlzLmhpZGVEZWxheSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuaGlkZShkZWxheSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogU2hvd3MvaGlkZXMgdGhlIHRvb2x0aXAgKi9cbiAgICB0b2dnbGUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2lzVG9vbHRpcFZpc2libGUoKSA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KCk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdG9vbHRpcCBpcyBjdXJyZW50bHkgdmlzaWJsZSB0byB0aGUgdXNlciAqL1xuICAgIF9pc1Rvb2x0aXBWaXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLl90b29sdGlwSW5zdGFuY2UgJiYgdGhpcy5fdG9vbHRpcEluc3RhbmNlLmlzVmlzaWJsZSgpO1xuICAgIH1cblxuICAgIC8qKiBIYW5kbGVzIHRoZSBrZXlkb3duIGV2ZW50cyBvbiB0aGUgaG9zdCBlbGVtZW50LiAqL1xuICAgIF9oYW5kbGVLZXlkb3duKGU6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVG9vbHRpcFZpc2libGUoKSAmJiBlLmtleUNvZGUgPT09IEVTQ0FQRSkge1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBIYW5kbGVzIHRoZSB0b3VjaGVuZCBldmVudHMgb24gdGhlIGhvc3QgZWxlbWVudC4gKi9cbiAgICBfaGFuZGxlVG91Y2hlbmQoKSB7XG4gICAgICAgIHRoaXMuaGlkZSh0aGlzLl9kZWZhdWx0T3B0aW9ucz8udG91Y2hlbmRIaWRlRGVsYXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHVwIHN0eWxpbmctc3BlY2lmaWMgdGhpbmdzXG4gICAgICovXG4gICAgX3VwZGF0ZVNlbGVjdGFiaWxpdHlTdHlsZXMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRTdHlsZSA9IGVsZW1lbnQuc3R5bGUgYXMgQ1NTU3R5bGVEZWNsYXJhdGlvbiAmIHsgd2Via2l0VXNlckRyYWc6IHN0cmluZyB9O1xuICAgICAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSU5QVVQnIHx8IGVsZW1lbnQubm9kZU5hbWUgPT09ICdURVhUQVJFQScgfHwgdGhpcy5fc2VsZWN0YWJsZTtcbiAgICAgICAgY29uc3QgdXNlclNlbGVjdCA9IGlzU2VsZWN0YWJsZSA/ICdhdXRvJyA6ICdub25lJztcbiAgICAgICAgZWxlbWVudFN0eWxlLndlYmtpdFVzZXJTZWxlY3QgPSBlbGVtZW50U3R5bGUudXNlclNlbGVjdCA9IChlbGVtZW50U3R5bGUgYXMgYW55KS5tc1VzZXJTZWxlY3QgPSB1c2VyU2VsZWN0O1xuICAgIH1cblxuICAgIC8qKiBDcmVhdGUgdGhlIG92ZXJsYXkgY29uZmlnIGFuZCBwb3NpdGlvbiBzdHJhdGVneSAqL1xuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmICYmICEhdGhpcy5fb3ZlcmxheVJlZi5ob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlSZWY7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3JzID0gdGhpcy5fc2Nyb2xsRGlzcGF0Y2hlci5nZXRBbmNlc3RvclNjcm9sbENvbnRhaW5lcnModGhpcy5fZWxlbWVudFJlZik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGNvbm5lY3RlZCBwb3NpdGlvbiBzdHJhdGVneSB0aGF0IGxpc3RlbnMgZm9yIHNjcm9sbCBldmVudHMgdG8gcmVwb3NpdGlvbi5cbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSB0aGlzLl9vdmVybGF5LnBvc2l0aW9uKCkuZmxleGlibGVDb25uZWN0ZWRUbyh0aGlzLl9lbGVtZW50UmVmKS53aXRoTG9ja2VkUG9zaXRpb24odHJ1ZSkud2l0aEZsZXhpYmxlRGltZW5zaW9ucyhmYWxzZSkud2l0aFB1c2godHJ1ZSk7XG5cbiAgICAgICAgc3RyYXRlZ3kud2l0aFNjcm9sbGFibGVDb250YWluZXJzKHNjcm9sbGFibGVBbmNlc3RvcnMpO1xuXG4gICAgICAgIHN0cmF0ZWd5LnBvc2l0aW9uQ2hhbmdlcy5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90b29sdGlwSW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYWlyID0gY2hhbmdlLmNvbm5lY3Rpb25QYWlyO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fbmdab25lLnJ1bigoKSA9PiB0aGlzLl9wb3NpdGlvbkFycm93KHBhaXIpKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2Uuc2Nyb2xsYWJsZVZpZXdQcm9wZXJ0aWVzLmlzT3ZlcmxheUNsaXBwZWQgJiYgdGhpcy5fdG9vbHRpcEluc3RhbmNlLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIHBvc2l0aW9uIGNoYW5nZXMgb2NjdXIgYW5kIHRoZSBvdmVybGF5IGlzIGNsaXBwZWQgYnlcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBwYXJlbnQgc2Nyb2xsYWJsZSB0aGVuIGNsb3NlIHRoZSB0b29sdGlwLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZ1pvbmUucnVuKCgpID0+IHRoaXMuaGlkZSgwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5UmVmID0gdGhpcy5fb3ZlcmxheS5jcmVhdGUoe1xuICAgICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9kaXI/LnZhbHVlIHx8ICdsdHInLFxuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneTogc3RyYXRlZ3ksXG4gICAgICAgICAgICBwYW5lbENsYXNzOiBOWF9UT09MVElQX1BBTkVMX0NMQVNTLFxuICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX3Njcm9sbFN0cmF0ZWd5RmFjdG9yeSgpLFxuICAgICAgICAgICAgZGlzcG9zZU9uTmF2aWdhdGlvbjogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5UmVmXG4gICAgICAgICAgICAuZGV0YWNobWVudHMoKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHRoaXMuX2RldGFjaCgpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheVJlZjtcbiAgICB9XG5cbiAgICAvKiogRGV0YWNoZXMgdGhlIGN1cnJlbnRseS1hdHRhY2hlZCB0b29sdGlwLiAqL1xuICAgIHByaXZhdGUgX2RldGFjaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWY/Lmhhc0F0dGFjaGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCB0b29sdGlwLiAqL1xuICAgIHByaXZhdGUgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMuX292ZXJsYXlSZWYuZ2V0Q29uZmlnKCkucG9zaXRpb25TdHJhdGVneSBhcyBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3k7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuX2dldE9yaWdpbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgY29uc3Qgb3ZlcmxheSA9IHRoaXMuX2dldE92ZXJsYXlQb3NpdGlvbih0aGlzLnBvc2l0aW9uKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5fZ2V0T2Zmc2V0KHRoaXMucG9zaXRpb24pO1xuICAgICAgICBjb25zdCBmYWxsYmFja3MgPSB0aGlzLl9nZXRGYWxsYmFja1Bvc2l0aW9ucyh0aGlzLnBvc2l0aW9uKTtcblxuICAgICAgICBwb3NpdGlvbi53aXRoUG9zaXRpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgLi4ub3ZlcmxheSxcbiAgICAgICAgICAgICAgICAuLi5vZmZzZXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4uZmFsbGJhY2tzLFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvcmlnaW4gcG9zaXRpb24gYmFzZWQgb24gdGhlIHVzZXIncyBwb3NpdGlvbiBwcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIF9nZXRPcmlnaW4ocG9zaXRpb246IFRvb2x0aXBQb3NpdGlvbik6IE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbiB7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpblk6IHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsZWZ0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpblg6IHRoaXMuX2lzTHRyID8gJ3N0YXJ0JyA6ICdlbmQnLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luWDogdGhpcy5faXNMdHIgPyAnZW5kJyA6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpblk6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0TnhUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG92ZXJsYXkgcG9zaXRpb24gYmFzZWQgb24gdGhlIHVzZXIncyBwcmVmZXJlbmNlICovXG4gICAgX2dldE92ZXJsYXlQb3NpdGlvbihwb3NpdGlvbjogVG9vbHRpcFBvc2l0aW9uKTogT3ZlcmxheUNvbm5lY3Rpb25Qb3NpdGlvbiB7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5WTogdGhpcy5fZ2V0SW52ZXJzZVBvc2l0aW9uKHBvc2l0aW9uKSBhcyBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVg6IHRoaXMuX2lzTHRyID8gJ2VuZCcgOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5WTogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXlYOiB0aGlzLl9pc0x0ciA/ICdzdGFydCcgOiAnZW5kJyxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheVk6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0TnhUb29sdGlwSW52YWxpZFBvc2l0aW9uRXJyb3IocG9zaXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG92ZXJsYXkgb2Zmc2V0IHJlcXVpcmVkIGJ5IHRoZSB1c2VyJ3MgcG9zaXRpb24gcHJlZmVyZW5jZSAqL1xuICAgIHByaXZhdGUgX2dldE9mZnNldChwb3NpdGlvbjogVG9vbHRpcFBvc2l0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3RvcCc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiBCQVNFX09GRlNFVCAqIC0xLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdib3R0b20nOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogQkFTRV9PRkZTRVQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogQkFTRV9PRkZTRVQgKiAtMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogQkFTRV9PRkZTRVQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICB0aHJvdyBnZXROeFRvb2x0aXBJbnZhbGlkUG9zaXRpb25FcnJvcihwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgb3Bwb3NpdGUgcG9zaXRpb24sIHVzaW5nIGFxdWlsYSB0b29sdGlwIHBvc2l0aW9uIG5hbWluZzogdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0ICovXG4gICAgcHJpdmF0ZSBfZ2V0SW52ZXJzZVRvb2x0aXBQb3NpdGlvbihwb3NpdGlvbjogVG9vbHRpcFBvc2l0aW9uKTogVG9vbHRpcFBvc2l0aW9uIHtcbiAgICAgICAgY29uc3QgdG9vbHRvcFBvc2l0aW9uUGFpcnMgPSB7XG4gICAgICAgICAgICB0b3A6ICdib3R0b20nLFxuICAgICAgICAgICAgcmlnaHQ6ICdsZWZ0JyxcbiAgICAgICAgICAgIGJvdHRvbTogJ3RvcCcsXG4gICAgICAgICAgICBsZWZ0OiAncmlnaHQnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdG9vbHRvcFBvc2l0aW9uUGFpcnNbcG9zaXRpb25dIGFzIFRvb2x0aXBQb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgb3Bwb3NpdGUgcG9zaXRpb24sIHVzaW5nIGFuZ3VsYXIgcG9zaXRpb24gbmFtaW5nOiB0b3AsIGJvdHRvbSwgc3RhcnQsIGVuZCwgY2VudGVyICovXG4gICAgcHJpdmF0ZSBfZ2V0SW52ZXJzZVBvc2l0aW9uKHBvc2l0aW9uOiBzdHJpbmcpOiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MgfCBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uUGFpcnM6IHsgW2s6IHN0cmluZ106IFZlcnRpY2FsQ29ubmVjdGlvblBvcyB8IEhvcml6b250YWxDb25uZWN0aW9uUG9zIH0gPSB7XG4gICAgICAgICAgICB0b3A6ICdib3R0b20nLFxuICAgICAgICAgICAgYm90dG9tOiAndG9wJyxcbiAgICAgICAgICAgIHN0YXJ0OiAnZW5kJyxcbiAgICAgICAgICAgIGVuZDogJ3N0YXJ0JyxcbiAgICAgICAgICAgIGNlbnRlcjogJ2NlbnRlcicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwb3NpdGlvblBhaXJzW3Bvc2l0aW9uXTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyBhbiBhcnJheSBvZiBmYWxsYmFjayBwb3NpdGlvbnMgZm9yIHRvb2x0aXAsIGZvbGxvd2luZyB0aGUgYWxnb3JpdG06XG4gICAgICogMSkgU2xpZ2h0bHkgYWx0ZXJuYXRlIHByZWZlcnJlZCBwb3NpdGlvbiBpZiBhcHBsaWNhYmxlLiBJLmUuIGZvciAndG9wJyB0cnkgJ3RvcC1zdGFydCcgYW5kICd0b3AtZW5kJyBwb3NpdGlvbmluZy5cbiAgICAgKiAyKSBUcnkgdGhlIG9wcG9zaXRlIHBvc2l0aW9uLCBpLmUuIGZvciAndG9wJyB0cnkgJ2JvdHRvbScuXG4gICAgICogMykgU2xpZ2h0bHkgYWx0ZXJuYXRlIG9wcG9zaXRlIHBvc2l0aW9uLCBpLmUuICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCdcbiAgICAgKiA0KSBBbGwgcmVtYWluaW5nIHBvc2l0aW9ucyBmcm9tIHBvc2l0aW9ucyBsaXN0XG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0RmFsbGJhY2tQb3NpdGlvbnMocG9zaXRpb246IFRvb2x0aXBQb3NpdGlvbiwgcG9zc2libGVQb3NpdGlvbnM6IFRvb2x0aXBQb3NpdGlvbltdID0gdGhpcy5fcG9zc2libGVUb29sdGlwUG9zaXRpb25zKTogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdIHtcbiAgICAgICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbWFpbmlnUG9zaXRpb25zID0gcG9zc2libGVQb3NpdGlvbnMuZmlsdGVyKHBvc3NpYmxlUG9zaXRpb24gPT4gcG9zc2libGVQb3NpdGlvbiAhPT0gcG9zaXRpb24pO1xuICAgICAgICBsZXQgZmFsbGJhY2tQb3NpdGlvbnM6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSA9IFtdO1xuICAgICAgICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgY2FzZSAnYm90dG9tJzoge1xuICAgICAgICAgICAgICAgIGZhbGxiYWNrUG9zaXRpb25zID0gdGhpcy5fZ2V0VmVydGljYWxGYWxsYmFja1Bvc2l0aW9uUGFpcnMocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnbGVmdCc6XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6IHtcbiAgICAgICAgICAgICAgICBmYWxsYmFja1Bvc2l0aW9ucyA9IHRoaXMuX2dldEhvcml6b250YWxGYWxsYmFja1Bvc2l0aW9uUGFpcnMocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW52ZXJzZVBvc2l0aW9uID0gdGhpcy5fZ2V0SW52ZXJzZVRvb2x0aXBQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IG5leHRGYWxsYmFja1Bvc2l0aW9uID0gcmVtYWluaWdQb3NpdGlvbnMuaW5jbHVkZXMoaW52ZXJzZVBvc2l0aW9uKSA/IGludmVyc2VQb3NpdGlvbiA6IHBvc3NpYmxlUG9zaXRpb25zWzBdO1xuICAgICAgICByZXR1cm4gWy4uLmZhbGxiYWNrUG9zaXRpb25zLCAuLi50aGlzLl9nZXRGYWxsYmFja1Bvc2l0aW9ucyhuZXh0RmFsbGJhY2tQb3NpdGlvbiwgcmVtYWluaWdQb3NpdGlvbnMpXTtcbiAgICB9XG5cbiAgICAvKiogQ2FsY3VsYXRlcyBmYWxsYmFja3MgZm9yIHZlcnRpY2FsIHRvb2x0aXAgcG9zaXRpb25pbmcgKi9cbiAgICBwcml2YXRlIF9nZXRWZXJ0aWNhbEZhbGxiYWNrUG9zaXRpb25QYWlycyhwb3NpdGlvbjogVG9vbHRpcFZlcnRpY2FsUG9zaXRpb24pOiBDb25uZWN0aW9uUG9zaXRpb25QYWlyW10ge1xuICAgICAgICBjb25zdCBpc1NlbGVjdGVkUG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdGhpcy5wb3NpdGlvbjtcbiAgICAgICAgY29uc3QgdmVydGljYWxGYWxsYmFja1Bvc2l0aW9uUGFpcnM6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSA9IFtdO1xuICAgICAgICBjb25zdCBiYXNlUG9zaXRpb25QYWlyID0ge1xuICAgICAgICAgICAgLi4udGhpcy5fZ2V0T3JpZ2luKHBvc2l0aW9uKSxcbiAgICAgICAgICAgIC4uLnRoaXMuX2dldE92ZXJsYXlQb3NpdGlvbihwb3NpdGlvbiksXG4gICAgICAgICAgICAuLi50aGlzLl9nZXRPZmZzZXQocG9zaXRpb24pLFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghaXNTZWxlY3RlZFBvc2l0aW9uKSB7XG4gICAgICAgICAgICAvLyBISU5UOiBzZWxlY3RlZCBwb3NpdGlvbiBtYXRjaGVzIGJhc2VQb3NpdGlvbiwgc28gd2UgZG9uJ3QgbmVlZCB0byByZXBlYXQgaXQgaW4gZmFsbGJhY2tcbiAgICAgICAgICAgIHZlcnRpY2FsRmFsbGJhY2tQb3NpdGlvblBhaXJzLnB1c2goYmFzZVBvc2l0aW9uUGFpcik7XG4gICAgICAgIH1cbiAgICAgICAgdmVydGljYWxGYWxsYmFja1Bvc2l0aW9uUGFpcnMucHVzaChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi5iYXNlUG9zaXRpb25QYWlyLFxuICAgICAgICAgICAgICAgIG9yaWdpblg6ICdzdGFydCcsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdzdGFydCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC4uLmJhc2VQb3NpdGlvblBhaXIsXG4gICAgICAgICAgICAgICAgb3JpZ2luWDogJ2VuZCcsXG4gICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIHZlcnRpY2FsRmFsbGJhY2tQb3NpdGlvblBhaXJzO1xuICAgIH1cblxuICAgIC8qKiBDYWxjdWxhdGVzIGZhbGxiYWNrcyBmb3IgaG9yaXpvbnRhbCB0b29sdGlwIHBvc2l0aW9uaW5nICovXG4gICAgcHJpdmF0ZSBfZ2V0SG9yaXpvbnRhbEZhbGxiYWNrUG9zaXRpb25QYWlycyhwb3NpdGlvbjogVG9vbHRpcEhvcml6b250YWxQb3NpdGlvbik6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuX2dldE9mZnNldChwb3NpdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9nZXRPcmlnaW4ocG9zaXRpb24pLFxuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2dldE92ZXJsYXlQb3NpdGlvbihwb3NpdGlvbiksXG4gICAgICAgICAgICAgICAgLi4ub2Zmc2V0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlcyB0aGUgdG9vbHRpcCBtZXNzYWdlIGFuZCByZXBvc2l0aW9ucyB0aGUgb3ZlcmxheSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBtZXNzYWdlIGxlbmd0aCAqL1xuICAgIHByaXZhdGUgX3VwZGF0ZVRvb2x0aXBNZXNzYWdlKCkge1xuICAgICAgICAvLyBNdXN0IHdhaXQgZm9yIHRoZSBtZXNzYWdlIHRvIGJlIHBhaW50ZWQgdG8gdGhlIHRvb2x0aXAgc28gdGhhdCB0aGUgb3ZlcmxheSBjYW4gcHJvcGVybHlcbiAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHBvc2l0aW9uaW5nIGJhc2VkIG9uIHRoZSBzaXplIG9mIHRoZSB0ZXh0LlxuICAgICAgICBpZiAodGhpcy5fdG9vbHRpcEluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UubWVzc2FnZSA9IHRoaXMubWVzc2FnZTtcblxuICAgICAgICAgICAgdGhpcy5fbmdab25lLm9uTWljcm90YXNrRW1wdHlcbiAgICAgICAgICAgICAgICAuYXNPYnNlcnZhYmxlKClcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlKDEpLCB0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Rvb2x0aXBJbnN0YW5jZSAmJiB0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnVwZGF0ZVBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX3Bvc2l0aW9uQXJyb3cocGFpcjogQ29ubmVjdGlvblBvc2l0aW9uUGFpcikge1xuICAgICAgICBpZiAoIXRoaXMuX292ZXJsYXlSZWYgfHwgIXRoaXMuX3Rvb2x0aXBJbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnRQb3NpdGlvblggPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudFdpZHRoID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gMjtcbiAgICAgICAgY29uc3Qgb3ZlcmxheUVsZW1lbnRMZWZ0T2Zmc2V0ID0gdGhpcy5fb3ZlcmxheVJlZi5vdmVybGF5RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXG4gICAgICAgIC8vIGNhbGN1bGF0aW9uIGZvciB4IHBvc2l0aW9uIG9mIHRoZSBwYXJlbnQgZWxlbWVudC4gSW4gdGhpcyBjYXNlLCBvdmVybGF5IGxlZnQgb2Zmc2V0IGlzIHRoZSBvbmUgdGhpbmcgdG8gY29uc2lkZXIuXG4gICAgICAgIGNvbnN0IHRhcmdldFBvc2l0aW9uID0gcGFyZW50RWxlbWVudFBvc2l0aW9uWCArIHBhcmVudEVsZW1lbnRXaWR0aCAtIG92ZXJsYXlFbGVtZW50TGVmdE9mZnNldDtcblxuICAgICAgICBpZiAocGFpci5vcmlnaW5YID09PSBwYWlyLm92ZXJsYXlYKSB7XG4gICAgICAgICAgICBjb25zdCBhcnJvd1N0eWxlID0geyBsZWZ0OiB0YXJnZXRQb3NpdGlvbiArICdweCcgfTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5hcnJvd1N0eWxlID0gYXJyb3dTdHlsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWlyLm9yaWdpblggPT09ICdlbmQnICYmIHBhaXIub3ZlcmxheVggPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5hcnJvd1N0eWxlID0ge1xuICAgICAgICAgICAgICAgIHRvcDogJzUwJScsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLnBvc2l0aW9uID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIGlmIChwYWlyLm9yaWdpblkgPT09ICdib3R0b20nICYmIHBhaXIub3ZlcmxheVkgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuYXJyb3dTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRQb3NpdGlvbiArICdweCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLnBvc2l0aW9uID0gJ2JvdHRvbSc7XG4gICAgICAgIH0gZWxzZSBpZiAocGFpci5vcmlnaW5YID09PSAnc3RhcnQnICYmIHBhaXIub3ZlcmxheVggPT09ICdlbmQnKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuYXJyb3dTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICB0b3A6ICc1MCUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX3Rvb2x0aXBJbnN0YW5jZS5wb3NpdGlvbiA9ICdsZWZ0JztcbiAgICAgICAgfSBlbHNlIGlmIChwYWlyLm9yaWdpblkgPT09ICd0b3AnICYmIHBhaXIub3ZlcmxheVkgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0aGlzLl90b29sdGlwSW5zdGFuY2UuYXJyb3dTdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRQb3NpdGlvbiArICdweCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fdG9vbHRpcEluc3RhbmNlLnBvc2l0aW9uID0gJ3RvcCc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZGlyQ2hhbmdlSGFuZGxlcih2YWx1ZTogRGlyZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoMCk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLnNldERpcmVjdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IF9pc0x0cigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9kaXIgfHwgdGhpcy5fZGlyLnZhbHVlID09PSAnbHRyJztcbiAgICB9XG59XG4iXX0=