import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, Component, ContentChildren, Input, Optional, QueryList, Self, } from '@angular/core';
import { mapClassNames } from '@aposin/ng-aquila/utils';
import { merge, Subject } from 'rxjs';
import { startWith, switchMap, takeUntil } from 'rxjs/operators';
import { NxRadioToggleButtonBaseComponent } from './radio-toggle-button-base.component';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "@aposin/ng-aquila/utils";
import * as i3 from "@angular/common";
let nextId = 0;
const MAPPING = {
    negative: 'nx-radio-toggle--negative',
    small: 'nx-radio-toggle--small',
};
export const RESET_VALUES = [null, undefined, ''];
export class NxRadioToggleComponent {
    constructor(_cdr, 
    /** @docs-private */ ngControl, _errorStateMatcher, _parentForm, _parentFormGroup) {
        this._cdr = _cdr;
        this.ngControl = ngControl;
        this._errorStateMatcher = _errorStateMatcher;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this._toggleId = (nextId++).toString();
        this._disabled = false;
        /** @docs-private */
        this.errorState = false;
        // emits to signal children to run change detection
        this._disableChange = new Subject();
        /** @docs-private */
        this.additionalClasses = '';
        /** @docs-private */
        this.toggleButtons = new QueryList();
        this._destroyed = new Subject();
        this.onTouchedCallback = () => { };
        this.onChangeCallback = (option) => { };
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /** Sets the component to the disabled state.*/
    set disabled(value) {
        const coerced = coerceBooleanProperty(value);
        if (this._disabled !== coerced) {
            this._disabled = coerced;
            this._disableChange.next();
        }
    }
    get disabled() {
        return this._disabled;
    }
    /** Sets the name used for accessibility. */
    set name(value) {
        if (this._name !== value) {
            this._name = value;
            this._cdr.markForCheck();
        }
    }
    get name() {
        return this._name;
    }
    ngAfterContentInit() {
        this.toggleButtons.changes
            .pipe(startWith(this.toggleButtons), switchMap(_ => merge(...this.toggleButtons.map((button) => button.onChecked))), takeUntil(this._destroyed))
            .subscribe(change => {
            this._selection = change.value;
            this.change(this._selection);
        });
        this.toggleButtons.changes
            .pipe(startWith(this.toggleButtons), takeUntil(this._destroyed))
            .subscribe((toggles) => {
            toggles.forEach(toggle => {
                toggle.resetClasses();
                if (toggle.value === this.selection) {
                    // We need to defer the selection for the edge case that the button with the value of this.selection
                    // didn't exist yet but was added afterwards to prevent changed after checked errors
                    setTimeout(() => toggle.select());
                }
            });
            if (toggles.length > 0) {
                toggles.first.setFirstButton();
                toggles.last.setLastButton();
            }
        });
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._disableChange.complete();
    }
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribe to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this.updateErrorState();
        }
    }
    registerOnChange(onChangeCallback) {
        this.onChangeCallback = onChangeCallback;
    }
    registerOnTouched(onTouchedCallback) {
        this.onTouchedCallback = onTouchedCallback;
    }
    /** Preselects the respective options. */
    writeValue(value) {
        this._selection = value;
        const correspondingButton = this.toggleButtons.find((button) => button.value === this._selection);
        if (correspondingButton) {
            correspondingButton.select();
            return;
        }
        if (RESET_VALUES.includes(value)) {
            this.toggleButtons.map((button) => button.deselect());
        }
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    /** @docs-private */
    get id() {
        return `nx-radio-toggle-${this._toggleId}`;
    }
    /** Sets the modifiers for the component. */
    set style(value) {
        this.additionalClasses = mapClassNames(value, [], MAPPING);
    }
    /**
     * @docs-private
     */
    get selection() {
        return this._selection;
    }
    /** @docs-private */
    change(value) {
        this.onChangeCallback(value);
        if (this.onTouchedCallback) {
            this.onTouchedCallback();
        }
    }
    /** @docs-private */
    updateErrorState() {
        const oldState = this.errorState;
        const parent = this._parentFormGroup || this._parentForm;
        const control = this.ngControl ? this.ngControl.control : null;
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
        }
    }
}
NxRadioToggleComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxRadioToggleComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.NgControl, optional: true, self: true }, { token: i2.ErrorStateMatcher }, { token: i1.NgForm, optional: true }, { token: i1.FormGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxRadioToggleComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxRadioToggleComponent, selector: "nx-radio-toggle", inputs: { disabled: ["nxDisabled", "disabled"], name: ["nxName", "name"], writeValue: ["nxSelection", "writeValue"], style: ["nxStyle", "style"] }, queries: [{ propertyName: "toggleButtons", predicate: NxRadioToggleButtonBaseComponent }], ngImport: i0, template: "<div class=\"nx-radio-toggle\" [ngClass]=\"additionalClasses\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n    <ng-content></ng-content>\n</div>\n", styles: [":host{display:block}.nx-radio-toggle{display:flex;height:100%}@media (max-width: 703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}\n"], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxRadioToggleComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-radio-toggle', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"nx-radio-toggle\" [ngClass]=\"additionalClasses\" role=\"radiogroup\" [attr.aria-label]=\"name\">\n    <ng-content></ng-content>\n</div>\n", styles: [":host{display:block}.nx-radio-toggle{display:flex;height:100%}@media (max-width: 703px){.nx-radio-toggle{flex-direction:column;text-align:center;width:100%;justify-content:center;align-items:center}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: i2.ErrorStateMatcher }, { type: i1.NgForm, decorators: [{
                    type: Optional
                }] }, { type: i1.FormGroupDirective, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { disabled: [{
                type: Input,
                args: ['nxDisabled']
            }], name: [{
                type: Input,
                args: ['nxName']
            }], toggleButtons: [{
                type: ContentChildren,
                args: [NxRadioToggleButtonBaseComponent]
            }], writeValue: [{
                type: Input,
                args: ['nxSelection']
            }], style: [{
                type: Input,
                args: ['nxStyle']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFkaW8tdG9nZ2xlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWFxdWlsYS9zcmMvcmFkaW8tdG9nZ2xlL3JhZGlvLXRvZ2dsZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL3JhZGlvLXRvZ2dsZS9yYWRpby10b2dnbGUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFnQixxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVFLE9BQU8sRUFFSCx1QkFBdUIsRUFFdkIsU0FBUyxFQUNULGVBQWUsRUFFZixLQUFLLEVBRUwsUUFBUSxFQUNSLFNBQVMsRUFDVCxJQUFJLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFxQixhQUFhLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMzRSxPQUFPLEVBQUUsS0FBSyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRCxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUdqRSxPQUFPLEVBQUUsZ0NBQWdDLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQzs7Ozs7QUFFeEYsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBRWYsTUFBTSxPQUFPLEdBQUc7SUFDWixRQUFRLEVBQUUsMkJBQTJCO0lBQ3JDLEtBQUssRUFBRSx3QkFBd0I7Q0FDbEMsQ0FBQztBQUVGLE1BQU0sQ0FBQyxNQUFNLFlBQVksR0FBRyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFRbEQsTUFBTSxPQUFPLHNCQUFzQjtJQW9EL0IsWUFDWSxJQUF1QjtJQUMvQixvQkFBb0IsQ0FBNEIsU0FBMkIsRUFDbkUsa0JBQXFDLEVBQ3pCLFdBQTBCLEVBQzFCLGdCQUEyQztRQUp2RCxTQUFJ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QUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBRSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQXVCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUNoRixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUV2RSxJQUFJLFFBQVEsS0FBSyxRQUFRLEVBQUU7WUFDdkIsSUFBSSxDQUFDLFVBQVUsR0FBRyxRQUFRLENBQUM7U0FDOUI7SUFDTCxDQUFDOzttSEE3S1Esc0JBQXNCO3VHQUF0QixzQkFBc0IseU9BMkNkLGdDQUFnQyw2QkNoRnJELHlKQUdBOzJGRGtDYSxzQkFBc0I7a0JBTmxDLFNBQVM7K0JBQ0ksaUJBQWlCLG1CQUVWLHVCQUF1QixDQUFDLE1BQU07OzBCQXlEckIsUUFBUTs7MEJBQUksSUFBSTs7MEJBRXJDLFFBQVE7OzBCQUNSLFFBQVE7NENBekNULFFBQVE7c0JBRFgsS0FBSzt1QkFBQyxZQUFZO2dCQWlCZixJQUFJO3NCQURQLEtBQUs7dUJBQUMsUUFBUTtnQkFhZixhQUFhO3NCQURaLGVBQWU7dUJBQUMsZ0NBQWdDO2dCQThFakQsVUFBVTtzQkFEVCxLQUFLO3VCQUFDLGFBQWE7Z0JBd0JoQixLQUFLO3NCQURSLEtBQUs7dUJBQUMsU0FBUyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJvb2xlYW5JbnB1dCwgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIERvQ2hlY2ssXG4gICAgSW5wdXQsXG4gICAgT25EZXN0cm95LFxuICAgIE9wdGlvbmFsLFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBTZWxmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQ29udHJvbCwgRm9ybUdyb3VwRGlyZWN0aXZlLCBOZ0NvbnRyb2wsIE5nRm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEVycm9yU3RhdGVNYXRjaGVyLCBtYXBDbGFzc05hbWVzIH0gZnJvbSAnQGFwb3Npbi9uZy1hcXVpbGEvdXRpbHMnO1xuaW1wb3J0IHsgbWVyZ2UsIE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN0YXJ0V2l0aCwgc3dpdGNoTWFwLCB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IE54UmFkaW9Ub2dnbGVCdXR0b25DaGFuZ2UsIE54UmFkaW9Ub2dnbGVCdXR0b25Db21wb25lbnQgfSBmcm9tICcuL3JhZGlvLXRvZ2dsZS1idXR0b24uY29tcG9uZW50JztcbmltcG9ydCB7IE54UmFkaW9Ub2dnbGVCdXR0b25CYXNlQ29tcG9uZW50IH0gZnJvbSAnLi9yYWRpby10b2dnbGUtYnV0dG9uLWJhc2UuY29tcG9uZW50JztcblxubGV0IG5leHRJZCA9IDA7XG5cbmNvbnN0IE1BUFBJTkcgPSB7XG4gICAgbmVnYXRpdmU6ICdueC1yYWRpby10b2dnbGUtLW5lZ2F0aXZlJyxcbiAgICBzbWFsbDogJ254LXJhZGlvLXRvZ2dsZS0tc21hbGwnLFxufTtcblxuZXhwb3J0IGNvbnN0IFJFU0VUX1ZBTFVFUyA9IFtudWxsLCB1bmRlZmluZWQsICcnXTtcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdueC1yYWRpby10b2dnbGUnLFxuICAgIHRlbXBsYXRlVXJsOiAncmFkaW8tdG9nZ2xlLmNvbXBvbmVudC5odG1sJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBzdHlsZVVybHM6IFsncmFkaW8tdG9nZ2xlLmNvbXBvbmVudC5zY3NzJ10sXG59KVxuZXhwb3J0IGNsYXNzIE54UmFkaW9Ub2dnbGVDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0LCBEb0NoZWNrIHtcbiAgICBwcml2YXRlIF90b2dnbGVJZDogc3RyaW5nID0gKG5leHRJZCsrKS50b1N0cmluZygpO1xuXG4gICAgcHJpdmF0ZSBfc2VsZWN0aW9uOiBhbnk7XG5cbiAgICBwcml2YXRlIF9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZXJyb3JTdGF0ZSA9IGZhbHNlO1xuICAgIC8vIGVtaXRzIHRvIHNpZ25hbCBjaGlsZHJlbiB0byBydW4gY2hhbmdlIGRldGVjdGlvblxuICAgIF9kaXNhYmxlQ2hhbmdlID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgYWRkaXRpb25hbENsYXNzZXMgPSAnJztcblxuICAgIC8qKiBTZXRzIHRoZSBjb21wb25lbnQgdG8gdGhlIGRpc2FibGVkIHN0YXRlLiovXG4gICAgQElucHV0KCdueERpc2FibGVkJylcbiAgICBzZXQgZGlzYWJsZWQodmFsdWU6IEJvb2xlYW5JbnB1dCkge1xuICAgICAgICBjb25zdCBjb2VyY2VkID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkICE9PSBjb2VyY2VkKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGNvZXJjZWQ7XG4gICAgICAgICAgICB0aGlzLl9kaXNhYmxlQ2hhbmdlLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX25hbWUhOiBzdHJpbmc7XG5cbiAgICAvKiogU2V0cyB0aGUgbmFtZSB1c2VkIGZvciBhY2Nlc3NpYmlsaXR5LiAqL1xuICAgIEBJbnB1dCgnbnhOYW1lJylcbiAgICBzZXQgbmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLl9uYW1lICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBuYW1lKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihOeFJhZGlvVG9nZ2xlQnV0dG9uQmFzZUNvbXBvbmVudClcbiAgICB0b2dnbGVCdXR0b25zOiBRdWVyeUxpc3Q8TnhSYWRpb1RvZ2dsZUJ1dHRvbkJhc2VDb21wb25lbnQ+ID0gbmV3IFF1ZXJ5TGlzdCgpO1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBfZGVzdHJveWVkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIHByaXZhdGUgb25Ub3VjaGVkQ2FsbGJhY2sgPSAoKSA9PiB7fTtcblxuICAgIHByaXZhdGUgb25DaGFuZ2VDYWxsYmFjayA9IChvcHRpb246IGFueSkgPT4ge307XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgLyoqIEBkb2NzLXByaXZhdGUgKi8gQE9wdGlvbmFsKCkgQFNlbGYoKSBwdWJsaWMgbmdDb250cm9sOiBOZ0NvbnRyb2wgfCBudWxsLFxuICAgICAgICBwcml2YXRlIF9lcnJvclN0YXRlTWF0Y2hlcjogRXJyb3JTdGF0ZU1hdGNoZXIsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm06IE5nRm9ybSB8IG51bGwsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm1Hcm91cDogRm9ybUdyb3VwRGlyZWN0aXZlIHwgbnVsbCxcbiAgICApIHtcbiAgICAgICAgaWYgKHRoaXMubmdDb250cm9sKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB3ZSBwcm92aWRlIHRoZSB2YWx1ZSBhY2Nlc3NvciB0aHJvdWdoIGhlcmUsIGluc3RlYWQgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBgcHJvdmlkZXJzYCB0byBhdm9pZCBydW5uaW5nIGludG8gYSBjaXJjdWxhciBpbXBvcnQuXG4gICAgICAgICAgICB0aGlzLm5nQ29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgdGhpcy50b2dnbGVCdXR0b25zLmNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgIHN0YXJ0V2l0aCh0aGlzLnRvZ2dsZUJ1dHRvbnMpLFxuICAgICAgICAgICAgICAgIHN3aXRjaE1hcChfID0+IG1lcmdlKC4uLnRoaXMudG9nZ2xlQnV0dG9ucy5tYXAoKGJ1dHRvbjogYW55KSA9PiBidXR0b24ub25DaGVja2VkIGFzIE9ic2VydmFibGU8TnhSYWRpb1RvZ2dsZUJ1dHRvbkNoYW5nZT4pKSksXG4gICAgICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCksXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGNoYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gY2hhbmdlLnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlKHRoaXMuX3NlbGVjdGlvbik7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbnMuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoc3RhcnRXaXRoKHRoaXMudG9nZ2xlQnV0dG9ucyksIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgodG9nZ2xlczogUXVlcnlMaXN0PE54UmFkaW9Ub2dnbGVCdXR0b25Db21wb25lbnQ+KSA9PiB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlcy5mb3JFYWNoKHRvZ2dsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZS5yZXNldENsYXNzZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvZ2dsZS52YWx1ZSA9PT0gdGhpcy5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdGhlIHNlbGVjdGlvbiBmb3IgdGhlIGVkZ2UgY2FzZSB0aGF0IHRoZSBidXR0b24gd2l0aCB0aGUgdmFsdWUgb2YgdGhpcy5zZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZG4ndCBleGlzdCB5ZXQgYnV0IHdhcyBhZGRlZCBhZnRlcndhcmRzIHRvIHByZXZlbnQgY2hhbmdlZCBhZnRlciBjaGVja2VkIGVycm9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0b2dnbGUuc2VsZWN0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHRvZ2dsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVzLmZpcnN0LnNldEZpcnN0QnV0dG9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZXMubGFzdC5zZXRMYXN0QnV0dG9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9kaXNhYmxlQ2hhbmdlLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5uZ0NvbnRyb2wpIHtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhpcyBvbiBldmVyeSBjaGFuZ2UgZGV0ZWN0aW9uIGN5Y2xlLCBiZWNhdXNlIHRoZXJlIGFyZSBzb21lXG4gICAgICAgICAgICAvLyBlcnJvciB0cmlnZ2VycyB0aGF0IHdlIGNhbid0IHN1YnNjcmliZSB0byAoZS5nLiBwYXJlbnQgZm9ybSBzdWJtaXNzaW9ucykuIFRoaXMgbWVhbnNcbiAgICAgICAgICAgIC8vIHRoYXQgd2hhdGV2ZXIgbG9naWMgaXMgaW4gaGVyZSBoYXMgdG8gYmUgc3VwZXIgbGVhbiBvciB3ZSByaXNrIGRlc3Ryb3lpbmcgdGhlIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgdGhpcy51cGRhdGVFcnJvclN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKG9uQ2hhbmdlQ2FsbGJhY2s6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBvbkNoYW5nZUNhbGxiYWNrO1xuICAgIH1cblxuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZENhbGxiYWNrOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjayA9IG9uVG91Y2hlZENhbGxiYWNrO1xuICAgIH1cblxuICAgIC8qKiBQcmVzZWxlY3RzIHRoZSByZXNwZWN0aXZlIG9wdGlvbnMuICovXG4gICAgQElucHV0KCdueFNlbGVjdGlvbicpXG4gICAgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IHZhbHVlO1xuICAgICAgICBjb25zdCBjb3JyZXNwb25kaW5nQnV0dG9uID0gdGhpcy50b2dnbGVCdXR0b25zLmZpbmQoKGJ1dHRvbjogTnhSYWRpb1RvZ2dsZUJ1dHRvbkJhc2VDb21wb25lbnQpID0+IGJ1dHRvbi52YWx1ZSA9PT0gdGhpcy5fc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGNvcnJlc3BvbmRpbmdCdXR0b24pIHtcbiAgICAgICAgICAgIChjb3JyZXNwb25kaW5nQnV0dG9uIGFzIE54UmFkaW9Ub2dnbGVCdXR0b25Db21wb25lbnQpLnNlbGVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSRVNFVF9WQUxVRVMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUJ1dHRvbnMubWFwKChidXR0b246IE54UmFkaW9Ub2dnbGVCdXR0b25CYXNlQ29tcG9uZW50KSA9PiAoYnV0dG9uIGFzIE54UmFkaW9Ub2dnbGVCdXR0b25Db21wb25lbnQpLmRlc2VsZWN0KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgbngtcmFkaW8tdG9nZ2xlLSR7dGhpcy5fdG9nZ2xlSWR9YDtcbiAgICB9XG5cbiAgICAvKiogU2V0cyB0aGUgbW9kaWZpZXJzIGZvciB0aGUgY29tcG9uZW50LiAqL1xuICAgIEBJbnB1dCgnbnhTdHlsZScpXG4gICAgc2V0IHN0eWxlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5hZGRpdGlvbmFsQ2xhc3NlcyA9IG1hcENsYXNzTmFtZXModmFsdWUsIFtdLCBNQVBQSU5HKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZG9jcy1wcml2YXRlXG4gICAgICovXG4gICAgZ2V0IHNlbGVjdGlvbigpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgY2hhbmdlKHZhbHVlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMub25Ub3VjaGVkQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgdXBkYXRlRXJyb3JTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmVycm9yU3RhdGU7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudEZvcm1Hcm91cCB8fCB0aGlzLl9wYXJlbnRGb3JtO1xuICAgICAgICBjb25zdCBjb250cm9sID0gdGhpcy5uZ0NvbnRyb2wgPyAodGhpcy5uZ0NvbnRyb2wuY29udHJvbCBhcyBGb3JtQ29udHJvbCkgOiBudWxsO1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuX2Vycm9yU3RhdGVNYXRjaGVyLmlzRXJyb3JTdGF0ZShjb250cm9sLCBwYXJlbnQpO1xuXG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiPGRpdiBjbGFzcz1cIm54LXJhZGlvLXRvZ2dsZVwiIFtuZ0NsYXNzXT1cImFkZGl0aW9uYWxDbGFzc2VzXCIgcm9sZT1cInJhZGlvZ3JvdXBcIiBbYXR0ci5hcmlhLWxhYmVsXT1cIm5hbWVcIj5cbiAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5cbiJdfQ==