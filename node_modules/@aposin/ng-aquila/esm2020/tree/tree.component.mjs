import { DOWN_ARROW, END, HOME, LEFT_ARROW, NUMPAD_MULTIPLY, RIGHT_ARROW, UP_ARROW } from '@angular/cdk/keycodes';
import { CdkTree, CdkTreeNode } from '@angular/cdk/tree';
import { ChangeDetectionStrategy, Component, Input, Optional, ViewChild, ViewEncapsulation, } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { NxTreeNodeOutletDirective } from './outlet';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/bidi";
import * as i2 from "@angular/cdk/a11y";
import * as i3 from "./outlet";
/**
 * Wrapper for the CdkTree with custom design styles and keyboard nav mechanics.
 */
export class NxTreeComponent extends CdkTree {
    constructor(_wrapperDiffers, _cdr, dir, _elementRef, _focusMonitor) {
        super(_wrapperDiffers, _cdr);
        this._wrapperDiffers = _wrapperDiffers;
        this._cdr = _cdr;
        this.dir = dir;
        this._elementRef = _elementRef;
        this._focusMonitor = _focusMonitor;
        /** The node map map data nodes to CdkTreeNodes */
        this.nodeMap = new Map();
        /** A map from parent node to a list of children. */
        this.childrenMap = new Map();
        /** A map from node data to its parent node data. */
        this.parentMap = new Map();
        /** Tab index for the tree. */
        this._tabIndex = 0;
        /**
         * User defined tab index.
         * When it is not null, use user defined tab index. Otherwise use _tabIndex
         */
        this._userTabIndex = null;
        /** Subject that emits when the component has been destroyed. */
        this._wrapperOnDestroy = new Subject();
    }
    set tabIndex(value) {
        this._userTabIndex = value;
    }
    ngOnInit() {
        super.ngOnInit();
        this._monitorTreeFocus();
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this._wrapperOnDestroy.next();
        this._wrapperOnDestroy.complete();
    }
    /** Get current focused data */
    get focusedData() {
        return this._focusedData;
    }
    /** Add tree node to data list based on owner of parent view container. */
    insertToA11yNodeTracking(index, data, node, parentData) {
        this.nodeMap.set(data, node);
        if (parentData) {
            this.parentMap.set(data, parentData);
        }
        this._getChildrenList(parentData).splice(index, 0, data);
    }
    /** Remove a node data from node list based on the owner of view container. */
    removeFromA11yNodeTracking(index, parentData) {
        const nodeList = this._getChildrenList(parentData);
        const removed = nodeList.splice(index, 1)[0];
        if (removed && removed === this._focusedData) {
            this._changeFocusedData(this._getNextVisibleNode());
        }
        this.nodeMap.delete(removed);
        this.parentMap.delete(removed);
        this.childrenMap.delete(removed);
    }
    /** Update node's index information based on the owner of view container. */
    moveInA11yNodeTracking(previousIndex, currentIndex, parentData) {
        const nodeList = this._getChildrenList(parentData);
        const target = nodeList.splice(previousIndex, 1);
        nodeList.splice(currentIndex, 0, target[0]);
    }
    /** When a tree node is focused, update the current focused data. */
    updateFocusedData(newFocusedData) {
        this._focusedData = newFocusedData;
    }
    /** Focus first node when the tree is focused */
    focus() {
        this._focusedData ? this._changeFocusedData(this._focusedData) : this.focusFirstVisibleNode();
    }
    /** Change focus to first visible node in the tree. */
    focusFirstVisibleNode() {
        this._changeFocusedData(this._getFirstVisibleNode());
    }
    /** Change focus to last visible node in the tree. */
    focusLastVisibleNode() {
        this._changeFocusedData(this._getLastVisibleNode());
    }
    /** Change focus to previous visible node. */
    focusPreviousVisibleNode() {
        if (!this._focusedData) {
            return this.focusLastVisibleNode();
        }
        this._changeFocusedData(this._getPreviousVisibleNode());
    }
    /** Change focus to next visible node. */
    focusNextVisibleNode() {
        if (!this._focusedData) {
            return this.focusFirstVisibleNode();
        }
        this._changeFocusedData(this._getNextVisibleNode());
    }
    /** Collapse the current node if it's expanded. Otherwise move to parent. */
    collapseCurrentFocusedNode() {
        if (this._focusedData && this.treeControl) {
            if (this.treeControl.isExpanded(this._focusedData)) {
                this.treeControl.collapse(this._focusedData);
            }
            else {
                this._changeFocusedData(this._getParentNode());
            }
        }
    }
    /** Expand the current node if it's not expanded. Otherwise move to its first child. */
    expandCurrentFocusedNode() {
        if (this._focusedData && this.treeControl) {
            if (this.treeControl.isExpanded(this._focusedData)) {
                this._changeFocusedData(this._getNextVisibleNode());
            }
            else {
                this.treeControl.expand(this._focusedData);
            }
        }
    }
    /** Expand all the nodes in the tree */
    expandAllNodes() {
        if (this.treeControl) {
            this.treeControl.expandAll();
        }
    }
    /** Expand the current node if it's not expanded. Otherwise move to its first child. */
    toggleCurrentFocusedNode() {
        if (this._focusedData && this.treeControl) {
            this.treeControl.toggle(this._focusedData);
        }
    }
    _isRtl() {
        return this.dir && this.dir.value === 'rtl';
    }
    /**
     * Pass events to the keyboard manager. Available here for tests.
     */
    _handleKeydown(event) {
        switch (event.keyCode) {
            case HOME:
                this.focusFirstVisibleNode();
                event.preventDefault();
                break;
            case END:
                this.focusLastVisibleNode();
                event.preventDefault();
                break;
            case UP_ARROW:
                this.focusPreviousVisibleNode();
                event.preventDefault();
                break;
            case DOWN_ARROW:
                this.focusNextVisibleNode();
                event.preventDefault();
                break;
            case LEFT_ARROW:
                this._isRtl() ? this.expandCurrentFocusedNode() : this.collapseCurrentFocusedNode();
                event.preventDefault();
                break;
            case RIGHT_ARROW:
                this._isRtl() ? this.collapseCurrentFocusedNode() : this.expandCurrentFocusedNode();
                event.preventDefault();
                break;
            case NUMPAD_MULTIPLY:
                this.expandAllNodes();
                event.preventDefault();
                break;
            default:
        }
    }
    /** Focus the tree node component with new focused data. */
    _changeFocusedData(newFocused) {
        if (newFocused) {
            this._focusedData = newFocused;
            if (this.nodeMap.has(this._focusedData)) {
                this.nodeMap.get(this._focusedData).focus();
            }
        }
    }
    /** Returns the data of the first visible tree node in the tree. */
    _getFirstVisibleNode() {
        const nodeList = this._getChildrenList();
        return nodeList[0];
    }
    /** Returns the data of the last visible tree node in the tree. */
    _getLastVisibleNode() {
        const nodeList = this._getChildrenList();
        return this._getLastChild(nodeList[nodeList.length - 1]);
    }
    /** Returns the previous visible tree node of current focused data. */
    _getPreviousVisibleNode() {
        if (!this._focusedData) {
            return;
        }
        const parent = this.parentMap.get(this._focusedData);
        const nodeList = this.childrenMap.get(parent);
        const index = nodeList.indexOf(this._focusedData);
        if (index === 0) {
            return parent;
        }
        else if (index > 0) {
            return this._getLastChild(nodeList[index - 1]);
        }
        return undefined;
    }
    /** Returns the next visible tree node data of current focused data. */
    _getNextVisibleNode() {
        if (!this._focusedData) {
            return;
        }
        // Always return first child if the node is expanded
        if (this.childrenMap.has(this._focusedData) && this.treeControl && this.treeControl.isExpanded(this._focusedData)) {
            const childNodeList = this._getChildrenList(this._focusedData);
            if (childNodeList.length) {
                return childNodeList[0];
            }
        }
        // Or return next sibling / parent's next child if any
        let currentData = this._focusedData;
        while (currentData) {
            const parent = this.parentMap.get(currentData);
            const nodeList = this.childrenMap.get(parent);
            const index = nodeList.indexOf(currentData);
            if (index === nodeList.length - 1) {
                currentData = parent;
            }
            else if (index > -1) {
                return nodeList[index + 1];
            }
        }
        return undefined;
    }
    /** Returns the parent of current focused node. */
    _getParentNode() {
        if (this.parentMap.has(this._focusedData)) {
            // For nested tree
            this._changeFocusedData(this.parentMap.get(this._focusedData));
        }
        else if (this.treeControl.getLevel) {
            // For flat tree
            const nodeList = this._getChildrenList();
            const index = nodeList.indexOf(this._focusedData);
            const level = this.treeControl.getLevel(this._focusedData) - 1;
            if (index <= 0) {
                return;
            }
            for (let i = index - 1; i >= 0; i--) {
                if (this.treeControl.getLevel(nodeList[i]) === level) {
                    return nodeList[i];
                }
            }
        }
        return undefined;
    }
    /**
     * Returns the data of list of children in the current `parentData` node's view container.
     * If there's no parent, return the tree nodes in the tree's view container.
     */
    _getChildrenList(parentData) {
        if (!this.childrenMap.has(parentData)) {
            this.childrenMap.set(parentData, []);
        }
        return this.childrenMap.get(parentData);
    }
    /**
     * Returns the data of last visible elements in the sub-tree rooted at `targetNode`.
     */
    _getLastChild(targetNode) {
        let currentData = targetNode;
        while (currentData && this.childrenMap.has(currentData) && this.treeControl && this.treeControl.isExpanded(currentData)) {
            const childNodeList = this._getChildrenList(currentData);
            if (childNodeList.length) {
                currentData = childNodeList[childNodeList.length - 1];
            }
            else {
                break;
            }
        }
        return currentData;
    }
    /**
     * Extended CdkTree method to track new nodes for a11y.
     */
    insertNode(nodeData, index, viewContainer, parentData) {
        super.insertNode(nodeData, index, viewContainer, parentData);
        if (CdkTreeNode.mostRecentTreeNode) {
            this.insertToA11yNodeTracking(index, nodeData, CdkTreeNode.mostRecentTreeNode, parentData);
            CdkTreeNode.mostRecentTreeNode.focus();
        }
    }
    /**
     * ⚠️  Here we override the method from cdk tree ⚠️
     * Adds some extra method calls to update the a11y node tracking.
     */
    renderNodeChanges(data, dataDiffer = this['_dataDiffer'], viewContainer = this._nodeOutlet.viewContainer, parentData) {
        super.renderNodeChanges(data, dataDiffer, viewContainer, parentData);
        const changes = dataDiffer.diff(data);
        if (!changes) {
            return;
        }
        changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {
            if (currentIndex == null) {
                this.removeFromA11yNodeTracking(adjustedPreviousIndex, parentData);
            }
            else if (item.previousIndex !== null) {
                this.moveInA11yNodeTracking(adjustedPreviousIndex, currentIndex, parentData);
            }
        });
    }
    /**
     * Monitor focus of the tree. When the tree is focused, change the tab index to -1 so TAB
     * can move the focus out of the tree. When the tree is blurred, change back the tab index.
     */
    _monitorTreeFocus() {
        this._focusMonitor
            .monitor(this._elementRef.nativeElement, true)
            .pipe(takeUntil(this._wrapperOnDestroy))
            .subscribe(origin => {
            const newTabIndex = origin ? -1 : this._userTabIndex || 0;
            if (this._tabIndex !== newTabIndex) {
                this._tabIndex = newTabIndex;
                this._cdr.markForCheck();
            }
        });
    }
}
NxTreeComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeComponent, deps: [{ token: i0.IterableDiffers }, { token: i0.ChangeDetectorRef }, { token: i1.Directionality, optional: true }, { token: i0.ElementRef }, { token: i2.FocusMonitor }], target: i0.ɵɵFactoryTarget.Component });
NxTreeComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTreeComponent, selector: "nx-tree", inputs: { tabIndex: "tabIndex" }, host: { attributes: { "role": "application" }, listeners: { "keydown": "_handleKeydown($event)", "focus": "focus()" }, properties: { "attr.tabindex": "_tabIndex" }, classAttribute: "nx-tree cdk-tree" }, providers: [{ provide: CdkTree, useExisting: NxTreeComponent }], viewQueries: [{ propertyName: "_nodeOutlet", first: true, predicate: NxTreeNodeOutletDirective, descendants: true, static: true }], exportAs: ["nxTree"], usesInheritance: true, ngImport: i0, template: `<ng-container nxTreeNodeOutlet></ng-container>`, isInline: true, styles: [":host.nx-tree{display:block}.nx-tree__node{display:block;overflow:hidden}.nx-tree__node.cdk-keyboard-focused{box-shadow:var(--focus-inset-box-shadow);border-radius:8px}@media screen and (-ms-high-contrast: active){.nx-tree__node.cdk-keyboard-focused{box-shadow:inset 0 0 0 4px windowText,inset 0 0 0 6px background;border:4px solid CanvasText}}\n"], directives: [{ type: i3.NxTreeNodeOutletDirective, selector: "[nxTreeNodeOutlet]" }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTreeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tree', exportAs: 'nxTree', template: `<ng-container nxTreeNodeOutlet></ng-container>`, host: {
                        // The 'cdk-tree' class needs to be included here because classes set in the host in the
                        // parent class are not inherited with View Engine. The 'cdk-tree' class in CdkTreeNode has
                        // to be set in the host because:
                        // if it is set as a @HostBinding it is not set by the time the tree nodes try to read the
                        // class from it.
                        // the ElementRef is not available in the constructor so the class can't be applied directly
                        // without a breaking constructor change.
                        class: 'nx-tree cdk-tree',
                        role: 'application',
                        '[attr.tabindex]': '_tabIndex',
                        '(keydown)': '_handleKeydown($event)',
                        '(focus)': 'focus()',
                    }, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, providers: [{ provide: CdkTree, useExisting: NxTreeComponent }], styles: [":host.nx-tree{display:block}.nx-tree__node{display:block;overflow:hidden}.nx-tree__node.cdk-keyboard-focused{box-shadow:var(--focus-inset-box-shadow);border-radius:8px}@media screen and (-ms-high-contrast: active){.nx-tree__node.cdk-keyboard-focused{box-shadow:inset 0 0 0 4px windowText,inset 0 0 0 6px background;border:4px solid CanvasText}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }, { type: i1.Directionality, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef }, { type: i2.FocusMonitor }]; }, propDecorators: { _nodeOutlet: [{
                type: ViewChild,
                args: [NxTreeNodeOutletDirective, { static: true }]
            }], tabIndex: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL3RyZWUvdHJlZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxlQUFlLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ2xILE9BQU8sRUFBRSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDekQsT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBRVQsS0FBSyxFQU1MLFFBQVEsRUFDUixTQUFTLEVBRVQsaUJBQWlCLEdBQ3BCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLFVBQVUsQ0FBQzs7Ozs7QUFFckQ7O0dBRUc7QUF3QkgsTUFBTSxPQUFPLGVBQW1CLFNBQVEsT0FBVTtJQWlDOUMsWUFDWSxlQUFnQyxFQUNoQyxJQUF1QixFQUNYLEdBQTBCLEVBQ3BDLFdBQXVCLEVBQ3ZCLGFBQTJCO1FBRXJDLEtBQUssQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFOckIsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBQ2hDLFNBQUksR0FBSixJQUFJLENBQW1CO1FBQ1gsUUFBRyxHQUFILEdBQUcsQ0FBdUI7UUFDcEMsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDdkIsa0JBQWEsR0FBYixhQUFhLENBQWM7UUFsQ3pDLGtEQUFrRDtRQUN4QyxZQUFPLEdBQTRCLElBQUksR0FBRyxFQUFzQixDQUFDO1FBRTNFLG9EQUFvRDtRQUMxQyxnQkFBVyxHQUE0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QUEyRjt3QkFDM0YsaUNBQWlDO3dCQUNqQywwRkFBMEY7d0JBQzFGLGlCQUFpQjt3QkFDakIsNEZBQTRGO3dCQUM1Rix5Q0FBeUM7d0JBQ3pDLEtBQUssRUFBRSxrQkFBa0I7d0JBQ3pCLElBQUksRUFBRSxhQUFhO3dCQUNuQixpQkFBaUIsRUFBRSxXQUFXO3dCQUM5QixXQUFXLEVBQUUsd0JBQXdCO3dCQUNyQyxTQUFTLEVBQUUsU0FBUztxQkFDdkIsaUJBRWMsaUJBQWlCLENBQUMsSUFBSSxtQkFDcEIsdUJBQXVCLENBQUMsTUFBTSxhQUNwQyxDQUFDLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxXQUFXLGlCQUFpQixFQUFFLENBQUM7OzBCQXNDMUQsUUFBUTtnR0FsQzJDLFdBQVc7c0JBQWxFLFNBQVM7dUJBQUMseUJBQXlCLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQXdCbEQsUUFBUTtzQkFEWCxLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRm9jdXNhYmxlT3B0aW9uLCBGb2N1c01vbml0b3IgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IERPV05fQVJST1csIEVORCwgSE9NRSwgTEVGVF9BUlJPVywgTlVNUEFEX01VTFRJUExZLCBSSUdIVF9BUlJPVywgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgQ2RrVHJlZSwgQ2RrVHJlZU5vZGUgfSBmcm9tICdAYW5ndWxhci9jZGsvdHJlZSc7XG5pbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIElucHV0LFxuICAgIEl0ZXJhYmxlQ2hhbmdlUmVjb3JkLFxuICAgIEl0ZXJhYmxlRGlmZmVyLFxuICAgIEl0ZXJhYmxlRGlmZmVycyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE9wdGlvbmFsLFxuICAgIFZpZXdDaGlsZCxcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxuICAgIFZpZXdFbmNhcHN1bGF0aW9uLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnhUcmVlTm9kZU91dGxldERpcmVjdGl2ZSB9IGZyb20gJy4vb3V0bGV0JztcblxuLyoqXG4gKiBXcmFwcGVyIGZvciB0aGUgQ2RrVHJlZSB3aXRoIGN1c3RvbSBkZXNpZ24gc3R5bGVzIGFuZCBrZXlib2FyZCBuYXYgbWVjaGFuaWNzLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ254LXRyZWUnLFxuICAgIGV4cG9ydEFzOiAnbnhUcmVlJyxcbiAgICB0ZW1wbGF0ZTogYDxuZy1jb250YWluZXIgbnhUcmVlTm9kZU91dGxldD48L25nLWNvbnRhaW5lcj5gLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgLy8gVGhlICdjZGstdHJlZScgY2xhc3MgbmVlZHMgdG8gYmUgaW5jbHVkZWQgaGVyZSBiZWNhdXNlIGNsYXNzZXMgc2V0IGluIHRoZSBob3N0IGluIHRoZVxuICAgICAgICAvLyBwYXJlbnQgY2xhc3MgYXJlIG5vdCBpbmhlcml0ZWQgd2l0aCBWaWV3IEVuZ2luZS4gVGhlICdjZGstdHJlZScgY2xhc3MgaW4gQ2RrVHJlZU5vZGUgaGFzXG4gICAgICAgIC8vIHRvIGJlIHNldCBpbiB0aGUgaG9zdCBiZWNhdXNlOlxuICAgICAgICAvLyBpZiBpdCBpcyBzZXQgYXMgYSBASG9zdEJpbmRpbmcgaXQgaXMgbm90IHNldCBieSB0aGUgdGltZSB0aGUgdHJlZSBub2RlcyB0cnkgdG8gcmVhZCB0aGVcbiAgICAgICAgLy8gY2xhc3MgZnJvbSBpdC5cbiAgICAgICAgLy8gdGhlIEVsZW1lbnRSZWYgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgY29uc3RydWN0b3Igc28gdGhlIGNsYXNzIGNhbid0IGJlIGFwcGxpZWQgZGlyZWN0bHlcbiAgICAgICAgLy8gd2l0aG91dCBhIGJyZWFraW5nIGNvbnN0cnVjdG9yIGNoYW5nZS5cbiAgICAgICAgY2xhc3M6ICdueC10cmVlIGNkay10cmVlJyxcbiAgICAgICAgcm9sZTogJ2FwcGxpY2F0aW9uJyxcbiAgICAgICAgJ1thdHRyLnRhYmluZGV4XSc6ICdfdGFiSW5kZXgnLFxuICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAnKGZvY3VzKSc6ICdmb2N1cygpJyxcbiAgICB9LFxuICAgIHN0eWxlVXJsczogWyd0cmVlLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IENka1RyZWUsIHVzZUV4aXN0aW5nOiBOeFRyZWVDb21wb25lbnQgfV0sXG59KVxuZXhwb3J0IGNsYXNzIE54VHJlZUNvbXBvbmVudDxUPiBleHRlbmRzIENka1RyZWU8VD4gaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gICAgLy8gT3V0bGV0cyB3aXRoaW4gdGhlIHRyZWUncyB0ZW1wbGF0ZSB3aGVyZSB0aGUgZGF0YU5vZGVzIHdpbGwgYmUgaW5zZXJ0ZWQuXG4gICAgQFZpZXdDaGlsZChOeFRyZWVOb2RlT3V0bGV0RGlyZWN0aXZlLCB7IHN0YXRpYzogdHJ1ZSB9KSBfbm9kZU91dGxldCE6IE54VHJlZU5vZGVPdXRsZXREaXJlY3RpdmU7XG5cbiAgICAvKiogVGhlIG5vZGUgbWFwIG1hcCBkYXRhIG5vZGVzIHRvIENka1RyZWVOb2RlcyAqL1xuICAgIHByb3RlY3RlZCBub2RlTWFwOiBNYXA8VCwgRm9jdXNhYmxlT3B0aW9uPiA9IG5ldyBNYXA8VCwgRm9jdXNhYmxlT3B0aW9uPigpO1xuXG4gICAgLyoqIEEgbWFwIGZyb20gcGFyZW50IG5vZGUgdG8gYSBsaXN0IG9mIGNoaWxkcmVuLiAqL1xuICAgIHByb3RlY3RlZCBjaGlsZHJlbk1hcDogTWFwPFQgfCB1bmRlZmluZWQsIFRbXT4gPSBuZXcgTWFwPFQgfCB1bmRlZmluZWQsIFRbXT4oKTtcblxuICAgIC8qKiBBIG1hcCBmcm9tIG5vZGUgZGF0YSB0byBpdHMgcGFyZW50IG5vZGUgZGF0YS4gKi9cbiAgICBwcm90ZWN0ZWQgcGFyZW50TWFwOiBNYXA8VCwgVD4gPSBuZXcgTWFwPFQsIFQ+KCk7XG5cbiAgICAvKiogQ3VycmVudCBmb2N1c2VkIG5vZGUgZGF0YS4gKi9cbiAgICBwcm90ZWN0ZWQgX2ZvY3VzZWREYXRhITogVDtcblxuICAgIC8qKiBUYWIgaW5kZXggZm9yIHRoZSB0cmVlLiAqL1xuICAgIF90YWJJbmRleCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VyIGRlZmluZWQgdGFiIGluZGV4LlxuICAgICAqIFdoZW4gaXQgaXMgbm90IG51bGwsIHVzZSB1c2VyIGRlZmluZWQgdGFiIGluZGV4LiBPdGhlcndpc2UgdXNlIF90YWJJbmRleFxuICAgICAqL1xuICAgIF91c2VyVGFiSW5kZXg6IG51bWJlciB8IG51bGwgPSBudWxsO1xuXG4gICAgQElucHV0KClcbiAgICBzZXQgdGFiSW5kZXgodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl91c2VyVGFiSW5kZXggPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKiogU3ViamVjdCB0aGF0IGVtaXRzIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBkZXN0cm95ZWQuICovXG4gICAgcHJpdmF0ZSBfd3JhcHBlck9uRGVzdHJveSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfd3JhcHBlckRpZmZlcnM6IEl0ZXJhYmxlRGlmZmVycyxcbiAgICAgICAgcHJpdmF0ZSBfY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBkaXI6IERpcmVjdGlvbmFsaXR5IHwgbnVsbCxcbiAgICAgICAgcHJvdGVjdGVkIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcm90ZWN0ZWQgX2ZvY3VzTW9uaXRvcjogRm9jdXNNb25pdG9yLFxuICAgICkge1xuICAgICAgICBzdXBlcihfd3JhcHBlckRpZmZlcnMsIF9jZHIpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuICAgICAgICB0aGlzLl9tb25pdG9yVHJlZUZvY3VzKCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLm5nT25EZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX3dyYXBwZXJPbkRlc3Ryb3kubmV4dCgpO1xuICAgICAgICB0aGlzLl93cmFwcGVyT25EZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqIEdldCBjdXJyZW50IGZvY3VzZWQgZGF0YSAqL1xuICAgIGdldCBmb2N1c2VkRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWREYXRhO1xuICAgIH1cblxuICAgIC8qKiBBZGQgdHJlZSBub2RlIHRvIGRhdGEgbGlzdCBiYXNlZCBvbiBvd25lciBvZiBwYXJlbnQgdmlldyBjb250YWluZXIuICovXG4gICAgaW5zZXJ0VG9BMTF5Tm9kZVRyYWNraW5nKGluZGV4OiBudW1iZXIsIGRhdGE6IFQsIG5vZGU6IEZvY3VzYWJsZU9wdGlvbiwgcGFyZW50RGF0YT86IFQpIHtcbiAgICAgICAgdGhpcy5ub2RlTWFwLnNldChkYXRhLCBub2RlKTtcbiAgICAgICAgaWYgKHBhcmVudERhdGEpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50TWFwLnNldChkYXRhLCBwYXJlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nZXRDaGlsZHJlbkxpc3QocGFyZW50RGF0YSkuc3BsaWNlKGluZGV4LCAwLCBkYXRhKTtcbiAgICB9XG5cbiAgICAvKiogUmVtb3ZlIGEgbm9kZSBkYXRhIGZyb20gbm9kZSBsaXN0IGJhc2VkIG9uIHRoZSBvd25lciBvZiB2aWV3IGNvbnRhaW5lci4gKi9cbiAgICByZW1vdmVGcm9tQTExeU5vZGVUcmFja2luZyhpbmRleDogbnVtYmVyLCBwYXJlbnREYXRhPzogVCkge1xuICAgICAgICBjb25zdCBub2RlTGlzdCA9IHRoaXMuX2dldENoaWxkcmVuTGlzdChwYXJlbnREYXRhKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG5vZGVMaXN0LnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgIGlmIChyZW1vdmVkICYmIHJlbW92ZWQgPT09IHRoaXMuX2ZvY3VzZWREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGFuZ2VGb2N1c2VkRGF0YSh0aGlzLl9nZXROZXh0VmlzaWJsZU5vZGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlTWFwLmRlbGV0ZShyZW1vdmVkKTtcbiAgICAgICAgdGhpcy5wYXJlbnRNYXAuZGVsZXRlKHJlbW92ZWQpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuTWFwLmRlbGV0ZShyZW1vdmVkKTtcbiAgICB9XG5cbiAgICAvKiogVXBkYXRlIG5vZGUncyBpbmRleCBpbmZvcm1hdGlvbiBiYXNlZCBvbiB0aGUgb3duZXIgb2YgdmlldyBjb250YWluZXIuICovXG4gICAgbW92ZUluQTExeU5vZGVUcmFja2luZyhwcmV2aW91c0luZGV4OiBudW1iZXIsIGN1cnJlbnRJbmRleDogbnVtYmVyLCBwYXJlbnREYXRhPzogVCkge1xuICAgICAgICBjb25zdCBub2RlTGlzdCA9IHRoaXMuX2dldENoaWxkcmVuTGlzdChwYXJlbnREYXRhKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbm9kZUxpc3Quc3BsaWNlKHByZXZpb3VzSW5kZXgsIDEpO1xuICAgICAgICBub2RlTGlzdC5zcGxpY2UoY3VycmVudEluZGV4LCAwLCB0YXJnZXRbMF0pO1xuICAgIH1cblxuICAgIC8qKiBXaGVuIGEgdHJlZSBub2RlIGlzIGZvY3VzZWQsIHVwZGF0ZSB0aGUgY3VycmVudCBmb2N1c2VkIGRhdGEuICovXG4gICAgdXBkYXRlRm9jdXNlZERhdGEobmV3Rm9jdXNlZERhdGE6IFQpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZERhdGEgPSBuZXdGb2N1c2VkRGF0YTtcbiAgICB9XG5cbiAgICAvKiogRm9jdXMgZmlyc3Qgbm9kZSB3aGVuIHRoZSB0cmVlIGlzIGZvY3VzZWQgKi9cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNlZERhdGEgPyB0aGlzLl9jaGFuZ2VGb2N1c2VkRGF0YSh0aGlzLl9mb2N1c2VkRGF0YSkgOiB0aGlzLmZvY3VzRmlyc3RWaXNpYmxlTm9kZSgpO1xuICAgIH1cblxuICAgIC8qKiBDaGFuZ2UgZm9jdXMgdG8gZmlyc3QgdmlzaWJsZSBub2RlIGluIHRoZSB0cmVlLiAqL1xuICAgIGZvY3VzRmlyc3RWaXNpYmxlTm9kZSgpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlRm9jdXNlZERhdGEodGhpcy5fZ2V0Rmlyc3RWaXNpYmxlTm9kZSgpKTtcbiAgICB9XG5cbiAgICAvKiogQ2hhbmdlIGZvY3VzIHRvIGxhc3QgdmlzaWJsZSBub2RlIGluIHRoZSB0cmVlLiAqL1xuICAgIGZvY3VzTGFzdFZpc2libGVOb2RlKCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VGb2N1c2VkRGF0YSh0aGlzLl9nZXRMYXN0VmlzaWJsZU5vZGUoKSk7XG4gICAgfVxuXG4gICAgLyoqIENoYW5nZSBmb2N1cyB0byBwcmV2aW91cyB2aXNpYmxlIG5vZGUuICovXG4gICAgZm9jdXNQcmV2aW91c1Zpc2libGVOb2RlKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZvY3VzZWREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb2N1c0xhc3RWaXNpYmxlTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZUZvY3VzZWREYXRhKHRoaXMuX2dldFByZXZpb3VzVmlzaWJsZU5vZGUoKSk7XG4gICAgfVxuXG4gICAgLyoqIENoYW5nZSBmb2N1cyB0byBuZXh0IHZpc2libGUgbm9kZS4gKi9cbiAgICBmb2N1c05leHRWaXNpYmxlTm9kZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mb2N1c2VkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNGaXJzdFZpc2libGVOb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlRm9jdXNlZERhdGEodGhpcy5fZ2V0TmV4dFZpc2libGVOb2RlKCkpO1xuICAgIH1cblxuICAgIC8qKiBDb2xsYXBzZSB0aGUgY3VycmVudCBub2RlIGlmIGl0J3MgZXhwYW5kZWQuIE90aGVyd2lzZSBtb3ZlIHRvIHBhcmVudC4gKi9cbiAgICBjb2xsYXBzZUN1cnJlbnRGb2N1c2VkTm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZvY3VzZWREYXRhICYmIHRoaXMudHJlZUNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWVDb250cm9sLmlzRXhwYW5kZWQodGhpcy5fZm9jdXNlZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlQ29udHJvbC5jb2xsYXBzZSh0aGlzLl9mb2N1c2VkRGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUZvY3VzZWREYXRhKHRoaXMuX2dldFBhcmVudE5vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogRXhwYW5kIHRoZSBjdXJyZW50IG5vZGUgaWYgaXQncyBub3QgZXhwYW5kZWQuIE90aGVyd2lzZSBtb3ZlIHRvIGl0cyBmaXJzdCBjaGlsZC4gKi9cbiAgICBleHBhbmRDdXJyZW50Rm9jdXNlZE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9mb2N1c2VkRGF0YSAmJiB0aGlzLnRyZWVDb250cm9sKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmVlQ29udHJvbC5pc0V4cGFuZGVkKHRoaXMuX2ZvY3VzZWREYXRhKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUZvY3VzZWREYXRhKHRoaXMuX2dldE5leHRWaXNpYmxlTm9kZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlQ29udHJvbC5leHBhbmQodGhpcy5fZm9jdXNlZERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEV4cGFuZCBhbGwgdGhlIG5vZGVzIGluIHRoZSB0cmVlICovXG4gICAgZXhwYW5kQWxsTm9kZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyZWVDb250cm9sKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVDb250cm9sLmV4cGFuZEFsbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEV4cGFuZCB0aGUgY3VycmVudCBub2RlIGlmIGl0J3Mgbm90IGV4cGFuZGVkLiBPdGhlcndpc2UgbW92ZSB0byBpdHMgZmlyc3QgY2hpbGQuICovXG4gICAgdG9nZ2xlQ3VycmVudEZvY3VzZWROb2RlKCkge1xuICAgICAgICBpZiAodGhpcy5fZm9jdXNlZERhdGEgJiYgdGhpcy50cmVlQ29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy50cmVlQ29udHJvbC50b2dnbGUodGhpcy5fZm9jdXNlZERhdGEpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2lzUnRsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXIgJiYgdGhpcy5kaXIudmFsdWUgPT09ICdydGwnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhc3MgZXZlbnRzIHRvIHRoZSBrZXlib2FyZCBtYW5hZ2VyLiBBdmFpbGFibGUgaGVyZSBmb3IgdGVzdHMuXG4gICAgICovXG4gICAgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIEhPTUU6XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0ZpcnN0VmlzaWJsZU5vZGUoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgICAgICAgdGhpcy5mb2N1c0xhc3RWaXNpYmxlTm9kZSgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFVQX0FSUk9XOlxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNQcmV2aW91c1Zpc2libGVOb2RlKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRE9XTl9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLmZvY3VzTmV4dFZpc2libGVOb2RlKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTEVGVF9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1J0bCgpID8gdGhpcy5leHBhbmRDdXJyZW50Rm9jdXNlZE5vZGUoKSA6IHRoaXMuY29sbGFwc2VDdXJyZW50Rm9jdXNlZE5vZGUoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1J0bCgpID8gdGhpcy5jb2xsYXBzZUN1cnJlbnRGb2N1c2VkTm9kZSgpIDogdGhpcy5leHBhbmRDdXJyZW50Rm9jdXNlZE5vZGUoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBOVU1QQURfTVVMVElQTFk6XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRBbGxOb2RlcygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEZvY3VzIHRoZSB0cmVlIG5vZGUgY29tcG9uZW50IHdpdGggbmV3IGZvY3VzZWQgZGF0YS4gKi9cbiAgICBfY2hhbmdlRm9jdXNlZERhdGEobmV3Rm9jdXNlZDogVCB8IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobmV3Rm9jdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXNlZERhdGEgPSBuZXdGb2N1c2VkO1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZU1hcC5oYXModGhpcy5fZm9jdXNlZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlTWFwLmdldCh0aGlzLl9mb2N1c2VkRGF0YSkhLmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgZGF0YSBvZiB0aGUgZmlyc3QgdmlzaWJsZSB0cmVlIG5vZGUgaW4gdGhlIHRyZWUuICovXG4gICAgX2dldEZpcnN0VmlzaWJsZU5vZGUoKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGNvbnN0IG5vZGVMaXN0ID0gdGhpcy5fZ2V0Q2hpbGRyZW5MaXN0KCk7XG4gICAgICAgIHJldHVybiBub2RlTGlzdFswXTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgZGF0YSBvZiB0aGUgbGFzdCB2aXNpYmxlIHRyZWUgbm9kZSBpbiB0aGUgdHJlZS4gKi9cbiAgICBfZ2V0TGFzdFZpc2libGVOb2RlKCk6IFQgfCB1bmRlZmluZWQge1xuICAgICAgICBjb25zdCBub2RlTGlzdCA9IHRoaXMuX2dldENoaWxkcmVuTGlzdCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGFzdENoaWxkKG5vZGVMaXN0W25vZGVMaXN0Lmxlbmd0aCAtIDFdKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgcHJldmlvdXMgdmlzaWJsZSB0cmVlIG5vZGUgb2YgY3VycmVudCBmb2N1c2VkIGRhdGEuICovXG4gICAgX2dldFByZXZpb3VzVmlzaWJsZU5vZGUoKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmICghdGhpcy5fZm9jdXNlZERhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudE1hcC5nZXQodGhpcy5fZm9jdXNlZERhdGEpO1xuICAgICAgICBjb25zdCBub2RlTGlzdCA9IHRoaXMuY2hpbGRyZW5NYXAuZ2V0KHBhcmVudCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbm9kZUxpc3QhLmluZGV4T2YodGhpcy5fZm9jdXNlZERhdGEpO1xuICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGFzdENoaWxkKG5vZGVMaXN0IVtpbmRleCAtIDFdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBuZXh0IHZpc2libGUgdHJlZSBub2RlIGRhdGEgb2YgY3VycmVudCBmb2N1c2VkIGRhdGEuICovXG4gICAgX2dldE5leHRWaXNpYmxlTm9kZSgpOiBUIHwgdW5kZWZpbmVkIHtcbiAgICAgICAgaWYgKCF0aGlzLl9mb2N1c2VkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsd2F5cyByZXR1cm4gZmlyc3QgY2hpbGQgaWYgdGhlIG5vZGUgaXMgZXhwYW5kZWRcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5NYXAuaGFzKHRoaXMuX2ZvY3VzZWREYXRhKSAmJiB0aGlzLnRyZWVDb250cm9sICYmIHRoaXMudHJlZUNvbnRyb2wuaXNFeHBhbmRlZCh0aGlzLl9mb2N1c2VkRGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZUxpc3QgPSB0aGlzLl9nZXRDaGlsZHJlbkxpc3QodGhpcy5fZm9jdXNlZERhdGEpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkTm9kZUxpc3RbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3IgcmV0dXJuIG5leHQgc2libGluZyAvIHBhcmVudCdzIG5leHQgY2hpbGQgaWYgYW55XG4gICAgICAgIGxldCBjdXJyZW50RGF0YTogVCB8IHVuZGVmaW5lZCA9IHRoaXMuX2ZvY3VzZWREYXRhO1xuICAgICAgICB3aGlsZSAoY3VycmVudERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50TWFwLmdldChjdXJyZW50RGF0YSk7XG4gICAgICAgICAgICBjb25zdCBub2RlTGlzdCA9IHRoaXMuY2hpbGRyZW5NYXAuZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG5vZGVMaXN0IS5pbmRleE9mKGN1cnJlbnREYXRhKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbm9kZUxpc3QhLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0YSA9IHBhcmVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlTGlzdCFbaW5kZXggKyAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBwYXJlbnQgb2YgY3VycmVudCBmb2N1c2VkIG5vZGUuICovXG4gICAgX2dldFBhcmVudE5vZGUoKTogVCB8IHVuZGVmaW5lZCB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudE1hcC5oYXModGhpcy5fZm9jdXNlZERhdGEpKSB7XG4gICAgICAgICAgICAvLyBGb3IgbmVzdGVkIHRyZWVcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUZvY3VzZWREYXRhKHRoaXMucGFyZW50TWFwLmdldCh0aGlzLl9mb2N1c2VkRGF0YSkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHJlZUNvbnRyb2wuZ2V0TGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIEZvciBmbGF0IHRyZWVcbiAgICAgICAgICAgIGNvbnN0IG5vZGVMaXN0ID0gdGhpcy5fZ2V0Q2hpbGRyZW5MaXN0KCk7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IG5vZGVMaXN0LmluZGV4T2YodGhpcy5fZm9jdXNlZERhdGEpO1xuICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSB0aGlzLnRyZWVDb250cm9sLmdldExldmVsKHRoaXMuX2ZvY3VzZWREYXRhKSAtIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJlZUNvbnRyb2wuZ2V0TGV2ZWwobm9kZUxpc3RbaV0pID09PSBsZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZUxpc3RbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBvZiBsaXN0IG9mIGNoaWxkcmVuIGluIHRoZSBjdXJyZW50IGBwYXJlbnREYXRhYCBub2RlJ3MgdmlldyBjb250YWluZXIuXG4gICAgICogSWYgdGhlcmUncyBubyBwYXJlbnQsIHJldHVybiB0aGUgdHJlZSBub2RlcyBpbiB0aGUgdHJlZSdzIHZpZXcgY29udGFpbmVyLlxuICAgICAqL1xuICAgIF9nZXRDaGlsZHJlbkxpc3QocGFyZW50RGF0YT86IFQpOiBUW10ge1xuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW5NYXAuaGFzKHBhcmVudERhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuTWFwLnNldChwYXJlbnREYXRhLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5NYXAuZ2V0KHBhcmVudERhdGEpITtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkYXRhIG9mIGxhc3QgdmlzaWJsZSBlbGVtZW50cyBpbiB0aGUgc3ViLXRyZWUgcm9vdGVkIGF0IGB0YXJnZXROb2RlYC5cbiAgICAgKi9cbiAgICBfZ2V0TGFzdENoaWxkKHRhcmdldE5vZGU6IFQpIHtcbiAgICAgICAgbGV0IGN1cnJlbnREYXRhID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnREYXRhICYmIHRoaXMuY2hpbGRyZW5NYXAuaGFzKGN1cnJlbnREYXRhKSAmJiB0aGlzLnRyZWVDb250cm9sICYmIHRoaXMudHJlZUNvbnRyb2wuaXNFeHBhbmRlZChjdXJyZW50RGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZUxpc3QgPSB0aGlzLl9nZXRDaGlsZHJlbkxpc3QoY3VycmVudERhdGEpO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZUxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGEgPSBjaGlsZE5vZGVMaXN0W2NoaWxkTm9kZUxpc3QubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdXJyZW50RGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHRlbmRlZCBDZGtUcmVlIG1ldGhvZCB0byB0cmFjayBuZXcgbm9kZXMgZm9yIGExMXkuXG4gICAgICovXG4gICAgaW5zZXJ0Tm9kZShub2RlRGF0YTogVCwgaW5kZXg6IG51bWJlciwgdmlld0NvbnRhaW5lcj86IFZpZXdDb250YWluZXJSZWYsIHBhcmVudERhdGE/OiBUKSB7XG4gICAgICAgIHN1cGVyLmluc2VydE5vZGUobm9kZURhdGEsIGluZGV4LCB2aWV3Q29udGFpbmVyLCBwYXJlbnREYXRhKTtcblxuICAgICAgICBpZiAoQ2RrVHJlZU5vZGUubW9zdFJlY2VudFRyZWVOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydFRvQTExeU5vZGVUcmFja2luZyhpbmRleCwgbm9kZURhdGEsIENka1RyZWVOb2RlLm1vc3RSZWNlbnRUcmVlTm9kZSBhcyBDZGtUcmVlTm9kZTxUPiwgcGFyZW50RGF0YSk7XG4gICAgICAgICAgICBDZGtUcmVlTm9kZS5tb3N0UmVjZW50VHJlZU5vZGUuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIOKaoO+4jyAgSGVyZSB3ZSBvdmVycmlkZSB0aGUgbWV0aG9kIGZyb20gY2RrIHRyZWUg4pqg77iPXG4gICAgICogQWRkcyBzb21lIGV4dHJhIG1ldGhvZCBjYWxscyB0byB1cGRhdGUgdGhlIGExMXkgbm9kZSB0cmFja2luZy5cbiAgICAgKi9cbiAgICByZW5kZXJOb2RlQ2hhbmdlcyhcbiAgICAgICAgZGF0YTogVFtdLFxuICAgICAgICBkYXRhRGlmZmVyOiBJdGVyYWJsZURpZmZlcjxUPiA9IHRoaXNbJ19kYXRhRGlmZmVyJ10sXG4gICAgICAgIHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYgPSB0aGlzLl9ub2RlT3V0bGV0LnZpZXdDb250YWluZXIsXG4gICAgICAgIHBhcmVudERhdGE/OiBULFxuICAgICkge1xuICAgICAgICBzdXBlci5yZW5kZXJOb2RlQ2hhbmdlcyhkYXRhLCBkYXRhRGlmZmVyLCB2aWV3Q29udGFpbmVyLCBwYXJlbnREYXRhKTtcblxuICAgICAgICBjb25zdCBjaGFuZ2VzID0gZGF0YURpZmZlci5kaWZmKGRhdGEpO1xuXG4gICAgICAgIGlmICghY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoT3BlcmF0aW9uKChpdGVtOiBJdGVyYWJsZUNoYW5nZVJlY29yZDxUPiwgYWRqdXN0ZWRQcmV2aW91c0luZGV4OiBudW1iZXIgfCBudWxsLCBjdXJyZW50SW5kZXg6IG51bWJlciB8IG51bGwpID0+IHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbUExMXlOb2RlVHJhY2tpbmcoYWRqdXN0ZWRQcmV2aW91c0luZGV4IGFzIG51bWJlciwgcGFyZW50RGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0ucHJldmlvdXNJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW92ZUluQTExeU5vZGVUcmFja2luZyhhZGp1c3RlZFByZXZpb3VzSW5kZXggYXMgbnVtYmVyLCBjdXJyZW50SW5kZXgsIHBhcmVudERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb25pdG9yIGZvY3VzIG9mIHRoZSB0cmVlLiBXaGVuIHRoZSB0cmVlIGlzIGZvY3VzZWQsIGNoYW5nZSB0aGUgdGFiIGluZGV4IHRvIC0xIHNvIFRBQlxuICAgICAqIGNhbiBtb3ZlIHRoZSBmb2N1cyBvdXQgb2YgdGhlIHRyZWUuIFdoZW4gdGhlIHRyZWUgaXMgYmx1cnJlZCwgY2hhbmdlIGJhY2sgdGhlIHRhYiBpbmRleC5cbiAgICAgKi9cbiAgICBfbW9uaXRvclRyZWVGb2N1cygpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNNb25pdG9yXG4gICAgICAgICAgICAubW9uaXRvcih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRydWUpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fd3JhcHBlck9uRGVzdHJveSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKG9yaWdpbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VGFiSW5kZXggPSBvcmlnaW4gPyAtMSA6IHRoaXMuX3VzZXJUYWJJbmRleCB8fCAwO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90YWJJbmRleCAhPT0gbmV3VGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFiSW5kZXggPSBuZXdUYWJJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==