import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
export function isString(value) {
    return typeof value === 'string';
}
export function pad(str, length = 2, padCharacter = '0') {
    if (!isString(str) || str.length >= length) {
        return str;
    }
    while (str.length < length) {
        str = padCharacter + str;
    }
    return str;
}
// DATE -> YYYY-MM-DD
export function formatDate(date) {
    const dateOfBirth = [String(date.getFullYear()), pad(String(date.getMonth() + 1)), pad(String(date.getDate()))].join('-');
    return dateOfBirth;
}
export function formatDateHuman(date) {
    const dateOfBirth = [pad(String(date.getDate())), pad(String(date.getMonth() + 1)), String(date.getFullYear())].join('-');
    return dateOfBirth;
}
/*
  Purpose of this function is to allow a list of short keywords
  expand to longer bem class names with will then be applied to the classname value.

  This function will map a list of keys to values in a MAPPING list.
  Whatever value is found will replace the keyword.
  Every keyword not found will just transfered wiithmout modifying.
*/
export function mapClassNames(value, DEFAULTS = [], MAPPING = {}) {
    let sanitizedList = [...DEFAULTS];
    if (typeof value === 'string') {
        const mappedClasses = getClassNameList(value, MAPPING);
        sanitizedList = [...sanitizedList, ...mappedClasses];
    }
    return sanitizedList.join(' ').trim();
}
export function getClassNameList(value, MAPPING = {}) {
    let mappedClasses = [];
    if (typeof value === 'string') {
        const classNames = value.split(' ');
        const keys = Object.keys(MAPPING);
        mappedClasses = classNames.map(className => {
            if (keys.includes(className)) {
                return MAPPING[className];
            }
            return className;
        });
    }
    return mappedClasses;
}
export function appendClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach(item => {
            renderer.addClass(element.nativeElement, item);
        });
    }
}
export function removeClasses(renderer, element, classes) {
    if (renderer && element && classes) {
        classes.split(' ').forEach(item => {
            renderer.removeClass(element.nativeElement, item);
        });
    }
}
// YYYY-MM-DD -> DATE
export function parseDate(dateString) {
    return new Date(dateString);
}
// Manually compose a font shorthand defintion as it's not
// guaranteed to be given by the computed style object.
export function getFontShorthand(style) {
    const { font, fontStyle, fontVariant, fontWeight, fontSize, lineHeight, fontFamily } = style;
    if (font.length > 0) {
        return font;
    }
    return `${fontStyle} ${fontVariant} ${fontWeight} ${fontSize}/${lineHeight} ${fontFamily}`;
}
export function numberOfDecimals(number) {
    const parsed = Number(number);
    if (Number.isNaN(parsed) || Number.isInteger(parsed)) {
        return 0;
    }
    const match = parsed.toString().match(/(?:\.(\d+))?(?:[Ee]([+-]?\d+))?$/);
    if (!match || !match[1]) {
        return 0;
    }
    return match[1].length;
}
export function clamp(value, min = 0, max = 1) {
    return Math.max(min, Math.min(max, value));
}
export function randomString() {
    return Math.random().toString(36);
}
/** Provider that defines when form controls have an error. */
export class ErrorStateMatcher {
    isErrorState(control, form) {
        return !!(control?.invalid && (control.touched || form?.submitted));
    }
}
ErrorStateMatcher.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: ErrorStateMatcher, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
ErrorStateMatcher.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: ErrorStateMatcher, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: ErrorStateMatcher, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL3V0aWxzL3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBYyxVQUFVLEVBQWEsTUFBTSxlQUFlLENBQUM7O0FBR2xFLE1BQU0sVUFBVSxRQUFRLENBQUMsS0FBVTtJQUMvQixPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztBQUNyQyxDQUFDO0FBRUQsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFXLEVBQUUsTUFBTSxHQUFHLENBQUMsRUFBRSxZQUFZLEdBQUcsR0FBRztJQUMzRCxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxNQUFNLElBQUksTUFBTSxFQUFFO1FBQ3hDLE9BQU8sR0FBRyxDQUFDO0tBQ2Q7SUFDRCxPQUFPLEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxFQUFFO1FBQ3hCLEdBQUcsR0FBRyxZQUFZLEdBQUcsR0FBRyxDQUFDO0tBQzVCO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDZixDQUFDO0FBRUQscUJBQXFCO0FBQ3JCLE1BQU0sVUFBVSxVQUFVLENBQUMsSUFBVTtJQUNqQyxNQUFNLFdBQVcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUMsRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUUxSCxPQUFPLFdBQVcsQ0FBQztBQUN2QixDQUFDO0FBQ0QsTUFBTSxVQUFVLGVBQWUsQ0FBQyxJQUFVO0lBQ3RDLE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJ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Q0FBQyxPQUFPLENBQUMsT0FBTyxJQUFJLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7OzhHQUhRLGlCQUFpQjtrSEFBakIsaUJBQWlCLGNBREosTUFBTTsyRkFDbkIsaUJBQWlCO2tCQUQ3QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEluamVjdGFibGUsIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cERpcmVjdGl2ZSwgTmdGb3JtIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWU6IGFueSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFkKHN0cjogc3RyaW5nLCBsZW5ndGggPSAyLCBwYWRDaGFyYWN0ZXIgPSAnMCcpOiBzdHJpbmcge1xuICAgIGlmICghaXNTdHJpbmcoc3RyKSB8fCBzdHIubGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICB3aGlsZSAoc3RyLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICBzdHIgPSBwYWRDaGFyYWN0ZXIgKyBzdHI7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5cbi8vIERBVEUgLT4gWVlZWS1NTS1ERFxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZTogRGF0ZSkge1xuICAgIGNvbnN0IGRhdGVPZkJpcnRoID0gW1N0cmluZyhkYXRlLmdldEZ1bGxZZWFyKCkpLCBwYWQoU3RyaW5nKGRhdGUuZ2V0TW9udGgoKSArIDEpKSwgcGFkKFN0cmluZyhkYXRlLmdldERhdGUoKSkpXS5qb2luKCctJyk7XG5cbiAgICByZXR1cm4gZGF0ZU9mQmlydGg7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZUh1bWFuKGRhdGU6IERhdGUpIHtcbiAgICBjb25zdCBkYXRlT2ZCaXJ0aCA9IFtwYWQoU3RyaW5nKGRhdGUuZ2V0RGF0ZSgpKSksIHBhZChTdHJpbmcoZGF0ZS5nZXRNb250aCgpICsgMSkpLCBTdHJpbmcoZGF0ZS5nZXRGdWxsWWVhcigpKV0uam9pbignLScpO1xuXG4gICAgcmV0dXJuIGRhdGVPZkJpcnRoO1xufVxuLypcbiAgUHVycG9zZSBvZiB0aGlzIGZ1bmN0aW9uIGlzIHRvIGFsbG93IGEgbGlzdCBvZiBzaG9ydCBrZXl3b3Jkc1xuICBleHBhbmQgdG8gbG9uZ2VyIGJlbSBjbGFzcyBuYW1lcyB3aXRoIHdpbGwgdGhlbiBiZSBhcHBsaWVkIHRvIHRoZSBjbGFzc25hbWUgdmFsdWUuXG5cbiAgVGhpcyBmdW5jdGlvbiB3aWxsIG1hcCBhIGxpc3Qgb2Yga2V5cyB0byB2YWx1ZXMgaW4gYSBNQVBQSU5HIGxpc3QuXG4gIFdoYXRldmVyIHZhbHVlIGlzIGZvdW5kIHdpbGwgcmVwbGFjZSB0aGUga2V5d29yZC5cbiAgRXZlcnkga2V5d29yZCBub3QgZm91bmQgd2lsbCBqdXN0IHRyYW5zZmVyZWQgd2lpdGhtb3V0IG1vZGlmeWluZy5cbiovXG5cbmV4cG9ydCBmdW5jdGlvbiBtYXBDbGFzc05hbWVzKHZhbHVlOiBzdHJpbmcsIERFRkFVTFRTOiBzdHJpbmdbXSA9IFtdLCBNQVBQSU5HID0ge30pIHtcbiAgICBsZXQgc2FuaXRpemVkTGlzdDogc3RyaW5nW10gPSBbLi4uREVGQVVMVFNdO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uc3QgbWFwcGVkQ2xhc3NlcyA9IGdldENsYXNzTmFtZUxpc3QodmFsdWUsIE1BUFBJTkcpO1xuICAgICAgICBzYW5pdGl6ZWRMaXN0ID0gWy4uLnNhbml0aXplZExpc3QsIC4uLm1hcHBlZENsYXNzZXNdO1xuICAgIH1cblxuICAgIHJldHVybiBzYW5pdGl6ZWRMaXN0LmpvaW4oJyAnKS50cmltKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc05hbWVMaXN0KHZhbHVlOiBzdHJpbmcsIE1BUFBJTkc6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9ID0ge30pIHtcbiAgICBsZXQgbWFwcGVkQ2xhc3Nlczogc3RyaW5nW10gPSBbXTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzTmFtZXMgPSB2YWx1ZS5zcGxpdCgnICcpO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoTUFQUElORyk7XG5cbiAgICAgICAgbWFwcGVkQ2xhc3NlcyA9IGNsYXNzTmFtZXMubWFwKGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5cy5pbmNsdWRlcyhjbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1BUFBJTkdbY2xhc3NOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWU7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXBwZWRDbGFzc2VzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXBwZW5kQ2xhc3NlcyhyZW5kZXJlcjogUmVuZGVyZXIyLCBlbGVtZW50OiBFbGVtZW50UmVmLCBjbGFzc2VzOiBzdHJpbmcpIHtcbiAgICBpZiAocmVuZGVyZXIgJiYgZWxlbWVudCAmJiBjbGFzc2VzKSB7XG4gICAgICAgIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmVuZGVyZXIuYWRkQ2xhc3MoZWxlbWVudC5uYXRpdmVFbGVtZW50LCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ2xhc3NlcyhyZW5kZXJlcjogUmVuZGVyZXIyLCBlbGVtZW50OiBFbGVtZW50UmVmLCBjbGFzc2VzOiBzdHJpbmcpIHtcbiAgICBpZiAocmVuZGVyZXIgJiYgZWxlbWVudCAmJiBjbGFzc2VzKSB7XG4gICAgICAgIGNsYXNzZXMuc3BsaXQoJyAnKS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgcmVuZGVyZXIucmVtb3ZlQ2xhc3MoZWxlbWVudC5uYXRpdmVFbGVtZW50LCBpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vLyBZWVlZLU1NLUREIC0+IERBVEVcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGUoZGF0ZVN0cmluZzogc3RyaW5nIHwgbnVtYmVyIHwgRGF0ZSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlU3RyaW5nKTtcbn1cblxuLy8gTWFudWFsbHkgY29tcG9zZSBhIGZvbnQgc2hvcnRoYW5kIGRlZmludGlvbiBhcyBpdCdzIG5vdFxuLy8gZ3VhcmFudGVlZCB0byBiZSBnaXZlbiBieSB0aGUgY29tcHV0ZWQgc3R5bGUgb2JqZWN0LlxuZXhwb3J0IGZ1bmN0aW9uIGdldEZvbnRTaG9ydGhhbmQoc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24pIHtcbiAgICBjb25zdCB7IGZvbnQsIGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBsaW5lSGVpZ2h0LCBmb250RmFtaWx5IH0gPSBzdHlsZTtcblxuICAgIGlmIChmb250Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGAke2ZvbnRTdHlsZX0gJHtmb250VmFyaWFudH0gJHtmb250V2VpZ2h0fSAke2ZvbnRTaXplfS8ke2xpbmVIZWlnaHR9ICR7Zm9udEZhbWlseX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyT2ZEZWNpbWFscyhudW1iZXI6IHN0cmluZyB8IG51bWJlcikge1xuICAgIGNvbnN0IHBhcnNlZCA9IE51bWJlcihudW1iZXIpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4ocGFyc2VkKSB8fCBOdW1iZXIuaXNJbnRlZ2VyKHBhcnNlZCkpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoID0gcGFyc2VkLnRvU3RyaW5nKCkubWF0Y2goLyg/OlxcLihcXGQrKSk/KD86W0VlXShbKy1dP1xcZCspKT8kLyk7XG4gICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2hbMV0pIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaFsxXS5sZW5ndGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjbGFtcCh2YWx1ZTogbnVtYmVyLCBtaW4gPSAwLCBtYXggPSAxKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nKCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqIFByb3ZpZGVyIHRoYXQgZGVmaW5lcyB3aGVuIGZvcm0gY29udHJvbHMgaGF2ZSBhbiBlcnJvci4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgRXJyb3JTdGF0ZU1hdGNoZXIge1xuICAgIGlzRXJyb3JTdGF0ZShjb250cm9sOiBGb3JtQ29udHJvbCB8IG51bGwsIGZvcm06IEZvcm1Hcm91cERpcmVjdGl2ZSB8IE5nRm9ybSB8IG51bGwpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICEhKGNvbnRyb2w/LmludmFsaWQgJiYgKGNvbnRyb2wudG91Y2hlZCB8fCBmb3JtPy5zdWJtaXR0ZWQpKTtcbiAgICB9XG59XG4iXX0=