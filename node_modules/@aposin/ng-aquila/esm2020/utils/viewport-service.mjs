import { Injectable } from '@angular/core';
import { asyncScheduler, fromEvent, Subject } from 'rxjs';
import { map, startWith, takeUntil, throttleTime } from 'rxjs/operators';
import * as i0 from "@angular/core";
/** Available breakpoints to subscribe to. */
export var NxBreakpoints;
(function (NxBreakpoints) {
    /** Min size for BREAKPOINT_MOBILE */
    NxBreakpoints[NxBreakpoints["BREAKPOINT_XSMALL"] = 0] = "BREAKPOINT_XSMALL";
    NxBreakpoints[NxBreakpoints["BREAKPOINT_SMALL"] = 320] = "BREAKPOINT_SMALL";
    /** Min size for BREAKPOINT_TABLET */
    NxBreakpoints[NxBreakpoints["BREAKPOINT_MEDIUM"] = 704] = "BREAKPOINT_MEDIUM";
    /** Min size for BREAKPOINT_DESKTOP */
    NxBreakpoints[NxBreakpoints["BREAKPOINT_LARGE"] = 992] = "BREAKPOINT_LARGE";
    NxBreakpoints[NxBreakpoints["BREAKPOINT_XLARGE"] = 1280] = "BREAKPOINT_XLARGE";
    NxBreakpoints[NxBreakpoints["BREAKPOINT_2XLARGE"] = 1472] = "BREAKPOINT_2XLARGE";
    NxBreakpoints[NxBreakpoints["BREAKPOINT_3XLARGE"] = 1760] = "BREAKPOINT_3XLARGE";
})(NxBreakpoints || (NxBreakpoints = {}));
const DEFAULT_THROTTLE_TIME = 200;
/** Service subscribing to window resize events and providing breakpoint matching functions. */
export class NxViewportService {
    constructor() {
        this._destroyed = new Subject();
        this.initialViewportWidth = 0;
        this.viewportChange$ = fromEvent(window, 'resize').pipe(map(() => window.innerWidth), takeUntil(this._destroyed));
    }
    /** Returns whether the current viewport width is greater than or equal (>=) to minSize. */
    min(minSize, throttleTimeMs = DEFAULT_THROTTLE_TIME) {
        return this.viewportChange$.pipe(startWith(window.innerWidth), throttleTime(throttleTimeMs, asyncScheduler, { trailing: true }), map(windowInnerWidth => windowInnerWidth >= minSize));
    }
    /** Returns whether the current viewport width is lower (<) than maxSize. */
    max(maxSize, throttleTimeMs = DEFAULT_THROTTLE_TIME) {
        return this.viewportChange$.pipe(startWith(window.innerWidth), throttleTime(throttleTimeMs, asyncScheduler, { trailing: true }), map(windowInnerWidth => windowInnerWidth < maxSize));
    }
    /** Returns whether the current viewport width is greater than or equal (>=) to minSize and lower (<) than maxSize. */
    between(minSize, maxSize, throttleTimeMs = DEFAULT_THROTTLE_TIME) {
        return this.viewportChange$.pipe(startWith(window.innerWidth), throttleTime(throttleTimeMs, asyncScheduler, { trailing: true }), map(windowInnerWidth => windowInnerWidth >= minSize && windowInnerWidth < maxSize));
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
}
NxViewportService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxViewportService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
NxViewportService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxViewportService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxViewportService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return []; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmlld3BvcnQtc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWFxdWlsYS9zcmMvdXRpbHMvdmlld3BvcnQtc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQUUsU0FBUyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RSxPQUFPLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7O0FBRXpFLDZDQUE2QztBQUM3QyxNQUFNLENBQU4sSUFBWSxhQVdYO0FBWEQsV0FBWSxhQUFhO0lBQ3JCLHFDQUFxQztJQUNyQywyRUFBcUIsQ0FBQTtJQUNyQiwyRUFBc0IsQ0FBQTtJQUN0QixxQ0FBcUM7SUFDckMsNkVBQXVCLENBQUE7SUFDdkIsc0NBQXNDO0lBQ3RDLDJFQUFzQixDQUFBO0lBQ3RCLDhFQUF3QixDQUFBO0lBQ3hCLGdGQUF5QixDQUFBO0lBQ3pCLGdGQUF5QixDQUFBO0FBQzdCLENBQUMsRUFYVyxhQUFhLEtBQWIsYUFBYSxRQVd4QjtBQUVELE1BQU0scUJBQXFCLEdBQUcsR0FBRyxDQUFDO0FBRWxDLCtGQUErRjtBQUUvRixNQUFNLE9BQU8saUJBQWlCO0lBSzFCO1FBSlEsZUFBVSxHQUFrQixJQUFJLE9BQU8sRUFBRSxDQUFDO1FBQ2xELHlCQUFvQixHQUFHLENBQUMsQ0FBQztRQUlyQixJQUFJLENBQUMsZUFBZSxHQUFHLFNBQVMsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUNuRCxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxFQUM1QixTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUM3QixDQUFDO0lBQ04sQ0FBQztJQUVELDJGQUEyRjtJQUMzRixHQUFHLENBQUMsT0FBc0IsRUFBRSxjQUFjLEdBQUcscUJBQXFCO1FBQzlELE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQzVCLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQzVCLFlBQVksQ0FBQyxjQUFjLEVBQUUsY0FBYyxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLEVBQ2hFLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLElBQUksT0FBTyxDQUFDLENBQ3ZELENBQUM7SUFDTixDQUFDO0lBRUQsNEVBQTRFO0lBQzVFLEdBQUcsQ0FBQyxPQUFzQixFQUFFLGNBQWMsR0FBRyxxQkFBcUI7UUFDOUQsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FDNUIsU0FBUyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsRUFDNUIsWUFBWSxDQUFDLGNBQWMsRUFBRSxjQUFjLEVBQUUsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFDaEUsR0FBRyxDQUFDLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsQ0FDdEQsQ0FBQztJQUNOLENBQUM7SUFFRCxzSEFBc0g7SUFDdEgsT0FBTyxDQUFDLE9BQXNCLEVBQUUsT0FBc0IsRUFBRSxjQUFjLEdBQUcscUJBQXFCO1FBQzFGLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQzVCLFNBQVMsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLEVBQzVCLFlBQVksQ0FBQyxjQUFjLEVBQUUsY0FBYyxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLEVBQ2hFLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLENBQUMsZ0JBQWdCLElBQUksT0FBTyxJQUFJLGdCQUFnQixHQUFHLE9BQU8sQ0FBQyxDQUNyRixDQUFDO0lBQ04sQ0FBQztJQUVELFdBQVc7UUFDUCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3ZCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDL0IsQ0FBQzs7OEdBMUNRLGlCQUFpQjtrSEFBakIsaUJBQWlCLGNBREosTUFBTTsyRkFDbkIsaUJBQWlCO2tCQUQ3QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgYXN5bmNTY2hlZHVsZXIsIGZyb21FdmVudCwgT2JzZXJ2YWJsZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgbWFwLCBzdGFydFdpdGgsIHRha2VVbnRpbCwgdGhyb3R0bGVUaW1lIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKiogQXZhaWxhYmxlIGJyZWFrcG9pbnRzIHRvIHN1YnNjcmliZSB0by4gKi9cbmV4cG9ydCBlbnVtIE54QnJlYWtwb2ludHMge1xuICAgIC8qKiBNaW4gc2l6ZSBmb3IgQlJFQUtQT0lOVF9NT0JJTEUgKi9cbiAgICBCUkVBS1BPSU5UX1hTTUFMTCA9IDAsXG4gICAgQlJFQUtQT0lOVF9TTUFMTCA9IDMyMCxcbiAgICAvKiogTWluIHNpemUgZm9yIEJSRUFLUE9JTlRfVEFCTEVUICovXG4gICAgQlJFQUtQT0lOVF9NRURJVU0gPSA3MDQsXG4gICAgLyoqIE1pbiBzaXplIGZvciBCUkVBS1BPSU5UX0RFU0tUT1AgKi9cbiAgICBCUkVBS1BPSU5UX0xBUkdFID0gOTkyLFxuICAgIEJSRUFLUE9JTlRfWExBUkdFID0gMTI4MCxcbiAgICBCUkVBS1BPSU5UXzJYTEFSR0UgPSAxNDcyLFxuICAgIEJSRUFLUE9JTlRfM1hMQVJHRSA9IDE3NjAsXG59XG5cbmNvbnN0IERFRkFVTFRfVEhST1RUTEVfVElNRSA9IDIwMDtcblxuLyoqIFNlcnZpY2Ugc3Vic2NyaWJpbmcgdG8gd2luZG93IHJlc2l6ZSBldmVudHMgYW5kIHByb3ZpZGluZyBicmVha3BvaW50IG1hdGNoaW5nIGZ1bmN0aW9ucy4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgTnhWaWV3cG9ydFNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX2Rlc3Ryb3llZDogU3ViamVjdDx2b2lkPiA9IG5ldyBTdWJqZWN0KCk7XG4gICAgaW5pdGlhbFZpZXdwb3J0V2lkdGggPSAwO1xuICAgIHZpZXdwb3J0Q2hhbmdlJDogT2JzZXJ2YWJsZTxudW1iZXI+O1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmlld3BvcnRDaGFuZ2UkID0gZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLnBpcGUoXG4gICAgICAgICAgICBtYXAoKCkgPT4gd2luZG93LmlubmVyV2lkdGgpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCB2aWV3cG9ydCB3aWR0aCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgKD49KSB0byBtaW5TaXplLiAqL1xuICAgIG1pbihtaW5TaXplOiBOeEJyZWFrcG9pbnRzLCB0aHJvdHRsZVRpbWVNcyA9IERFRkFVTFRfVEhST1RUTEVfVElNRSk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydENoYW5nZSQucGlwZShcbiAgICAgICAgICAgIHN0YXJ0V2l0aCh3aW5kb3cuaW5uZXJXaWR0aCksXG4gICAgICAgICAgICB0aHJvdHRsZVRpbWUodGhyb3R0bGVUaW1lTXMsIGFzeW5jU2NoZWR1bGVyLCB7IHRyYWlsaW5nOiB0cnVlIH0pLFxuICAgICAgICAgICAgbWFwKHdpbmRvd0lubmVyV2lkdGggPT4gd2luZG93SW5uZXJXaWR0aCA+PSBtaW5TaXplKSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHZpZXdwb3J0IHdpZHRoIGlzIGxvd2VyICg8KSB0aGFuIG1heFNpemUuICovXG4gICAgbWF4KG1heFNpemU6IE54QnJlYWtwb2ludHMsIHRocm90dGxlVGltZU1zID0gREVGQVVMVF9USFJPVFRMRV9USU1FKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0Q2hhbmdlJC5waXBlKFxuICAgICAgICAgICAgc3RhcnRXaXRoKHdpbmRvdy5pbm5lcldpZHRoKSxcbiAgICAgICAgICAgIHRocm90dGxlVGltZSh0aHJvdHRsZVRpbWVNcywgYXN5bmNTY2hlZHVsZXIsIHsgdHJhaWxpbmc6IHRydWUgfSksXG4gICAgICAgICAgICBtYXAod2luZG93SW5uZXJXaWR0aCA9PiB3aW5kb3dJbm5lcldpZHRoIDwgbWF4U2l6ZSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCB2aWV3cG9ydCB3aWR0aCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgKD49KSB0byBtaW5TaXplIGFuZCBsb3dlciAoPCkgdGhhbiBtYXhTaXplLiAqL1xuICAgIGJldHdlZW4obWluU2l6ZTogTnhCcmVha3BvaW50cywgbWF4U2l6ZTogTnhCcmVha3BvaW50cywgdGhyb3R0bGVUaW1lTXMgPSBERUZBVUxUX1RIUk9UVExFX1RJTUUpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3BvcnRDaGFuZ2UkLnBpcGUoXG4gICAgICAgICAgICBzdGFydFdpdGgod2luZG93LmlubmVyV2lkdGgpLFxuICAgICAgICAgICAgdGhyb3R0bGVUaW1lKHRocm90dGxlVGltZU1zLCBhc3luY1NjaGVkdWxlciwgeyB0cmFpbGluZzogdHJ1ZSB9KSxcbiAgICAgICAgICAgIG1hcCh3aW5kb3dJbm5lcldpZHRoID0+IHdpbmRvd0lubmVyV2lkdGggPj0gbWluU2l6ZSAmJiB3aW5kb3dJbm5lcldpZHRoIDwgbWF4U2l6ZSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIH1cbn1cbiJdfQ==