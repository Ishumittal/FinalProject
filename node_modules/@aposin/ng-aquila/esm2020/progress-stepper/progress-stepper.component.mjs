import { CdkStep, CdkStepper } from '@angular/cdk/stepper';
import { ChangeDetectionStrategy, Component, ContentChildren, Directive, forwardRef, Inject, Input, Optional, QueryList, SkipSelf, } from '@angular/core';
import { ErrorStateMatcher } from '@aposin/ng-aquila/utils';
import { Subject } from 'rxjs';
import { takeUntil, takeWhile } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@aposin/ng-aquila/utils";
import * as i2 from "@angular/cdk/bidi";
// We need to reference steps in stepper and stepper in steps. To prevent circular depenedency errors
// Provide both components in a single file. Otherwise we would have to introduce interface/abstract classes
// shared between both implementations.
export class NxStepComponent extends CdkStep {
    constructor(stepper, _errorStateMatcher) {
        super(stepper);
        this.stepper = stepper;
        this._errorStateMatcher = _errorStateMatcher;
        this._destroyed = new Subject();
        this.interacted = false;
    }
    /** Custom error state matcher that checks for validity of the step form. */
    isErrorState(control, form) {
        const originalErrorState = this._errorStateMatcher.isErrorState(control, form);
        // Checks for the validity of a step form that is not submitted or touched,
        // e.g when the user directly clicks the "next" button or directly on the step
        const customErrorState = !!(control?.invalid && this.interacted);
        return originalErrorState || customErrorState;
    }
    ngOnChanges() {
        // We can't use the `changes: SimpleChanges` as a parameter here
        // because CdkStep only defines the ngOnChanges() method.
        super.ngOnChanges();
        if (this.stepControl !== this._stepControl) {
            this._stepControl = this.stepControl;
            // If a step control changes its state, the stepper needs to update.
            if (this._stepControl) {
                this._stepControl.statusChanges
                    .pipe(takeWhile(() => this._stepControl === this.stepControl), takeUntil(this._destroyed))
                    .subscribe(() => {
                    this.stepper._stateChanged();
                });
            }
        }
        if (this.interacted !== this._interacted) {
            this._interacted = this.interacted;
            if (this.stepper) {
                this.stepper._stateChanged();
            }
        }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
}
NxStepComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxStepComponent, deps: [{ token: forwardRef(() => NxProgressStepperDirective) }, { token: i1.ErrorStateMatcher, skipSelf: true }], target: i0.ɵɵFactoryTarget.Component });
NxStepComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxStepComponent, selector: "nx-step", providers: [{ provide: ErrorStateMatcher, useExisting: NxStepComponent }], exportAs: ["nxStep"], usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<ng-template><ng-content></ng-content></ng-template>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxStepComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-step', exportAs: 'nxStep', providers: [{ provide: ErrorStateMatcher, useExisting: NxStepComponent }], changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-template><ng-content></ng-content></ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: NxProgressStepperDirective, decorators: [{
                    type: Inject,
                    args: [forwardRef(() => NxProgressStepperDirective)]
                }] }, { type: i1.ErrorStateMatcher, decorators: [{
                    type: SkipSelf
                }] }]; } });
/** @docs-private */
export class NxProgressStepperDirective extends CdkStepper {
    constructor(_cdr, _dir, _elementRef) {
        super(_dir, _cdr, _elementRef, null);
        this._cdr = _cdr;
        /** Steps that belong to the current stepper, excluding ones from nested steppers. */
        this.steps = new QueryList();
        this._stepHeader = new QueryList();
    }
    ngAfterContentInit() {
        super.ngAfterContentInit();
        // Mark the component for change detection whenever the content children query changes
        this.steps.changes.pipe(takeUntil(this._destroyed)).subscribe(() => {
            this._stateChanged();
        });
        // If a step control changes its state, the stepper needs to update.
        this.steps
            .filter(s => !!s.stepControl)
            .forEach(step => {
            step.stepControl.statusChanges.pipe(takeUntil(step._destroyed)).subscribe(() => {
                this._stateChanged();
            });
        });
        // we need to defer change detection that the nxStepperNext and NxStepperPrevious buttons
        // can run change detection again, because they are initialized before the stepper content
        Promise.resolve().then(() => {
            this._cdr.detectChanges();
        });
    }
    /** @docs-private */
    get hasPrevious() {
        return this.selectedIndex - 1 >= 0;
    }
    /** @docs-private */
    get hasNext() {
        return this.selectedIndex + 1 < this.count;
    }
    /** @docs-private */
    get count() {
        return this.steps ? this.steps.length : 0;
    }
    /** @docs-private */
    get currentStep() {
        if (this.count === 0 || this.selectedIndex === -1 || !this.steps) {
            return null;
        }
        const steps = this.steps.toArray();
        return steps[this.selectedIndex];
    }
    /** @docs-private */
    get nextStep() {
        if (this.selectedIndex + 1 >= this.steps.length) {
            return null;
        }
        return this.steps.toArray()[this.selectedIndex + 1];
    }
    /** @docs-private */
    get currentLabel() {
        const step = this.currentStep;
        if (!step) {
            return '';
        }
        const label = step.stepLabel || step.label;
        return this.currentStepLabel && label ? `${this.currentStepLabel} ${this.selectedIndex + 1}/${this.count}: ${label}` : '';
    }
}
NxProgressStepperDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxProgressStepperDirective, deps: [{ token: i0.ChangeDetectorRef }, { token: i2.Directionality, optional: true }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NxProgressStepperDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxProgressStepperDirective, selector: "[nxProgressStepper]", inputs: { currentStepLabel: "currentStepLabel" }, queries: [{ propertyName: "_steps", predicate: NxStepComponent, descendants: true }], exportAs: ["nxProgressStepper"], usesInheritance: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxProgressStepperDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxProgressStepper]',
                    exportAs: 'nxProgressStepper',
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i2.Directionality, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef }]; }, propDecorators: { _steps: [{
                type: ContentChildren,
                args: [NxStepComponent, { descendants: true }]
            }], currentStepLabel: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL3Byb2dyZXNzLXN0ZXBwZXIvcHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL3Byb2dyZXNzLXN0ZXBwZXIvcHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsT0FBTyxFQUFpQixVQUFVLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRSxPQUFPLEVBRUgsdUJBQXVCLEVBRXZCLFNBQVMsRUFDVCxlQUFlLEVBQ2YsU0FBUyxFQUVULFVBQVUsRUFDVixNQUFNLEVBQ04sS0FBSyxFQUdMLFFBQVEsRUFDUixTQUFTLEVBQ1QsUUFBUSxHQUNYLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQzVELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUV0RCxxR0FBcUc7QUFDckcsNEdBQTRHO0FBQzVHLHVDQUF1QztBQVN2QyxNQUFNLE9BQU8sZUFBZ0IsU0FBUSxPQUFPO0lBQ3hDLFlBQ2lFLE9BQW1DLEVBQzVFLGtCQUFxQztRQUV6RCxLQUFLLENBQUMsT0FBcUIsQ0FBQyxDQUFDO1FBSGdDLFlBQU8sR0FBUCxPQUFPLENBQTRCO1FBQzVFLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBbUI7UUFjcEQsZUFBVSxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFWdEMsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7SUFDNUIsQ0FBQztJQVdELDRFQUE0RTtJQUM1RSxZQUFZ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UUFBUTtxRUFWRyxNQUFNO3NCQUE5RCxlQUFlO3VCQUFDLGVBQWUsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUU7Z0JBUTlDLGdCQUFnQjtzQkFBeEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgQ2RrU3RlcCwgQ2RrU3RlcEhlYWRlciwgQ2RrU3RlcHBlciB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9zdGVwcGVyJztcbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT3B0aW9uYWwsXG4gICAgUXVlcnlMaXN0LFxuICAgIFNraXBTZWxmLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBGb3JtR3JvdXBEaXJlY3RpdmUsIE5nRm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEVycm9yU3RhdGVNYXRjaGVyIH0gZnJvbSAnQGFwb3Npbi9uZy1hcXVpbGEvdXRpbHMnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsLCB0YWtlV2hpbGUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbi8vIFdlIG5lZWQgdG8gcmVmZXJlbmNlIHN0ZXBzIGluIHN0ZXBwZXIgYW5kIHN0ZXBwZXIgaW4gc3RlcHMuIFRvIHByZXZlbnQgY2lyY3VsYXIgZGVwZW5lZGVuY3kgZXJyb3JzXG4vLyBQcm92aWRlIGJvdGggY29tcG9uZW50cyBpbiBhIHNpbmdsZSBmaWxlLiBPdGhlcndpc2Ugd2Ugd291bGQgaGF2ZSB0byBpbnRyb2R1Y2UgaW50ZXJmYWNlL2Fic3RyYWN0IGNsYXNzZXNcbi8vIHNoYXJlZCBiZXR3ZWVuIGJvdGggaW1wbGVtZW50YXRpb25zLlxuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ254LXN0ZXAnLFxuICAgIHRlbXBsYXRlVXJsOiAncHJvZ3Jlc3Mtc3RlcHBlci5jb21wb25lbnQuaHRtbCcsXG4gICAgZXhwb3J0QXM6ICdueFN0ZXAnLFxuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogRXJyb3JTdGF0ZU1hdGNoZXIsIHVzZUV4aXN0aW5nOiBOeFN0ZXBDb21wb25lbnQgfV0sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIE54U3RlcENvbXBvbmVudCBleHRlbmRzIENka1N0ZXAgaW1wbGVtZW50cyBFcnJvclN0YXRlTWF0Y2hlciwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmUpKSBwdWJsaWMgc3RlcHBlcjogTnhQcm9ncmVzc1N0ZXBwZXJEaXJlY3RpdmUsXG4gICAgICAgIEBTa2lwU2VsZigpIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcixcbiAgICApIHtcbiAgICAgICAgc3VwZXIoc3RlcHBlciBhcyBDZGtTdGVwcGVyKTtcblxuICAgICAgICB0aGlzLmludGVyYWN0ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zdGVwQ29udHJvbDogYW55O1xuXG4gICAgLyoqIFRoZSB0b3AgbGV2ZWwgYWJzdHJhY3QgY29udHJvbCBvZiB0aGUgc3RlcC4gKi9cbiAgICBzdGVwQ29udHJvbDogYW55O1xuXG4gICAgcHJpdmF0ZSBfaW50ZXJhY3RlZCE6IGJvb2xlYW47XG5cbiAgICByZWFkb25seSBfZGVzdHJveWVkID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcblxuICAgIC8qKiBDdXN0b20gZXJyb3Igc3RhdGUgbWF0Y2hlciB0aGF0IGNoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHN0ZXAgZm9ybS4gKi9cbiAgICBpc0Vycm9yU3RhdGUoY29udHJvbDogRm9ybUNvbnRyb2wgfCBudWxsLCBmb3JtOiBGb3JtR3JvdXBEaXJlY3RpdmUgfCBOZ0Zvcm0gfCBudWxsKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRXJyb3JTdGF0ZSA9IHRoaXMuX2Vycm9yU3RhdGVNYXRjaGVyLmlzRXJyb3JTdGF0ZShjb250cm9sLCBmb3JtKTtcblxuICAgICAgICAvLyBDaGVja3MgZm9yIHRoZSB2YWxpZGl0eSBvZiBhIHN0ZXAgZm9ybSB0aGF0IGlzIG5vdCBzdWJtaXR0ZWQgb3IgdG91Y2hlZCxcbiAgICAgICAgLy8gZS5nIHdoZW4gdGhlIHVzZXIgZGlyZWN0bHkgY2xpY2tzIHRoZSBcIm5leHRcIiBidXR0b24gb3IgZGlyZWN0bHkgb24gdGhlIHN0ZXBcbiAgICAgICAgY29uc3QgY3VzdG9tRXJyb3JTdGF0ZSA9ICEhKGNvbnRyb2w/LmludmFsaWQgJiYgdGhpcy5pbnRlcmFjdGVkKTtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsRXJyb3JTdGF0ZSB8fCBjdXN0b21FcnJvclN0YXRlO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICAvLyBXZSBjYW4ndCB1c2UgdGhlIGBjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzYCBhcyBhIHBhcmFtZXRlciBoZXJlXG4gICAgICAgIC8vIGJlY2F1c2UgQ2RrU3RlcCBvbmx5IGRlZmluZXMgdGhlIG5nT25DaGFuZ2VzKCkgbWV0aG9kLlxuICAgICAgICBzdXBlci5uZ09uQ2hhbmdlcygpO1xuXG4gICAgICAgIGlmICh0aGlzLnN0ZXBDb250cm9sICE9PSB0aGlzLl9zdGVwQ29udHJvbCkge1xuICAgICAgICAgICAgdGhpcy5fc3RlcENvbnRyb2wgPSB0aGlzLnN0ZXBDb250cm9sO1xuXG4gICAgICAgICAgICAvLyBJZiBhIHN0ZXAgY29udHJvbCBjaGFuZ2VzIGl0cyBzdGF0ZSwgdGhlIHN0ZXBwZXIgbmVlZHMgdG8gdXBkYXRlLlxuICAgICAgICAgICAgaWYgKHRoaXMuX3N0ZXBDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RlcENvbnRyb2wuc3RhdHVzQ2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VXaGlsZSgoKSA9PiB0aGlzLl9zdGVwQ29udHJvbCA9PT0gdGhpcy5zdGVwQ29udHJvbCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSxcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlcHBlci5fc3RhdGVDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaW50ZXJhY3RlZCAhPT0gdGhpcy5faW50ZXJhY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5faW50ZXJhY3RlZCA9IHRoaXMuaW50ZXJhY3RlZDtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZXBwZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBwZXIuX3N0YXRlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIH1cbn1cblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW254UHJvZ3Jlc3NTdGVwcGVyXScsXG4gICAgZXhwb3J0QXM6ICdueFByb2dyZXNzU3RlcHBlcicsXG59KVxuZXhwb3J0IGNsYXNzIE54UHJvZ3Jlc3NTdGVwcGVyRGlyZWN0aXZlIGV4dGVuZHMgQ2RrU3RlcHBlciBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAgIC8vIERvIG5vdCBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgUXVlcnlMaXN0IG9yIHRoZSBoYXNOZXh0KCkgZnVuY3Rpb24gcHJvZHVjZXNcbiAgICAvLyB3cm9uZyByZXN1bHRzIG9uIGluaXRcbiAgICAvKiogRnVsbCBsaXN0IG9mIHN0ZXBzIGluc2lkZSB0aGUgc3RlcHBlciwgaW5jbHVkaW5nIGluc2lkZSBuZXN0ZWQgc3RlcHBlcnMgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKE54U3RlcENvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSBfc3RlcHMhOiBRdWVyeUxpc3Q8TnhTdGVwQ29tcG9uZW50PjtcblxuICAgIC8qKiBTdGVwcyB0aGF0IGJlbG9uZyB0byB0aGUgY3VycmVudCBzdGVwcGVyLCBleGNsdWRpbmcgb25lcyBmcm9tIG5lc3RlZCBzdGVwcGVycy4gKi9cbiAgICByZWFkb25seSBzdGVwczogUXVlcnlMaXN0PE54U3RlcENvbXBvbmVudD4gPSBuZXcgUXVlcnlMaXN0PE54U3RlcENvbXBvbmVudD4oKTtcblxuICAgIF9zdGVwSGVhZGVyOiBRdWVyeUxpc3Q8Q2RrU3RlcEhlYWRlcj4gPSBuZXcgUXVlcnlMaXN0KCk7XG5cbiAgICAvKiogU2V0cyB0aGUgbGFiZWwgb24gdGhlIGxlZnQgc2lkZSBzaG93aW5nIHRoZSBjdXJyZW50IHN0ZXAgbGFiZWwuIFVzZWQgZm9yIG1vYmlsZSB2aWV3cG9ydHMuICovXG4gICAgQElucHV0KCkgY3VycmVudFN0ZXBMYWJlbCE6IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsIEBPcHRpb25hbCgpIF9kaXI6IERpcmVjdGlvbmFsaXR5IHwgbnVsbCwgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+KSB7XG4gICAgICAgIHN1cGVyKF9kaXIhLCBfY2RyLCBfZWxlbWVudFJlZiwgbnVsbCk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICAgICAgLy8gTWFyayB0aGUgY29tcG9uZW50IGZvciBjaGFuZ2UgZGV0ZWN0aW9uIHdoZW5ldmVyIHRoZSBjb250ZW50IGNoaWxkcmVuIHF1ZXJ5IGNoYW5nZXNcbiAgICAgICAgdGhpcy5zdGVwcy5jaGFuZ2VzLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gSWYgYSBzdGVwIGNvbnRyb2wgY2hhbmdlcyBpdHMgc3RhdGUsIHRoZSBzdGVwcGVyIG5lZWRzIHRvIHVwZGF0ZS5cbiAgICAgICAgdGhpcy5zdGVwc1xuICAgICAgICAgICAgLmZpbHRlcihzID0+ICEhcy5zdGVwQ29udHJvbClcbiAgICAgICAgICAgIC5mb3JFYWNoKHN0ZXAgPT4ge1xuICAgICAgICAgICAgICAgIHN0ZXAuc3RlcENvbnRyb2wuc3RhdHVzQ2hhbmdlcy5waXBlKHRha2VVbnRpbChzdGVwLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGVmZXIgY2hhbmdlIGRldGVjdGlvbiB0aGF0IHRoZSBueFN0ZXBwZXJOZXh0IGFuZCBOeFN0ZXBwZXJQcmV2aW91cyBidXR0b25zXG4gICAgICAgIC8vIGNhbiBydW4gY2hhbmdlIGRldGVjdGlvbiBhZ2FpbiwgYmVjYXVzZSB0aGV5IGFyZSBpbml0aWFsaXplZCBiZWZvcmUgdGhlIHN0ZXBwZXIgY29udGVudFxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2Nkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGhhc1ByZXZpb3VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4IC0gMSA+PSAwO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGhhc05leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXggKyAxIDwgdGhpcy5jb3VudDtcbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGdldCBjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMgPyB0aGlzLnN0ZXBzLmxlbmd0aCA6IDA7XG4gICAgfVxuXG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBnZXQgY3VycmVudFN0ZXAoKTogTnhTdGVwQ29tcG9uZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICh0aGlzLmNvdW50ID09PSAwIHx8IHRoaXMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgfHwgIXRoaXMuc3RlcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc3RlcHMgPSB0aGlzLnN0ZXBzLnRvQXJyYXkoKTtcbiAgICAgICAgcmV0dXJuIHN0ZXBzW3RoaXMuc2VsZWN0ZWRJbmRleF07XG4gICAgfVxuXG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBnZXQgbmV4dFN0ZXAoKTogTnhTdGVwQ29tcG9uZW50IHwgbnVsbCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggKyAxID49IHRoaXMuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLnRvQXJyYXkoKVt0aGlzLnNlbGVjdGVkSW5kZXggKyAxXTtcbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGdldCBjdXJyZW50TGFiZWwoKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmN1cnJlbnRTdGVwO1xuICAgICAgICBpZiAoIXN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhYmVsID0gc3RlcC5zdGVwTGFiZWwgfHwgc3RlcC5sYWJlbDtcblxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RlcExhYmVsICYmIGxhYmVsID8gYCR7dGhpcy5jdXJyZW50U3RlcExhYmVsfSAke3RoaXMuc2VsZWN0ZWRJbmRleCArIDF9LyR7dGhpcy5jb3VudH06ICR7bGFiZWx9YCA6ICcnO1xuICAgIH1cbn1cbiIsIjxuZy10ZW1wbGF0ZT48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy10ZW1wbGF0ZT5cbiJdfQ==