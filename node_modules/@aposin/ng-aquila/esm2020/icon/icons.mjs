import { SecurityContext } from '@angular/core';
import { of } from 'rxjs';
import { finalize, map, share } from 'rxjs/operators';
export class NxSvgIcon {
    constructor(_httpClient, _sanitizer, _document) {
        this._httpClient = _httpClient;
        this._sanitizer = _sanitizer;
        this._document = _document;
    }
    /** Returns the content. */
    getContent() {
        return of(this.svgElement);
    }
    _svgElementFromString(str) {
        const div = this._document.createElement('DIV');
        div.innerHTML = str;
        const svg = div.querySelector('svg');
        if (!svg) {
            throw Error('<svg> tag not found');
        }
        return svg;
    }
}
export class NxSvgIconLiteral extends NxSvgIcon {
    constructor(data, _httpClient, _sanitizer, _document) {
        super(_httpClient, _sanitizer, _document);
        const sanitizedLiteral = this._sanitizer.sanitize(SecurityContext.HTML, data);
        if (!sanitizedLiteral) {
            throw Error(`The literal provided to NxIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${data}".`);
        }
        this.svgElement = this._svgElementFromString(sanitizedLiteral);
    }
}
export class NxSvgIconFromUrl extends NxSvgIcon {
    constructor(safeUrl, _httpClient, _sanitizer, _document) {
        super(_httpClient, _sanitizer, _document);
        this._sanitizer = _sanitizer;
        this._document = _document;
        this.url = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
        if (!this.url) {
            throw Error(`The URL provided to NxIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${safeUrl}".`);
        }
        if (!_httpClient) {
            throw Error('Could not find HttpClient provider for using a SVG url in the nx-icon registry. ' +
                'Please include the HttpClientModule from @angular/common/http in your app imports.');
        }
        this._httpClient = _httpClient;
    }
    /** Returns the content. If the SVG is not already loaded it fetches the SVG from icons' URL */
    getContent() {
        return this._loadSvgIcon();
    }
    _loadSvgIcon() {
        // If the SVG for this icon has already been parsed, do nothing.
        if (this.svgElement) {
            return of(this.svgElement);
        }
        return this._fetchUrl(this.url).pipe(map(svgText => {
            // It is possible that the icon was parsed and cached by an earlier request, so parsing
            // only needs to occur if the cache is yet unset.
            if (!this.svgElement) {
                this.svgElement = this._svgElementFromString(svgText);
            }
            return this.svgElement;
        }));
    }
    /**
     * Returns an Observable which produces the string contents of the given URL. Results may be
     * cached, so future calls with the same URL may not cause another HTTP request.
     */
    _fetchUrl(url) {
        // Store in-progress fetches to avoid sending a duplicate request for a URL when there is
        // already a request in progress for that URL. It's necessary to call share() on the
        // Observable returned by http.get() so that multiple subscribers don't cause multiple XHRs.
        if (this._pendingRequest) {
            return this._pendingRequest;
        }
        const req = this._httpClient.get(url, { responseType: 'text' }).pipe(finalize(() => {
            this._pendingRequest = undefined;
        }), share());
        this._pendingRequest = req;
        return req;
    }
}
export class NxFontIcon {
    constructor(alias, font) {
        this.alias = alias;
        this.font = font;
    }
    getClasses() {
        return { alias: this.alias, font: this.font };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaWNvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL2ljb24vaWNvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVoRCxPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSXRELE1BQU0sT0FBTyxTQUFTO0lBR2xCLFlBQXNCLFdBQThCLEVBQVksVUFBd0IsRUFBWSxTQUFtQjtRQUFqRyxnQkFBVyxHQUFYLFdBQVcsQ0FBbUI7UUFBWSxlQUFVLEdBQVYsVUFBVSxDQUFjO1FBQVksY0FBUyxHQUFULFNBQVMsQ0FBVTtJQUFHLENBQUM7SUFFM0gsMkJBQTJCO0lBQzNCLFVBQVU7UUFDTixPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDL0IsQ0FBQztJQUVTLHFCQUFxQixDQUFDLEdBQVc7UUFDdkMsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDaEQsR0FBRyxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUM7UUFDcEIsTUFBTSxHQUFHLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQWUsQ0FBQztRQUVuRCxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ04sTUFBTSxLQUFLLENBQUMscUJBQXFCLENBQUMsQ0FBQztTQUN0QztRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztDQUNKO0FBRUQsTUFBTSxPQUFPLGdCQUFpQixTQUFRLFNBQVM7SUFDM0MsWUFBWSxJQUFjLEVBQUUsV0FBOEIsRUFBRSxVQUF3QixFQUFFLFNBQW1CO1FBQ3JHLEtBQUssQ0FBQyxXQUFXLEVBQUUsVUFB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RUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ2xELENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0dHBDbGllbnQgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5pbXBvcnQgeyBTZWN1cml0eUNvbnRleHQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERvbVNhbml0aXplciwgU2FmZUh0bWwsIFNhZmVSZXNvdXJjZVVybCB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGZpbmFsaXplLCBtYXAsIHNoYXJlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBOeEljb25Gb250RGVmaW5pdGlvbiB9IGZyb20gJy4vaWNvbi1yZWdpc3RyeSc7XG5cbmV4cG9ydCBjbGFzcyBOeFN2Z0ljb24ge1xuICAgIHN2Z0VsZW1lbnQ6IFNWR0VsZW1lbnQgfCB1bmRlZmluZWQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX2h0dHBDbGllbnQ6IEh0dHBDbGllbnQgfCBudWxsLCBwcm90ZWN0ZWQgX3Nhbml0aXplcjogRG9tU2FuaXRpemVyLCBwcm90ZWN0ZWQgX2RvY3VtZW50OiBEb2N1bWVudCkge31cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBjb250ZW50LiAqL1xuICAgIGdldENvbnRlbnQoKTogT2JzZXJ2YWJsZTxTVkdFbGVtZW50IHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIHJldHVybiBvZih0aGlzLnN2Z0VsZW1lbnQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfc3ZnRWxlbWVudEZyb21TdHJpbmcoc3RyOiBzdHJpbmcpOiBTVkdFbGVtZW50IHtcbiAgICAgICAgY29uc3QgZGl2ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSBzdHI7XG4gICAgICAgIGNvbnN0IHN2ZyA9IGRpdi5xdWVyeVNlbGVjdG9yKCdzdmcnKSBhcyBTVkdFbGVtZW50O1xuXG4gICAgICAgIGlmICghc3ZnKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignPHN2Zz4gdGFnIG5vdCBmb3VuZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBOeFN2Z0ljb25MaXRlcmFsIGV4dGVuZHMgTnhTdmdJY29uIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhOiBTYWZlSHRtbCwgX2h0dHBDbGllbnQ6IEh0dHBDbGllbnQgfCBudWxsLCBfc2FuaXRpemVyOiBEb21TYW5pdGl6ZXIsIF9kb2N1bWVudDogRG9jdW1lbnQpIHtcbiAgICAgICAgc3VwZXIoX2h0dHBDbGllbnQsIF9zYW5pdGl6ZXIsIF9kb2N1bWVudCk7XG4gICAgICAgIGNvbnN0IHNhbml0aXplZExpdGVyYWwgPSB0aGlzLl9zYW5pdGl6ZXIuc2FuaXRpemUoU2VjdXJpdHlDb250ZXh0LkhUTUwsIGRhdGEpO1xuXG4gICAgICAgIGlmICghc2FuaXRpemVkTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFRoZSBsaXRlcmFsIHByb3ZpZGVkIHRvIE54SWNvblJlZ2lzdHJ5IHdhcyBub3QgdHJ1c3RlZCBhcyBzYWZlIEhUTUwgYnkgQW5ndWxhcidzIERvbVNhbml0aXplci4gQXR0ZW1wdGVkIGxpdGVyYWwgd2FzIFwiJHtkYXRhfVwiLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdmdFbGVtZW50ID0gdGhpcy5fc3ZnRWxlbWVudEZyb21TdHJpbmcoc2FuaXRpemVkTGl0ZXJhbCk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTnhTdmdJY29uRnJvbVVybCBleHRlbmRzIE54U3ZnSWNvbiB7XG4gICAgdXJsOiBzdHJpbmc7XG5cbiAgICBwcm90ZWN0ZWQgX2h0dHBDbGllbnQ6IEh0dHBDbGllbnQ7XG5cbiAgICAvLyB1c2VkIHRvIG5vdCBzZW5kIG11bHRpcGxlIHJlcXVlc3RzIGZvciB0aGUgc2FtZSB1cmxcbiAgICBwcml2YXRlIF9wZW5kaW5nUmVxdWVzdDogT2JzZXJ2YWJsZTxhbnk+IHwgdW5kZWZpbmVkO1xuXG4gICAgY29uc3RydWN0b3Ioc2FmZVVybDogU2FmZVJlc291cmNlVXJsLCBfaHR0cENsaWVudDogSHR0cENsaWVudCB8IG51bGwsIHByb3RlY3RlZCBfc2FuaXRpemVyOiBEb21TYW5pdGl6ZXIsIHByb3RlY3RlZCBfZG9jdW1lbnQ6IERvY3VtZW50KSB7XG4gICAgICAgIHN1cGVyKF9odHRwQ2xpZW50LCBfc2FuaXRpemVyLCBfZG9jdW1lbnQpO1xuXG4gICAgICAgIHRoaXMudXJsID0gdGhpcy5fc2FuaXRpemVyLnNhbml0aXplKFNlY3VyaXR5Q29udGV4dC5SRVNPVVJDRV9VUkwsIHNhZmVVcmwpIGFzIHN0cmluZztcblxuICAgICAgICBpZiAoIXRoaXMudXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlIFVSTCBwcm92aWRlZCB0byBOeEljb25SZWdpc3RyeSB3YXMgbm90IHRydXN0ZWQgYXMgYSByZXNvdXJjZSBVUkwgdmlhIEFuZ3VsYXIncyBEb21TYW5pdGl6ZXIuIEF0dGVtcHRlZCBVUkwgd2FzIFwiJHtzYWZlVXJsfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghX2h0dHBDbGllbnQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFxuICAgICAgICAgICAgICAgICdDb3VsZCBub3QgZmluZCBIdHRwQ2xpZW50IHByb3ZpZGVyIGZvciB1c2luZyBhIFNWRyB1cmwgaW4gdGhlIG54LWljb24gcmVnaXN0cnkuICcgK1xuICAgICAgICAgICAgICAgICAgICAnUGxlYXNlIGluY2x1ZGUgdGhlIEh0dHBDbGllbnRNb2R1bGUgZnJvbSBAYW5ndWxhci9jb21tb24vaHR0cCBpbiB5b3VyIGFwcCBpbXBvcnRzLicsXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2h0dHBDbGllbnQgPSBfaHR0cENsaWVudDtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgY29udGVudC4gSWYgdGhlIFNWRyBpcyBub3QgYWxyZWFkeSBsb2FkZWQgaXQgZmV0Y2hlcyB0aGUgU1ZHIGZyb20gaWNvbnMnIFVSTCAqL1xuICAgIGdldENvbnRlbnQoKTogT2JzZXJ2YWJsZTxTVkdFbGVtZW50PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkU3ZnSWNvbigpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2xvYWRTdmdJY29uKCkge1xuICAgICAgICAvLyBJZiB0aGUgU1ZHIGZvciB0aGlzIGljb24gaGFzIGFscmVhZHkgYmVlbiBwYXJzZWQsIGRvIG5vdGhpbmcuXG4gICAgICAgIGlmICh0aGlzLnN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBvZih0aGlzLnN2Z0VsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZldGNoVXJsKHRoaXMudXJsKS5waXBlKFxuICAgICAgICAgICAgbWFwKHN2Z1RleHQgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIGljb24gd2FzIHBhcnNlZCBhbmQgY2FjaGVkIGJ5IGFuIGVhcmxpZXIgcmVxdWVzdCwgc28gcGFyc2luZ1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgbmVlZHMgdG8gb2NjdXIgaWYgdGhlIGNhY2hlIGlzIHlldCB1bnNldC5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN2Z0VsZW1lbnQgPSB0aGlzLl9zdmdFbGVtZW50RnJvbVN0cmluZyhzdmdUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdmdFbGVtZW50O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHdoaWNoIHByb2R1Y2VzIHRoZSBzdHJpbmcgY29udGVudHMgb2YgdGhlIGdpdmVuIFVSTC4gUmVzdWx0cyBtYXkgYmVcbiAgICAgKiBjYWNoZWQsIHNvIGZ1dHVyZSBjYWxscyB3aXRoIHRoZSBzYW1lIFVSTCBtYXkgbm90IGNhdXNlIGFub3RoZXIgSFRUUCByZXF1ZXN0LlxuICAgICAqL1xuICAgIHByaXZhdGUgX2ZldGNoVXJsKHVybDogc3RyaW5nKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICAgICAgLy8gU3RvcmUgaW4tcHJvZ3Jlc3MgZmV0Y2hlcyB0byBhdm9pZCBzZW5kaW5nIGEgZHVwbGljYXRlIHJlcXVlc3QgZm9yIGEgVVJMIHdoZW4gdGhlcmUgaXNcbiAgICAgICAgLy8gYWxyZWFkeSBhIHJlcXVlc3QgaW4gcHJvZ3Jlc3MgZm9yIHRoYXQgVVJMLiBJdCdzIG5lY2Vzc2FyeSB0byBjYWxsIHNoYXJlKCkgb24gdGhlXG4gICAgICAgIC8vIE9ic2VydmFibGUgcmV0dXJuZWQgYnkgaHR0cC5nZXQoKSBzbyB0aGF0IG11bHRpcGxlIHN1YnNjcmliZXJzIGRvbid0IGNhdXNlIG11bHRpcGxlIFhIUnMuXG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BlbmRpbmdSZXF1ZXN0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVxID0gdGhpcy5faHR0cENsaWVudC5nZXQodXJsLCB7IHJlc3BvbnNlVHlwZTogJ3RleHQnIH0pLnBpcGUoXG4gICAgICAgICAgICBmaW5hbGl6ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHNoYXJlKCksXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcXVlc3QgPSByZXE7XG4gICAgICAgIHJldHVybiByZXE7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgTnhGb250SWNvbiB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGFsaWFzOiBzdHJpbmcsIHB1YmxpYyBmb250OiBOeEljb25Gb250RGVmaW5pdGlvbikge31cblxuICAgIGdldENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB7IGFsaWFzOiB0aGlzLmFsaWFzLCBmb250OiB0aGlzLmZvbnQgfTtcbiAgICB9XG59XG4iXX0=