import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, Component, ContentChildren, EventEmitter, HostBinding, Inject, InjectionToken, Input, Optional, Output, Self, } from '@angular/core';
import { merge, Subject } from 'rxjs';
import { filter, startWith, takeUntil, tap } from 'rxjs/operators';
import { ToggleButton } from '../circle-toggle/toggle-button';
import * as i0 from "@angular/core";
import * as i1 from "@aposin/ng-aquila/utils";
import * as i2 from "@angular/forms";
import * as i3 from "@angular/common";
export const CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS = new InjectionToken('CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS');
let nextId = 0;
export class NxCircleToggleGroupComponent {
    constructor(_cdr, _errorStateMatcher, _defaultOptions, ngControl, _parentForm, _parentFormGroup) {
        this._cdr = _cdr;
        this._errorStateMatcher = _errorStateMatcher;
        this._defaultOptions = _defaultOptions;
        this.ngControl = ngControl;
        this._parentForm = _parentForm;
        this._parentFormGroup = _parentFormGroup;
        this.errorState = false;
        this._id = `nx-circle-toggle-group-${nextId++}`;
        /** An event emitted when the selection changes. Outputs the value of the currently selected button. */
        this.valueChange = new EventEmitter();
        this._name = `toggle-group-${nextId++}`;
        this._disabled = false;
        this._negative = false;
        this._responsive = true;
        this._destroyed = new Subject();
        this.onChangeCallback = (value) => { };
        this.onTouchedCallback = () => { };
        if (this.ngControl) {
            // Note: we provide the value accessor through here, instead of
            // the `providers` to avoid running into a circular import.
            this.ngControl.valueAccessor = this;
        }
    }
    /**
     * Id of the circle toggle group.
     *
     * If not set, the circle toggle group gets an incremented value by default.
     */
    set id(value) {
        this._id = value;
        this._cdr.markForCheck();
    }
    get id() {
        return this._id;
    }
    /** Name that is used for accessibility. */
    set name(value) {
        this._name = value;
        this.updateToggleButtonsNames();
        this._cdr.markForCheck();
    }
    get name() {
        return this._name;
    }
    /** Whether the circle toggle group is disabled. */
    set disabled(value) {
        const newValue = coerceBooleanProperty(value);
        if (this._disabled !== newValue) {
            this._disabled = newValue;
            this._cdr.markForCheck();
        }
        if (this.buttons) {
            this.buttons.forEach(button => (button.disabled = newValue));
        }
    }
    get disabled() {
        return this._disabled;
    }
    /** Whether the circle toggle group uses the negative styling. */
    set negative(value) {
        const newValue = coerceBooleanProperty(value);
        if (this.negative !== newValue) {
            this._negative = newValue;
        }
        if (this.buttons) {
            this.buttons.forEach(button => (button.negative = newValue));
        }
    }
    get negative() {
        return this._negative;
    }
    /** The value of the selected circle toggle in the circle toggle group. */
    set value(value) {
        this.writeValue(value);
    }
    get value() {
        return this._value;
    }
    /** Whether the circle toggle group has a responsive behavior. */
    set responsive(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this.responsive) {
            this._responsive = newValue;
            this._cdr.markForCheck();
        }
    }
    get responsive() {
        if (this._isExpert) {
            return false;
        }
        return this._responsive;
    }
    get _isExpert() {
        return this.appearance === 'expert';
    }
    /** @docs-private */
    get selectedButton() {
        return this.buttons ? this.buttons.find(button => button.checked) || null : null;
    }
    /** @docs-private */
    get buttons() {
        return this._buttons;
    }
    /**
     * **Expert option**
     *
     * Sets the appearance of the circle toggle group. Default: 'default'
     */
    set appearance(value) {
        if (this._appearance !== value) {
            this._appearance = value;
            this._cdr.markForCheck();
        }
    }
    get appearance() {
        return this._appearance || this._defaultOptions?.appearance || 'default';
    }
    writeValue(value) {
        Promise.resolve().then(() => {
            if (this.value !== value) {
                this._value = value;
                this.notifySelectedChild(value);
            }
        });
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
    }
    ngAfterViewInit() {
        this.subscribeToSelectionChanges();
        // react if a content child is deleted, added etc.
        this.buttons.changes
            .pipe(startWith(this.buttons), filter(toggles => toggles.length > 0), tap(async (toggles) => Promise.resolve().then(() => {
            toggles.forEach((toggle) => toggle.toggleButton.resetClasses());
            this.buttons.first.toggleButton.setFirstButton();
            this.buttons.last.toggleButton.setLastButton();
        })), takeUntil(this._destroyed))
            .subscribe(() => this.subscribeToSelectionChanges());
    }
    /** @docs-private */
    subscribeToSelectionChanges() {
        merge(...this.buttons.map(button => button.selectionChange))
            .pipe(takeUntil(this.buttons.changes), takeUntil(this._destroyed))
            .subscribe((change) => {
            this.onChangeCallback(change.value);
            this.valueChange.emit(change.value);
        });
    }
    /**
     * @docs-private
     * inform the selected button if the group selection is set programattically at the beginning
     */
    notifySelectedChild(newValue) {
        if (this.buttons) {
            const selected = this.buttons.find(button => button.value === newValue);
            if (selected) {
                selected.setGroupSelection();
            }
        }
    }
    /** @docs-private */
    updateToggleButtonsNames() {
        if (this.buttons) {
            this.buttons.forEach(button => (button.name = this.name));
        }
    }
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
    }
    ngDoCheck() {
        if (this.ngControl) {
            // We need to re-evaluate this on every change detection cycle, because there are some
            // error triggers that we can't subscribed to (e.g. parent form submissions). This means
            // that whatever logic is in here has to be super lean or we risk destroying the performance.
            this._updateErrorState();
        }
    }
    _updateErrorState() {
        const oldState = this.errorState;
        const parent = this._parentFormGroup || this._parentForm;
        const control = this.ngControl ? this.ngControl.control : null;
        const newState = this._errorStateMatcher.isErrorState(control, parent);
        if (newState !== oldState) {
            this.errorState = newState;
            this._cdr.markForCheck();
        }
    }
}
NxCircleToggleGroupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleGroupComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.ErrorStateMatcher }, { token: CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS, optional: true }, { token: i2.NgControl, optional: true, self: true }, { token: i2.NgForm, optional: true }, { token: i2.FormGroupDirective, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxCircleToggleGroupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxCircleToggleGroupComponent, selector: "nx-circle-toggle-group", inputs: { name: "name", disabled: "disabled", negative: "negative", value: "value", responsive: "responsive", appearance: "appearance" }, outputs: { valueChange: "valueChange" }, host: { attributes: { "role": "radiogroup" }, properties: { "class.is-responsive": "responsive", "class.is-disabled": "disabled", "attr.aria-disabled": "disabled", "attr.aria-labelledby": "name", "class.has-error": "errorState", "attr.name": "name", "attr.id": "id", "class.nx-circle-toggle-group": "true", "class.is-expert": "this._isExpert" } }, providers: [], queries: [{ propertyName: "_buttons", predicate: ToggleButton, descendants: true }], ngImport: i0, template: `<ng-content></ng-content>
        <ng-container *ngIf="errorState">
            <ng-content select="nx-error"></ng-content>
        </ng-container> `, isInline: true, styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width: 320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width: 704px){:host(.is-responsive){flex-direction:row}}:host(.has-error) ::ng-deep .nx-toggle-circle__icon-wrapper{border-color:var(--danger)}\n"], directives: [{ type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxCircleToggleGroupComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-circle-toggle-group', template: `<ng-content></ng-content>
        <ng-container *ngIf="errorState">
            <ng-content select="nx-error"></ng-content>
        </ng-container> `, changeDetection: ChangeDetectionStrategy.OnPush, providers: [], host: {
                        '[class.is-responsive]': 'responsive',
                        '[class.is-disabled]': 'disabled',
                        '[attr.aria-disabled]': 'disabled',
                        '[attr.aria-labelledby]': 'name',
                        '[class.has-error]': 'errorState',
                        '[attr.name]': 'name',
                        '[attr.id]': 'id',
                        '[class.nx-circle-toggle-group]': 'true',
                        role: 'radiogroup',
                    }, styles: [":host{display:flex;flex-wrap:wrap;flex-direction:column;justify-content:space-around}@media (min-width: 320px){:host{flex-direction:row}}:host(.is-responsive){flex-direction:column}@media (min-width: 704px){:host(.is-responsive){flex-direction:row}}:host(.has-error) ::ng-deep .nx-toggle-circle__icon-wrapper{border-color:var(--danger)}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.ErrorStateMatcher }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [CIRCLE_TOGGLE_GROUP_DEFAULT_OPTIONS]
                }] }, { type: i2.NgControl, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: i2.NgForm, decorators: [{
                    type: Optional
                }] }, { type: i2.FormGroupDirective, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { name: [{
                type: Input
            }], disabled: [{
                type: Input
            }], negative: [{
                type: Input
            }], value: [{
                type: Input
            }], responsive: [{
                type: Input
            }], _isExpert: [{
                type: HostBinding,
                args: ['class.is-expert']
            }], _buttons: [{
                type: ContentChildren,
                args: [ToggleButton, { descendants: true }]
            }], valueChange: [{
                type: Output
            }], appearance: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2lyY2xlLXRvZ2dsZS1ncm91cC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL2NpcmNsZS10b2dnbGUvY2lyY2xlLXRvZ2dsZS1ncm91cC9jaXJjbGUtdG9nZ2xlLWdyb3VwLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWdCLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUUsT0FBTyxFQUVILHVCQUF1QixFQUV2QixTQUFTLEVBQ1QsZUFBZSxFQUVmLFlBQVksRUFDWixXQUFXLEVBQ1gsTUFBTSxFQUNOLGNBQWMsRUFDZCxLQUFLLEVBRUwsUUFBUSxFQUNSLE1BQU0sRUFFTixJQUFJLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRW5FLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQzs7Ozs7QUFrQjlELE1BQU0sQ0FBQyxNQUFNLG1DQUFtQyxHQUFHLElBQUksY0FBYyxDQUFrQyxxQ0FBcUMsQ0FBQyxDQUFDO0FBRTlJLElBQUksTUFBTSxHQUFHLENBQUMsQ0FBQztBQXVCZixNQUFNLE9BQU8sNEJBQTRCO0lBdUZyQyxZQUNZLElBQXVCLEVBQ3ZCLGtCQUFxQyxFQUNvQixlQUF1RCxFQUM3RixTQUEyQixFQUNsQyxXQUEwQixFQUMxQixnQkFBMkM7UUFMdkQsU0FBSSxHQUFKLElBQUksQ0FBbUI7UUFDdkIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFtQjtRQUNvQixvQkFBZSxHQUFmLGVBQWUsQ0FBd0M7UUFDN0YsY0FBUyxHQUFULFNBQVMsQ0FBa0I7UUFDbEMsZ0JBQVcs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QUUsbURBNkhJLFlBQVksZ0RBbkluQjs7O3lCQUdXOzJGQWdCWiw0QkFBNEI7a0JBckJ4QyxTQUFTOytCQUNJLHdCQUF3QixZQUN4Qjs7O3lCQUdXLG1CQUVKLHVCQUF1QixDQUFDLE1BQU0sYUFDcEMsRUFBRSxRQUNQO3dCQUNGLHVCQUF1QixFQUFFLFlBQVk7d0JBQ3JDLHFCQUFxQixFQUFFLFVBQVU7d0JBQ2pDLHNCQUFzQixFQUFFLFVBQVU7d0JBQ2xDLHdCQUF3QixFQUFFLE1BQU07d0JBQ2hDLG1CQUFtQixFQUFFLFlBQVk7d0JBQ2pDLGFBQWEsRUFBRSxNQUFNO3dCQUNyQixXQUFXLEVBQUUsSUFBSTt3QkFDakIsZ0NBQWdDLEVBQUUsTUFBTTt3QkFDeEMsSUFBSSxFQUFFLFlBQVk7cUJBQ3JCOzswQkE0RkksUUFBUTs7MEJBQUksTUFBTTsyQkFBQyxtQ0FBbUM7OzBCQUN0RCxRQUFROzswQkFBSSxJQUFJOzswQkFDaEIsUUFBUTs7MEJBQ1IsUUFBUTs0Q0E3RVQsSUFBSTtzQkFEUCxLQUFLO2dCQVlGLFFBQVE7c0JBRFgsS0FBSztnQkFnQkYsUUFBUTtzQkFEWCxLQUFLO2dCQWVGLEtBQUs7c0JBRFIsS0FBSztnQkFVRixVQUFVO3NCQURiLEtBQUs7Z0JBaUJGLFNBQVM7c0JBRFosV0FBVzt1QkFBQyxpQkFBaUI7Z0JBZ0NnQyxRQUFRO3NCQUFyRSxlQUFlO3VCQUFDLFlBQVksRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUU7Z0JBTXBELFdBQVc7c0JBRFYsTUFBTTtnQkFxQkgsVUFBVTtzQkFEYixLQUFLIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm9vbGVhbklucHV0LCBjb2VyY2VCb29sZWFuUHJvcGVydHkgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGRyZW4sXG4gICAgRG9DaGVjayxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5qZWN0LFxuICAgIEluamVjdGlvblRva2VuLFxuICAgIElucHV0LFxuICAgIE9uRGVzdHJveSxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFNlbGYsXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEZvcm1Db250cm9sLCBGb3JtR3JvdXBEaXJlY3RpdmUsIE5nQ29udHJvbCwgTmdGb3JtIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICdAYXBvc2luL25nLWFxdWlsYS91dGlscyc7XG5pbXBvcnQgeyBtZXJnZSwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBzdGFydFdpdGgsIHRha2VVbnRpbCwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBUb2dnbGVCdXR0b24gfSBmcm9tICcuLi9jaXJjbGUtdG9nZ2xlL3RvZ2dsZS1idXR0b24nO1xuXG4vKipcbiAqIEFwcGVhcmFuY2Ugb3B0aW9ucyBmb3IgdGhlIGNpcmNsZSB0b2dnbGUgZ3JvdXAgY29tcG9uZW50LlxuICovXG5leHBvcnQgdHlwZSBOeENpcmNsZVRvZ2dsZUdyb3VwQXBwZWFyYW5jZSA9ICdkZWZhdWx0JyB8ICdleHBlcnQnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgdGhlIGNpcmNsZSB0b2dnbGUgZ3JvdXAuXG4gKiBJdCBjYW4gYmUgY29uZmlndXJlZCB1c2luZyB0aGUgYENJUkNMRV9UT0dHTEVfR1JPVVBfREVGQVVMVF9PUFRJT05TYCBpbmplY3Rpb24gdG9rZW4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ2lyY2xlVG9nZ2xlR3JvdXBEZWZhdWx0T3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCBhcHBlYXJhbmNlLiAob3B0aW9uYWwpXG4gICAgICovXG4gICAgYXBwZWFyYW5jZT86IE54Q2lyY2xlVG9nZ2xlR3JvdXBBcHBlYXJhbmNlO1xufVxuXG5leHBvcnQgY29uc3QgQ0lSQ0xFX1RPR0dMRV9HUk9VUF9ERUZBVUxUX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48Q2lyY2xlVG9nZ2xlR3JvdXBEZWZhdWx0T3B0aW9ucz4oJ0NJUkNMRV9UT0dHTEVfR1JPVVBfREVGQVVMVF9PUFRJT05TJyk7XG5cbmxldCBuZXh0SWQgPSAwO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ254LWNpcmNsZS10b2dnbGUtZ3JvdXAnLFxuICAgIHRlbXBsYXRlOiBgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiZXJyb3JTdGF0ZVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwibngtZXJyb3JcIj48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbmctY29udGFpbmVyPiBgLFxuICAgIHN0eWxlVXJsczogWycuL2NpcmNsZS10b2dnbGUtZ3JvdXAuY29tcG9uZW50LnNjc3MnXSxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcm92aWRlcnM6IFtdLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tjbGFzcy5pcy1yZXNwb25zaXZlXSc6ICdyZXNwb25zaXZlJyxcbiAgICAgICAgJ1tjbGFzcy5pcy1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAnW2F0dHIuYXJpYS1kaXNhYmxlZF0nOiAnZGlzYWJsZWQnLFxuICAgICAgICAnW2F0dHIuYXJpYS1sYWJlbGxlZGJ5XSc6ICduYW1lJyxcbiAgICAgICAgJ1tjbGFzcy5oYXMtZXJyb3JdJzogJ2Vycm9yU3RhdGUnLFxuICAgICAgICAnW2F0dHIubmFtZV0nOiAnbmFtZScsXG4gICAgICAgICdbYXR0ci5pZF0nOiAnaWQnLFxuICAgICAgICAnW2NsYXNzLm54LWNpcmNsZS10b2dnbGUtZ3JvdXBdJzogJ3RydWUnLFxuICAgICAgICByb2xlOiAncmFkaW9ncm91cCcsXG4gICAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTnhDaXJjbGVUb2dnbGVHcm91cENvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3ksIERvQ2hlY2sge1xuICAgIC8qKlxuICAgICAqIElkIG9mIHRoZSBjaXJjbGUgdG9nZ2xlIGdyb3VwLlxuICAgICAqXG4gICAgICogSWYgbm90IHNldCwgdGhlIGNpcmNsZSB0b2dnbGUgZ3JvdXAgZ2V0cyBhbiBpbmNyZW1lbnRlZCB2YWx1ZSBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIHNldCBpZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2lkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgZ2V0IGlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG5cbiAgICAvKiogTmFtZSB0aGF0IGlzIHVzZWQgZm9yIGFjY2Vzc2liaWxpdHkuICovXG4gICAgQElucHV0KClcbiAgICBzZXQgbmFtZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX25hbWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVUb2dnbGVCdXR0b25zTmFtZXMoKTtcbiAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG5cbiAgICAvKiogV2hldGhlciB0aGUgY2lyY2xlIHRvZ2dsZSBncm91cCBpcyBkaXNhYmxlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBkaXNhYmxlZCh2YWx1ZTogQm9vbGVhbklucHV0KSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuX2Rpc2FibGVkICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idXR0b25zKSB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4gKGJ1dHRvbi5kaXNhYmxlZCA9IG5ld1ZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoZSBjaXJjbGUgdG9nZ2xlIGdyb3VwIHVzZXMgdGhlIG5lZ2F0aXZlIHN0eWxpbmcuICovXG4gICAgQElucHV0KClcbiAgICBzZXQgbmVnYXRpdmUodmFsdWU6IEJvb2xlYW5JbnB1dCkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbmVnYXRpdmUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idXR0b25zKSB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvbnMuZm9yRWFjaChidXR0b24gPT4gKGJ1dHRvbi5uZWdhdGl2ZSA9IG5ld1ZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5lZ2F0aXZlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmVnYXRpdmU7XG4gICAgfVxuICAgIC8qKiBUaGUgdmFsdWUgb2YgdGhlIHNlbGVjdGVkIGNpcmNsZSB0b2dnbGUgaW4gdGhlIGNpcmNsZSB0b2dnbGUgZ3JvdXAuICovXG4gICAgQElucHV0KClcbiAgICBzZXQgdmFsdWUodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIGdldCB2YWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIC8qKiBXaGV0aGVyIHRoZSBjaXJjbGUgdG9nZ2xlIGdyb3VwIGhhcyBhIHJlc3BvbnNpdmUgYmVoYXZpb3IuICovXG4gICAgQElucHV0KClcbiAgICBzZXQgcmVzcG9uc2l2ZSh2YWx1ZTogQm9vbGVhbklucHV0KSB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlICE9PSB0aGlzLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNpdmUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZXNwb25zaXZlKCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5faXNFeHBlcnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2l2ZTtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlzLWV4cGVydCcpXG4gICAgZ2V0IF9pc0V4cGVydCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwZWFyYW5jZSA9PT0gJ2V4cGVydCc7XG4gICAgfVxuXG4gICAgZXJyb3JTdGF0ZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX2NkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIHByaXZhdGUgX2Vycm9yU3RhdGVNYXRjaGVyOiBFcnJvclN0YXRlTWF0Y2hlcixcbiAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChDSVJDTEVfVE9HR0xFX0dST1VQX0RFRkFVTFRfT1BUSU9OUykgcHJpdmF0ZSBfZGVmYXVsdE9wdGlvbnM6IENpcmNsZVRvZ2dsZUdyb3VwRGVmYXVsdE9wdGlvbnMgfCBudWxsLFxuICAgICAgICBAT3B0aW9uYWwoKSBAU2VsZigpIHB1YmxpYyBuZ0NvbnRyb2w6IE5nQ29udHJvbCB8IG51bGwsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm06IE5nRm9ybSB8IG51bGwsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgX3BhcmVudEZvcm1Hcm91cDogRm9ybUdyb3VwRGlyZWN0aXZlIHwgbnVsbCxcbiAgICApIHtcbiAgICAgICAgaWYgKHRoaXMubmdDb250cm9sKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiB3ZSBwcm92aWRlIHRoZSB2YWx1ZSBhY2Nlc3NvciB0aHJvdWdoIGhlcmUsIGluc3RlYWQgb2ZcbiAgICAgICAgICAgIC8vIHRoZSBgcHJvdmlkZXJzYCB0byBhdm9pZCBydW5uaW5nIGludG8gYSBjaXJjdWxhciBpbXBvcnQuXG4gICAgICAgICAgICB0aGlzLm5nQ29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IHNlbGVjdGVkQnV0dG9uKCk6IFRvZ2dsZUJ1dHRvbiB8IG51bGwge1xuICAgICAgICByZXR1cm4gdGhpcy5idXR0b25zID8gdGhpcy5idXR0b25zLmZpbmQoYnV0dG9uID0+IGJ1dHRvbi5jaGVja2VkKSB8fCBudWxsIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIGdldCBidXR0b25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9ucztcbiAgICB9XG5cbiAgICBAQ29udGVudENoaWxkcmVuKFRvZ2dsZUJ1dHRvbiwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KSBwcml2YXRlIF9idXR0b25zITogUXVlcnlMaXN0PFRvZ2dsZUJ1dHRvbj47XG5cbiAgICBwcml2YXRlIF9pZCA9IGBueC1jaXJjbGUtdG9nZ2xlLWdyb3VwLSR7bmV4dElkKyt9YDtcblxuICAgIC8qKiBBbiBldmVudCBlbWl0dGVkIHdoZW4gdGhlIHNlbGVjdGlvbiBjaGFuZ2VzLiBPdXRwdXRzIHRoZSB2YWx1ZSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGJ1dHRvbi4gKi9cbiAgICBAT3V0cHV0KClcbiAgICB2YWx1ZUNoYW5nZTogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBwcml2YXRlIF9uYW1lID0gYHRvZ2dsZS1ncm91cC0ke25leHRJZCsrfWA7XG5cbiAgICBwcml2YXRlIF9kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgX25lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICBwcml2YXRlIF92YWx1ZSE6IHN0cmluZztcblxuICAgIHByaXZhdGUgX3Jlc3BvbnNpdmUgPSB0cnVlO1xuXG4gICAgcHJpdmF0ZSBfYXBwZWFyYW5jZTogTnhDaXJjbGVUb2dnbGVHcm91cEFwcGVhcmFuY2UgfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiAqKkV4cGVydCBvcHRpb24qKlxuICAgICAqXG4gICAgICogU2V0cyB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgY2lyY2xlIHRvZ2dsZSBncm91cC4gRGVmYXVsdDogJ2RlZmF1bHQnXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgYXBwZWFyYW5jZSh2YWx1ZTogTnhDaXJjbGVUb2dnbGVHcm91cEFwcGVhcmFuY2UpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FwcGVhcmFuY2UgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBlYXJhbmNlID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgYXBwZWFyYW5jZSgpOiBOeENpcmNsZVRvZ2dsZUdyb3VwQXBwZWFyYW5jZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBlYXJhbmNlIHx8IHRoaXMuX2RlZmF1bHRPcHRpb25zPy5hcHBlYXJhbmNlIHx8ICdkZWZhdWx0JztcbiAgICB9XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9kZXN0cm95ZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgcHJpdmF0ZSBvbkNoYW5nZUNhbGxiYWNrID0gKHZhbHVlOiBzdHJpbmcpID0+IHt9O1xuICAgIHByaXZhdGUgb25Ub3VjaGVkQ2FsbGJhY2sgPSAoKSA9PiB7fTtcblxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTZWxlY3RlZENoaWxkKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1NlbGVjdGlvbkNoYW5nZXMoKTtcblxuICAgICAgICAvLyByZWFjdCBpZiBhIGNvbnRlbnQgY2hpbGQgaXMgZGVsZXRlZCwgYWRkZWQgZXRjLlxuICAgICAgICB0aGlzLmJ1dHRvbnMuY2hhbmdlc1xuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgc3RhcnRXaXRoKHRoaXMuYnV0dG9ucyksXG4gICAgICAgICAgICAgICAgZmlsdGVyKHRvZ2dsZXMgPT4gdG9nZ2xlcy5sZW5ndGggPiAwKSxcbiAgICAgICAgICAgICAgICB0YXAoYXN5bmMgdG9nZ2xlcyA9PlxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvZ2dsZXMuZm9yRWFjaCgodG9nZ2xlOiBhbnkpID0+IHRvZ2dsZS50b2dnbGVCdXR0b24ucmVzZXRDbGFzc2VzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zLmZpcnN0LnRvZ2dsZUJ1dHRvbi5zZXRGaXJzdEJ1dHRvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b25zLmxhc3QudG9nZ2xlQnV0dG9uLnNldExhc3RCdXR0b24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5zdWJzY3JpYmVUb1NlbGVjdGlvbkNoYW5nZXMoKSk7XG4gICAgfVxuXG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBzdWJzY3JpYmVUb1NlbGVjdGlvbkNoYW5nZXMoKSB7XG4gICAgICAgIG1lcmdlKC4uLnRoaXMuYnV0dG9ucy5tYXAoYnV0dG9uID0+IGJ1dHRvbi5zZWxlY3Rpb25DaGFuZ2UpKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuYnV0dG9ucy5jaGFuZ2VzKSwgdGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3llZCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChjaGFuZ2U6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayhjaGFuZ2UudmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdChjaGFuZ2UudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRvY3MtcHJpdmF0ZVxuICAgICAqIGluZm9ybSB0aGUgc2VsZWN0ZWQgYnV0dG9uIGlmIHRoZSBncm91cCBzZWxlY3Rpb24gaXMgc2V0IHByb2dyYW1hdHRpY2FsbHkgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAqL1xuICAgIG5vdGlmeVNlbGVjdGVkQ2hpbGQobmV3VmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5idXR0b25zKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9IHRoaXMuYnV0dG9ucy5maW5kKGJ1dHRvbiA9PiBidXR0b24udmFsdWUgPT09IG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLnNldEdyb3VwU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIHVwZGF0ZVRvZ2dsZUJ1dHRvbnNOYW1lcygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuYnV0dG9ucykge1xuICAgICAgICAgICAgdGhpcy5idXR0b25zLmZvckVhY2goYnV0dG9uID0+IChidXR0b24ubmFtZSA9IHRoaXMubmFtZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayA9IGZuO1xuICAgIH1cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMub25Ub3VjaGVkQ2FsbGJhY2sgPSBmbjtcbiAgICB9XG5cbiAgICBzZXREaXNhYmxlZFN0YXRlPyhpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBpc0Rpc2FibGVkO1xuICAgIH1cblxuICAgIG5nRG9DaGVjaygpIHtcbiAgICAgICAgaWYgKHRoaXMubmdDb250cm9sKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlLWV2YWx1YXRlIHRoaXMgb24gZXZlcnkgY2hhbmdlIGRldGVjdGlvbiBjeWNsZSwgYmVjYXVzZSB0aGVyZSBhcmUgc29tZVxuICAgICAgICAgICAgLy8gZXJyb3IgdHJpZ2dlcnMgdGhhdCB3ZSBjYW4ndCBzdWJzY3JpYmVkIHRvIChlLmcuIHBhcmVudCBmb3JtIHN1Ym1pc3Npb25zKS4gVGhpcyBtZWFuc1xuICAgICAgICAgICAgLy8gdGhhdCB3aGF0ZXZlciBsb2dpYyBpcyBpbiBoZXJlIGhhcyB0byBiZSBzdXBlciBsZWFuIG9yIHdlIHJpc2sgZGVzdHJveWluZyB0aGUgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVFcnJvclN0YXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlRXJyb3JTdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmVycm9yU3RhdGU7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX3BhcmVudEZvcm1Hcm91cCB8fCB0aGlzLl9wYXJlbnRGb3JtO1xuICAgICAgICBjb25zdCBjb250cm9sID0gdGhpcy5uZ0NvbnRyb2wgPyAodGhpcy5uZ0NvbnRyb2wuY29udHJvbCBhcyBGb3JtQ29udHJvbCkgOiBudWxsO1xuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuX2Vycm9yU3RhdGVNYXRjaGVyLmlzRXJyb3JTdGF0ZShjb250cm9sLCBwYXJlbnQpO1xuXG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19