var _NxContextMenuTriggerDirective_scrollStrategy;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';
import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { _getEventTarget } from '@angular/cdk/platform';
import { TemplatePortal } from '@angular/cdk/portal';
import { Directive, EventEmitter, Inject, InjectionToken, Input, Optional, Output, Self, } from '@angular/core';
import { asapScheduler, fromEvent, merge, of as observableOf, Subject, Subscription } from 'rxjs';
import { delay, filter, map, take, takeUntil } from 'rxjs/operators';
import { NxContextMenuComponent } from './context-menu.component';
import { throwNxContextMenuMissingError } from './context-menu-errors';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "./context-menu.component";
import * as i3 from "./context-menu-item.component";
import * as i4 from "@angular/cdk/bidi";
import * as i5 from "@aposin/ng-aquila/overlay";
/** Default top padding of the menu panel. */
export const MENU_PANEL_TOP_PADDING = 8;
export const MENU_PANEL_OFFSET_Y = 8;
export const MENU_PANEL_OFFSET_X = 8;
/** Injection token that determines the scroll handling while a context-menu is open. */
export const NX_CONTEXT_MENU_SCROLL_STRATEGY = new InjectionToken('nx-context-menu-scroll-strategy');
/** @docs-private */
export function NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/** @docs-private */
export const NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_CONTEXT_MENU_SCROLL_STRATEGY,
    useFactory: NX_CONTEXT_MENU_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
/**
 * This directive is intended to be used in conjunction with an nx-context-menu tag.
 * It is responsible for toggling the display of the provided context menu instance.
 */
export class NxContextMenuTriggerDirective {
    constructor(_overlay, _element, _viewContainerRef, _parentMenu, _contextMenuItemInstance, _dir, _triggerButton, _defaultScrollStrategyFactory, _cdr) {
        this._overlay = _overlay;
        this._element = _element;
        this._viewContainerRef = _viewContainerRef;
        this._parentMenu = _parentMenu;
        this._contextMenuItemInstance = _contextMenuItemInstance;
        this._dir = _dir;
        this._triggerButton = _triggerButton;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this._cdr = _cdr;
        this._overlayRef = null;
        this._contextMenuOpen = false;
        this._closingActionsSubscription = Subscription.EMPTY;
        this._contextMenuCloseSubscription = Subscription.EMPTY;
        /** Strategy factory that will be used to handle scrolling while the context-menu panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
        _NxContextMenuTriggerDirective_scrollStrategy.set(this, void 0);
        /**
         * Sets the mode of this context menu trigger.
         * 'button' (default): Opens by clicking the trigger
         * 'cursor': Opens at the cursor position by right clicking anywhere on the trigger.
         */
        this.mode = 'button';
        /** Event emitted when the associated context menu is opened. */
        this.contextMenuOpened = new EventEmitter();
        /** Event emitted when the associated context menu is closed. */
        this.contextMenuClosed = new EventEmitter();
        this._destroyed = new Subject();
        this._rightClicked = false;
        if (_contextMenuItemInstance) {
            _contextMenuItemInstance._triggersSubmenu = this.triggersSubmenu();
        }
        this._documentClickObservable = fromEvent(document, 'click');
        this._dir?.change.pipe(takeUntil(this._destroyed)).subscribe(() => {
            if (this.contextMenuOpen) {
                // HINT: closing menu on direction change.
                // When user re-opens it, the overlay and menu will be initialized properly, based on new direction.
                this.closeContextMenu();
            }
        });
    }
    /** References the context menu instance that the trigger is associated with. */
    get contextMenu() {
        return this._contextMenu;
    }
    set contextMenu(contextMenu) {
        if (contextMenu === this._contextMenu) {
            return;
        }
        this._contextMenu = contextMenu;
        this._contextMenuCloseSubscription.unsubscribe();
        if (contextMenu) {
            this._contextMenuCloseSubscription = contextMenu.closed.asObservable().subscribe(reason => {
                this._destroyMenu();
                // If a click closed the menu, we should close the entire chain of nested menus.
                if ((reason === 'click' || reason === 'tab') && this._parentMenu) {
                    this._parentMenu.closed.emit(reason);
                }
            });
        }
    }
    set scrollStrategy(value) {
        if (__classPrivateFieldGet(this, _NxContextMenuTriggerDirective_scrollStrategy, "f") !== value) {
            __classPrivateFieldSet(this, _NxContextMenuTriggerDirective_scrollStrategy, value, "f");
            this._scrollStrategyFactory = value ? this.getScrollStrtegyFactory(value) : this._defaultScrollStrategyFactory;
            this._cdr.markForCheck();
        }
    }
    get scrollStrategy() {
        return __classPrivateFieldGet(this, _NxContextMenuTriggerDirective_scrollStrategy, "f");
    }
    /** Whether the context menu is open. */
    get contextMenuOpen() {
        return this._contextMenuOpen;
    }
    /** The text direction of the containing app. */
    get dir() {
        return this._dir?.value === 'rtl' ? 'rtl' : 'ltr';
    }
    ngAfterContentInit() {
        this._checkContextMenu();
        this._handleHover();
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        if (this._overlayRef) {
            this._overlayRef.dispose();
            this._overlayRef = null;
        }
        this._contextMenuCloseSubscription.unsubscribe();
        this._closingActionsSubscription.unsubscribe();
    }
    /** Whether the context menu triggers a sub-menu or a top-level one. */
    triggersSubmenu() {
        return !!(this._contextMenuItemInstance && this._parentMenu);
    }
    /** Toggles the context menu between the open and closed states. */
    toggleContextMenu(origin) {
        return this.contextMenuOpen ? this.closeContextMenu() : this.openContextMenu(origin);
    }
    /** Opens the context menu. */
    openContextMenu(origin, position) {
        if (this.contextMenuOpen) {
            return;
        }
        this._checkContextMenu();
        const overlayRef = this._createOverlay();
        const overlayConfig = overlayRef.getConfig();
        if (position) {
            this._setPositionToCursor(overlayConfig.positionStrategy, position);
        }
        else {
            this._setPosition(overlayConfig.positionStrategy);
        }
        overlayRef.attach(this._getPortal());
        if (this.contextMenu.lazyContent) {
            this.contextMenu.lazyContent.attach(this.contextMenuData);
        }
        this._closingActionsSubscription = this._contextMenuClosingActions().subscribe(() => this.closeContextMenu());
        this._initContextMenu(origin);
        if (this.contextMenu instanceof NxContextMenuComponent) {
            this.contextMenu._startAnimation();
        }
        if (this._triggerButton) {
            this._triggerButton.setTriggerActive();
            this.contextMenu.closed.pipe(take(1)).subscribe(() => this._triggerButton?.setTriggerInactive());
        }
        this._waitForClose();
    }
    /** Closes the context menu. */
    closeContextMenu() {
        this._rightClicked = false;
        this.contextMenu.closed.emit();
    }
    getScrollStrtegyFactory(scrollStrategy) {
        switch (scrollStrategy) {
            case 'close':
                return this._overlay.scrollStrategies.close;
            default:
                return this._overlay.scrollStrategies.reposition;
        }
    }
    /** Closes the context menu and does the necessary cleanup. */
    _destroyMenu() {
        if (!this._overlayRef || !this.contextMenuOpen) {
            return;
        }
        const contextMenu = this.contextMenu;
        this._closingActionsSubscription.unsubscribe();
        this._overlayRef.detach();
        contextMenu._resetAnimation();
        if (contextMenu.lazyContent) {
            // Wait for the exit animation to finish before detaching the content.
            contextMenu._animationDone
                .pipe(filter(event => event.toState === 'void'), take(1), 
            // Interrupt if the content got re-attached.
            takeUntil(contextMenu.lazyContent._attached))
                .subscribe({
                next: () => contextMenu.lazyContent?.detach(),
                // No matter whether the content got re-attached, reset the menu.
                complete: () => this._resetContextMenu(),
            });
        }
        else {
            this._resetContextMenu();
        }
    }
    /**
     * This method sets the context menu state to open and focuses the first item if
     * the context menu was opened via the keyboard.
     */
    _initContextMenu(origin) {
        this.contextMenu.parentMenu = this.triggersSubmenu() ? this._parentMenu ?? undefined : undefined;
        this.contextMenu.direction = this.dir;
        this._setIsContextMenuOpen(true);
        this.contextMenu.focusFirstItem(origin);
    }
    /**
     * Focuses the context menu trigger.
     */
    focus() {
        this._element.nativeElement.focus();
    }
    /**
     * This method resets the context menu when it's closed, most importantly restoring
     * focus to the context menu trigger if the context menu was opened via the keyboard.
     */
    _resetContextMenu() {
        this._setIsContextMenuOpen(false);
        this.focus();
    }
    /** Set state rather than toggle to support triggers sharing a menu. */
    _setIsContextMenuOpen(isOpen) {
        this._contextMenuOpen = isOpen;
        this._contextMenuOpen ? this.contextMenuOpened.emit() : this.contextMenuClosed.emit();
        if (this.triggersSubmenu()) {
            this._contextMenuItemInstance._highlighted = isOpen;
        }
    }
    /**
     * This method checks that a valid instance of NxContextMenuComponent has been passed into
     * nxContextMenuTriggerFor. If not, an exception is thrown.
     */
    _checkContextMenu() {
        if (!this.contextMenu) {
            throwNxContextMenuMissingError();
        }
    }
    /**
     * This method creates the overlay from the provided menu's template and saves its
     * OverlayRef so that it can be attached to the DOM when openContextMenu is called.
     */
    _createOverlay() {
        if (!this._overlayRef) {
            const config = this._getOverlayConfig();
            this._overlayRef = this._overlay.create(config);
            // Consume the `keydownEvents` in order to prevent them from going to another overlay.
            this._overlayRef.keydownEvents().pipe(takeUntil(this._destroyed)).subscribe();
        }
        return this._overlayRef;
    }
    /**
     * This method builds the configuration object needed to create the overlay, the OverlayState.
     * @returns OverlayConfig
     */
    _getOverlayConfig() {
        return new OverlayConfig({
            positionStrategy: this._overlay
                .position()
                .flexibleConnectedTo(this._element)
                .withLockedPosition()
                .withFlexibleDimensions(false)
                .withTransformOriginOn('.nx-context-menu'),
            scrollStrategy: this._scrollStrategyFactory(),
            direction: this._dir ?? undefined,
        });
    }
    /**
     * Sets the position on a position strategy so the overlay is placed at the cursor.
     * @param positionStrategy Strategy whose position to update.
     * @param position Position of the cursor.
     */
    _setPositionToCursor(positionStrategy, cursorPosition) {
        positionStrategy.setOrigin(cursorPosition);
        positionStrategy.withPositions([
            {
                overlayX: 'start',
                overlayY: 'top',
                originX: 'center',
                originY: 'center',
            },
            {
                overlayX: 'start',
                overlayY: 'bottom',
                originX: 'center',
                originY: 'center',
            },
            {
                overlayX: 'end',
                overlayY: 'top',
                originX: 'center',
                originY: 'center',
            },
            {
                overlayX: 'end',
                overlayY: 'bottom',
                originX: 'center',
                originY: 'center',
            },
        ]);
    }
    /**
     * Sets the appropriate positions on a position strategy
     * so the overlay connects with the trigger correctly.
     * @param positionStrategy Strategy whose position to update.
     */
    _setPosition(positionStrategy) {
        let originX = 'start';
        let originFallbackX = 'end';
        const overlayY = 'top';
        const overlayFallbackY = 'bottom';
        let originY = overlayY;
        let originFallbackY = overlayFallbackY;
        let overlayX = originX;
        let overlayFallbackX = originFallbackX;
        let offsetX = 0;
        let offsetY = 0;
        if (this.triggersSubmenu()) {
            // When the menu is a sub-menu, it should always align itself
            // to the edges of the trigger, instead of overlapping it.
            overlayFallbackX = originX = 'end';
            originFallbackX = overlayX = 'start';
            offsetX = this.dir === 'rtl' ? -MENU_PANEL_OFFSET_X : MENU_PANEL_OFFSET_X;
            offsetY = -MENU_PANEL_TOP_PADDING;
        }
        else {
            offsetY = MENU_PANEL_OFFSET_Y;
            originY = 'bottom';
            originFallbackY = 'top';
        }
        positionStrategy.withPositions([
            { originX, originY, overlayX, overlayY, offsetX, offsetY },
            {
                originX: originFallbackX,
                originY,
                overlayX: overlayFallbackX,
                overlayY,
                offsetX: -offsetX,
                offsetY,
            },
            {
                originX,
                originY: originFallbackY,
                overlayX,
                overlayY: overlayFallbackY,
                offsetX,
                offsetY: -offsetY,
            },
            {
                originX: originFallbackX,
                originY: originFallbackY,
                overlayX: overlayFallbackX,
                overlayY: overlayFallbackY,
                offsetX: -offsetX,
                offsetY: -offsetY,
            },
        ]);
    }
    /**
     * Returns a stream that emits whenever an action that should close the context menu occurs. */
    _contextMenuClosingActions() {
        let backdrop;
        let detachments;
        if (this._overlayRef) {
            backdrop = this._overlayRef.backdropClick();
            detachments = this._overlayRef.detachments();
        }
        const parentClose = this._parentMenu ? this._parentMenu.closed : observableOf();
        const hover = this._parentMenu
            ? this._parentMenu._hovered().pipe(filter(active => active !== this._contextMenuItemInstance), filter(() => this._contextMenuOpen))
            : observableOf();
        return merge(backdrop, parentClose, hover, detachments);
    }
    /** Handles mouse presses on the trigger. */
    _handleMousedown(event) {
        // Since right or middle button clicks won't trigger the `click` event,
        // we shouldn't consider the menu as opened by mouse in those cases.
        // this._openedBy = event.button === 0 ? 'mouse' : null;
        // Since clicking on the trigger won't close the menu if it opens a sub-menu,
        // we should prevent focus from moving onto it via click to avoid the
        // highlight from lingering on the menu item.
        if (this.triggersSubmenu()) {
            event.preventDefault();
        }
    }
    _handleRightClick(event) {
        if (this.mode !== 'cursor') {
            return;
        }
        this._rightClicked = true;
        event.preventDefault();
        if (this._contextMenuOpen) {
            this.closeContextMenu();
        }
        const position = {
            x: event.clientX,
            y: event.clientY,
        };
        this.openContextMenu('mouse', position);
    }
    /** Handles key presses on the trigger. */
    _handleKeydown(event) {
        if (this.mode !== 'button') {
            return;
        }
        const keyCode = event.keyCode;
        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') || (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {
            this.openContextMenu('keyboard');
        }
    }
    /** Handles click events on the trigger. */
    _handleClick(event) {
        if (this.mode !== 'button') {
            return;
        }
        event.preventDefault();
        const origin = event.detail ? 'program' : 'keyboard';
        if (this.triggersSubmenu()) {
            // Stop event propagation to avoid closing the parent menu.
            event.stopPropagation();
            this.openContextMenu(origin);
        }
        else {
            this.toggleContextMenu(origin);
        }
    }
    /* Subscribes to document clicks to close the context menu on clicks on the background. */
    _waitForClose() {
        if (this._rightClicked) {
            return this._documentClickObservable
                .pipe(filter(event => !event.defaultPrevented), takeUntil(this.contextMenu.closed))
                .subscribe(() => {
                this.closeContextMenu();
            });
        }
        return this._documentClickObservable
            .pipe(map(event => _getEventTarget(event)), filter(target => !this._element.nativeElement.contains(target)), takeUntil(this.contextMenu.closed))
            .subscribe(() => {
            this.closeContextMenu();
        });
    }
    /** Handles the cases where the user hovers over the trigger. */
    _handleHover() {
        // Subscribe to changes in the hovered item in order to toggle the panel.
        if (!this.triggersSubmenu()) {
            return;
        }
        this._parentMenu._hovered()
            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu
            // with different data and triggers), we have to delay it by a tick to ensure that
            // it won't be closed immediately after it is opened.
            .pipe(filter(active => active === this._contextMenuItemInstance && !active.disabled), delay(0, asapScheduler), takeUntil(this._destroyed))
            .subscribe(() => {
            // If the same menu is used between multiple triggers, it might still be animating
            // while the new trigger tries to re-open it. Wait for the animation to finish
            // before doing so. Also interrupt if the user moves to another item.
            if (this.contextMenu._isAnimating) {
                // We need the `delay(0)` here in order to avoid
                // 'changed after checked' errors in some cases.
                this.contextMenu._animationDone
                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMenu._hovered()))
                    .subscribe(() => this.openContextMenu('mouse'));
            }
            else {
                this.openContextMenu('mouse');
            }
        });
    }
    /** Gets the portal that should be attached to the overlay. */
    _getPortal() {
        // Note that we can avoid this check by keeping the portal on the context menu panel.
        // While it would be cleaner, we'd have to introduce another required method on
        // `NxContextMenuPanelComponent`, making it harder to consume.
        if (!this._portal || this._portal.templateRef !== this.contextMenu.templateRef) {
            this._portal = new TemplatePortal(this.contextMenu.templateRef, this._viewContainerRef);
        }
        return this._portal;
    }
}
_NxContextMenuTriggerDirective_scrollStrategy = new WeakMap();
NxContextMenuTriggerDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuTriggerDirective, deps: [{ token: i1.Overlay }, { token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i2.NxContextMenuComponent, optional: true }, { token: i3.NxContextMenuItemComponent, optional: true, self: true }, { token: i4.Directionality, optional: true }, { token: i5.NxTriggerButton, optional: true, self: true }, { token: NX_CONTEXT_MENU_SCROLL_STRATEGY }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Directive });
NxContextMenuTriggerDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxContextMenuTriggerDirective, selector: "[nxContextMenuTriggerFor]", inputs: { contextMenu: ["nxContextMenuTriggerFor", "contextMenu"], scrollStrategy: "scrollStrategy", contextMenuData: ["nxContextMenuTriggerData", "contextMenuData"], mode: ["nxContextMenuTriggerMode", "mode"] }, outputs: { contextMenuOpened: "contextMenuOpened", contextMenuClosed: "contextMenuClosed" }, host: { attributes: { "aria-haspopup": "true" }, listeners: { "mousedown": "_handleMousedown($event)", "keydown": "_handleKeydown($event)", "click": "_handleClick($event)", "contextmenu": "_handleRightClick($event)" }, properties: { "attr.aria-expanded": "contextMenuOpen || null" } }, exportAs: ["nxContextMenuTrigger"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxContextMenuTriggerDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `[nxContextMenuTriggerFor]`,
                    host: {
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'contextMenuOpen || null',
                        '(mousedown)': '_handleMousedown($event)',
                        '(keydown)': '_handleKeydown($event)',
                        '(click)': '_handleClick($event)',
                        '(contextmenu)': '_handleRightClick($event)',
                    },
                    exportAs: 'nxContextMenuTrigger',
                }]
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i2.NxContextMenuComponent, decorators: [{
                    type: Optional
                }] }, { type: i3.NxContextMenuItemComponent, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: i4.Directionality, decorators: [{
                    type: Optional
                }] }, { type: i5.NxTriggerButton, decorators: [{
                    type: Optional
                }, {
                    type: Self
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NX_CONTEXT_MENU_SCROLL_STRATEGY]
                }] }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { contextMenu: [{
                type: Input,
                args: ['nxContextMenuTriggerFor']
            }], scrollStrategy: [{
                type: Input
            }], contextMenuData: [{
                type: Input,
                args: ['nxContextMenuTriggerData']
            }], mode: [{
                type: Input,
                args: ['nxContextMenuTriggerMode']
            }], contextMenuOpened: [{
                type: Output
            }], contextMenuClosed: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1tZW51LXRyaWdnZXIuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctYXF1aWxhL3NyYy9jb250ZXh0LW1lbnUvY29udGV4dC1tZW51LXRyaWdnZXIuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUNoRSxPQUFPLEVBQXdELE9BQU8sRUFBRSxhQUFhLEVBQThCLE1BQU0sc0JBQXNCLENBQUM7QUFDaEosT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3hELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNyRCxPQUFPLEVBR0gsU0FBUyxFQUVULFlBQVksRUFDWixNQUFNLEVBQ04sY0FBYyxFQUNkLEtBQUssRUFFTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLElBQUksR0FFUCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWMsRUFBRSxJQUFJLFlBQVksRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzlHLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFckUsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDbEUsT0FBTyxFQUFFLDhCQUE4QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7Ozs7QUFHdkUsNkNBQTZDO0FBQzdDLE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLENBQUMsQ0FBQztBQUV4QyxNQUFNLENBQUMsTUFBTSxtQkFBbUIsR0FBRyxDQUFDLENBQUM7QUFFckMsTUFBTSxDQUFDLE1BQU0sbUJB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QkFBd0I7d0JBQ3JDLFNBQVMsRUFBRSxzQkFBc0I7d0JBQ2pDLGVBQWUsRUFBRSwyQkFBMkI7cUJBQy9DO29CQUNELFFBQVEsRUFBRSxzQkFBc0I7aUJBQ25DOzswQkFzRlEsUUFBUTs7MEJBQ1IsUUFBUTs7MEJBQUksSUFBSTs7MEJBQ2hCLFFBQVE7OzBCQUNSLFFBQVE7OzBCQUFJLElBQUk7OzBCQUNoQixNQUFNOzJCQUFDLCtCQUErQjs0RUE1RXZDLFdBQVc7c0JBRGQsS0FBSzt1QkFBQyx5QkFBeUI7Z0JBMEI1QixjQUFjO3NCQURqQixLQUFLO2dCQXdCNkIsZUFBZTtzQkFBakQsS0FBSzt1QkFBQywwQkFBMEI7Z0JBUWpDLElBQUk7c0JBREgsS0FBSzt1QkFBQywwQkFBMEI7Z0JBSWQsaUJBQWlCO3NCQUFuQyxNQUFNO2dCQUdZLGlCQUFpQjtzQkFBbkMsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvY3VzT3JpZ2luIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgRGlyZWN0aW9uLCBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7IExFRlRfQVJST1csIFJJR0hUX0FSUk9XIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2tleWNvZGVzJztcbmltcG9ydCB7IENvbm5lY3RlZFBvc2l0aW9uLCBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3ksIE92ZXJsYXksIE92ZXJsYXlDb25maWcsIE92ZXJsYXlSZWYsIFNjcm9sbFN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgX2dldEV2ZW50VGFyZ2V0IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BsYXRmb3JtJztcbmltcG9ydCB7IFRlbXBsYXRlUG9ydGFsIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3BvcnRhbCc7XG5pbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgRGlyZWN0aXZlLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEluamVjdCxcbiAgICBJbmplY3Rpb25Ub2tlbixcbiAgICBJbnB1dCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFNlbGYsXG4gICAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOeFRyaWdnZXJCdXR0b24gfSBmcm9tICdAYXBvc2luL25nLWFxdWlsYS9vdmVybGF5JztcbmltcG9ydCB7IGFzYXBTY2hlZHVsZXIsIGZyb21FdmVudCwgbWVyZ2UsIE9ic2VydmFibGUsIG9mIGFzIG9ic2VydmFibGVPZiwgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWxheSwgZmlsdGVyLCBtYXAsIHRha2UsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnhDb250ZXh0TWVudUNvbXBvbmVudCB9IGZyb20gJy4vY29udGV4dC1tZW51LmNvbXBvbmVudCc7XG5pbXBvcnQgeyB0aHJvd054Q29udGV4dE1lbnVNaXNzaW5nRXJyb3IgfSBmcm9tICcuL2NvbnRleHQtbWVudS1lcnJvcnMnO1xuaW1wb3J0IHsgTnhDb250ZXh0TWVudUl0ZW1Db21wb25lbnQgfSBmcm9tICcuL2NvbnRleHQtbWVudS1pdGVtLmNvbXBvbmVudCc7XG5cbi8qKiBEZWZhdWx0IHRvcCBwYWRkaW5nIG9mIHRoZSBtZW51IHBhbmVsLiAqL1xuZXhwb3J0IGNvbnN0IE1FTlVfUEFORUxfVE9QX1BBRERJTkcgPSA4O1xuXG5leHBvcnQgY29uc3QgTUVOVV9QQU5FTF9PRkZTRVRfWSA9IDg7XG5cbmV4cG9ydCBjb25zdCBNRU5VX1BBTkVMX09GRlNFVF9YID0gODtcblxuZXhwb3J0IHR5cGUgTnhDb250ZXh0TWVudVNjcm9sbFN0cmF0ZWd5ID0gJ2Nsb3NlJyB8ICdyZXBvc2l0aW9uJztcblxuZXhwb3J0IHR5cGUgTnhDb250ZXh0TWVudU1vZGUgPSAnYnV0dG9uJyB8ICdjdXJzb3InO1xuXG4vKiogSW5qZWN0aW9uIHRva2VuIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2Nyb2xsIGhhbmRsaW5nIHdoaWxlIGEgY29udGV4dC1tZW51IGlzIG9wZW4uICovXG5leHBvcnQgY29uc3QgTlhfQ09OVEVYVF9NRU5VX1NDUk9MTF9TVFJBVEVHWSA9IG5ldyBJbmplY3Rpb25Ub2tlbjwoKSA9PiBTY3JvbGxTdHJhdGVneT4oJ254LWNvbnRleHQtbWVudS1zY3JvbGwtc3RyYXRlZ3knKTtcblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBOWF9DT05URVhUX01FTlVfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSX0ZBQ1RPUlkob3ZlcmxheTogT3ZlcmxheSk6ICgpID0+IFNjcm9sbFN0cmF0ZWd5IHtcbiAgICByZXR1cm4gKCkgPT4gb3ZlcmxheS5zY3JvbGxTdHJhdGVnaWVzLnJlcG9zaXRpb24oKTtcbn1cblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBjb25zdCBOWF9DT05URVhUX01FTlVfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IE5YX0NPTlRFWFRfTUVOVV9TQ1JPTExfU1RSQVRFR1ksXG4gICAgdXNlRmFjdG9yeTogTlhfQ09OVEVYVF9NRU5VX1NDUk9MTF9TVFJBVEVHWV9QUk9WSURFUl9GQUNUT1JZLFxuICAgIGRlcHM6IFtPdmVybGF5XSxcbn07XG5cbmludGVyZmFjZSBQb2ludCB7XG4gICAgeDogbnVtYmVyO1xuICAgIHk6IG51bWJlcjtcbn1cblxuLyoqXG4gKiBUaGlzIGRpcmVjdGl2ZSBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYW4gbngtY29udGV4dC1tZW51IHRhZy5cbiAqIEl0IGlzIHJlc3BvbnNpYmxlIGZvciB0b2dnbGluZyB0aGUgZGlzcGxheSBvZiB0aGUgcHJvdmlkZWQgY29udGV4dCBtZW51IGluc3RhbmNlLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogYFtueENvbnRleHRNZW51VHJpZ2dlckZvcl1gLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ2FyaWEtaGFzcG9wdXAnOiAndHJ1ZScsXG4gICAgICAgICdbYXR0ci5hcmlhLWV4cGFuZGVkXSc6ICdjb250ZXh0TWVudU9wZW4gfHwgbnVsbCcsXG4gICAgICAgICcobW91c2Vkb3duKSc6ICdfaGFuZGxlTW91c2Vkb3duKCRldmVudCknLFxuICAgICAgICAnKGtleWRvd24pJzogJ19oYW5kbGVLZXlkb3duKCRldmVudCknLFxuICAgICAgICAnKGNsaWNrKSc6ICdfaGFuZGxlQ2xpY2soJGV2ZW50KScsXG4gICAgICAgICcoY29udGV4dG1lbnUpJzogJ19oYW5kbGVSaWdodENsaWNrKCRldmVudCknLFxuICAgIH0sXG4gICAgZXhwb3J0QXM6ICdueENvbnRleHRNZW51VHJpZ2dlcicsXG59KVxuZXhwb3J0IGNsYXNzIE54Q29udGV4dE1lbnVUcmlnZ2VyRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJDb250ZW50SW5pdCwgT25EZXN0cm95IHtcbiAgICBwcml2YXRlIF9wb3J0YWwhOiBUZW1wbGF0ZVBvcnRhbDtcbiAgICBwcml2YXRlIF9vdmVybGF5UmVmOiBPdmVybGF5UmVmIHwgbnVsbCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfY29udGV4dE1lbnVPcGVuID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfY2xvc2luZ0FjdGlvbnNTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgcHJpdmF0ZSBfY29udGV4dE1lbnVDbG9zZVN1YnNjcmlwdGlvbiA9IFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICBwcml2YXRlIF9kb2N1bWVudENsaWNrT2JzZXJ2YWJsZTogT2JzZXJ2YWJsZTxNb3VzZUV2ZW50PjtcblxuICAgIC8qKiBTdHJhdGVneSBmYWN0b3J5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGhhbmRsZSBzY3JvbGxpbmcgd2hpbGUgdGhlIGNvbnRleHQtbWVudSBwYW5lbCBpcyBvcGVuLiAqL1xuICAgIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5RmFjdG9yeSA9IHRoaXMuX2RlZmF1bHRTY3JvbGxTdHJhdGVneUZhY3Rvcnk7XG5cbiAgICAvKiogUmVmZXJlbmNlcyB0aGUgY29udGV4dCBtZW51IGluc3RhbmNlIHRoYXQgdGhlIHRyaWdnZXIgaXMgYXNzb2NpYXRlZCB3aXRoLiAqL1xuICAgIEBJbnB1dCgnbnhDb250ZXh0TWVudVRyaWdnZXJGb3InKVxuICAgIGdldCBjb250ZXh0TWVudSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRNZW51O1xuICAgIH1cbiAgICBzZXQgY29udGV4dE1lbnUoY29udGV4dE1lbnU6IE54Q29udGV4dE1lbnVDb21wb25lbnQpIHtcbiAgICAgICAgaWYgKGNvbnRleHRNZW51ID09PSB0aGlzLl9jb250ZXh0TWVudSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY29udGV4dE1lbnUgPSBjb250ZXh0TWVudTtcbiAgICAgICAgdGhpcy5fY29udGV4dE1lbnVDbG9zZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXG4gICAgICAgIGlmIChjb250ZXh0TWVudSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dE1lbnVDbG9zZVN1YnNjcmlwdGlvbiA9IGNvbnRleHRNZW51LmNsb3NlZC5hc09ic2VydmFibGUoKS5zdWJzY3JpYmUocmVhc29uID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZXN0cm95TWVudSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgYSBjbGljayBjbG9zZWQgdGhlIG1lbnUsIHdlIHNob3VsZCBjbG9zZSB0aGUgZW50aXJlIGNoYWluIG9mIG5lc3RlZCBtZW51cy5cbiAgICAgICAgICAgICAgICBpZiAoKHJlYXNvbiA9PT0gJ2NsaWNrJyB8fCByZWFzb24gPT09ICd0YWInKSAmJiB0aGlzLl9wYXJlbnRNZW51KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmVudE1lbnUuY2xvc2VkLmVtaXQocmVhc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIF9jb250ZXh0TWVudSE6IE54Q29udGV4dE1lbnVDb21wb25lbnQ7XG5cbiAgICBASW5wdXQoKVxuICAgIHNldCBzY3JvbGxTdHJhdGVneSh2YWx1ZTogTnhDb250ZXh0TWVudVNjcm9sbFN0cmF0ZWd5IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy4jc2Nyb2xsU3RyYXRlZ3kgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLiNzY3JvbGxTdHJhdGVneSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsU3RyYXRlZ3lGYWN0b3J5ID0gdmFsdWUgPyB0aGlzLmdldFNjcm9sbFN0cnRlZ3lGYWN0b3J5KHZhbHVlKSA6IHRoaXMuX2RlZmF1bHRTY3JvbGxTdHJhdGVneUZhY3Rvcnk7XG4gICAgICAgICAgICB0aGlzLl9jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNjcm9sbFN0cmF0ZWd5KCk6IE54Q29udGV4dE1lbnVTY3JvbGxTdHJhdGVneSB8IG51bGwgfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2Nyb2xsU3RyYXRlZ3k7XG4gICAgfVxuICAgICNzY3JvbGxTdHJhdGVneT86IE54Q29udGV4dE1lbnVTY3JvbGxTdHJhdGVneSB8IG51bGw7XG5cbiAgICAvKiogV2hldGhlciB0aGUgY29udGV4dCBtZW51IGlzIG9wZW4uICovXG4gICAgZ2V0IGNvbnRleHRNZW51T3BlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHRNZW51T3BlbjtcbiAgICB9XG5cbiAgICAvKiogVGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC4gKi9cbiAgICBwcml2YXRlIGdldCBkaXIoKTogRGlyZWN0aW9uIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpcj8udmFsdWUgPT09ICdydGwnID8gJ3J0bCcgOiAnbHRyJztcbiAgICB9XG5cbiAgICAvKiogRGF0YSB0byBiZSBwYXNzZWQgYWxvbmcgdG8gYW55IGxhemlseS1yZW5kZXJlZCBjb250ZW50LiAqL1xuICAgIEBJbnB1dCgnbnhDb250ZXh0TWVudVRyaWdnZXJEYXRhJykgY29udGV4dE1lbnVEYXRhITogb2JqZWN0O1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbW9kZSBvZiB0aGlzIGNvbnRleHQgbWVudSB0cmlnZ2VyLlxuICAgICAqICdidXR0b24nIChkZWZhdWx0KTogT3BlbnMgYnkgY2xpY2tpbmcgdGhlIHRyaWdnZXJcbiAgICAgKiAnY3Vyc29yJzogT3BlbnMgYXQgdGhlIGN1cnNvciBwb3NpdGlvbiBieSByaWdodCBjbGlja2luZyBhbnl3aGVyZSBvbiB0aGUgdHJpZ2dlci5cbiAgICAgKi9cbiAgICBASW5wdXQoJ254Q29udGV4dE1lbnVUcmlnZ2VyTW9kZScpXG4gICAgbW9kZTogTnhDb250ZXh0TWVudU1vZGUgPSAnYnV0dG9uJztcblxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgY29udGV4dCBtZW51IGlzIG9wZW5lZC4gKi9cbiAgICBAT3V0cHV0KCkgcmVhZG9ubHkgY29udGV4dE1lbnVPcGVuZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBFdmVudCBlbWl0dGVkIHdoZW4gdGhlIGFzc29jaWF0ZWQgY29udGV4dCBtZW51IGlzIGNsb3NlZC4gKi9cbiAgICBAT3V0cHV0KCkgcmVhZG9ubHkgY29udGV4dE1lbnVDbG9zZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2Rlc3Ryb3llZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICBwcml2YXRlIF9yaWdodENsaWNrZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LFxuICAgICAgICBwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PixcbiAgICAgICAgcHJpdmF0ZSBfdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfcGFyZW50TWVudTogTnhDb250ZXh0TWVudUNvbXBvbmVudCB8IG51bGwsXG4gICAgICAgIEBPcHRpb25hbCgpIEBTZWxmKCkgcHJpdmF0ZSBfY29udGV4dE1lbnVJdGVtSW5zdGFuY2U6IE54Q29udGV4dE1lbnVJdGVtQ29tcG9uZW50IHwgbnVsbCxcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eSB8IG51bGwsXG4gICAgICAgIEBPcHRpb25hbCgpIEBTZWxmKCkgcHJpdmF0ZSBfdHJpZ2dlckJ1dHRvbjogTnhUcmlnZ2VyQnV0dG9uIHwgbnVsbCxcbiAgICAgICAgQEluamVjdChOWF9DT05URVhUX01FTlVfU0NST0xMX1NUUkFURUdZKSBwcml2YXRlIF9kZWZhdWx0U2Nyb2xsU3RyYXRlZ3lGYWN0b3J5OiAoKSA9PiBTY3JvbGxTdHJhdGVneSxcbiAgICAgICAgcHJpdmF0ZSBfY2RyOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICApIHtcbiAgICAgICAgaWYgKF9jb250ZXh0TWVudUl0ZW1JbnN0YW5jZSkge1xuICAgICAgICAgICAgX2NvbnRleHRNZW51SXRlbUluc3RhbmNlLl90cmlnZ2Vyc1N1Ym1lbnUgPSB0aGlzLnRyaWdnZXJzU3VibWVudSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RvY3VtZW50Q2xpY2tPYnNlcnZhYmxlID0gZnJvbUV2ZW50PE1vdXNlRXZlbnQ+KGRvY3VtZW50LCAnY2xpY2snKTtcblxuICAgICAgICB0aGlzLl9kaXI/LmNoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnVPcGVuKSB7XG4gICAgICAgICAgICAgICAgLy8gSElOVDogY2xvc2luZyBtZW51IG9uIGRpcmVjdGlvbiBjaGFuZ2UuXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB1c2VyIHJlLW9wZW5zIGl0LCB0aGUgb3ZlcmxheSBhbmQgbWVudSB3aWxsIGJlIGluaXRpYWxpemVkIHByb3Blcmx5LCBiYXNlZCBvbiBuZXcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VDb250ZXh0TWVudSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dE1lbnUoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlSG92ZXIoKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkLm5leHQoKTtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVkLmNvbXBsZXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb250ZXh0TWVudUNsb3NlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX2Nsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuXG4gICAgLyoqIFdoZXRoZXIgdGhlIGNvbnRleHQgbWVudSB0cmlnZ2VycyBhIHN1Yi1tZW51IG9yIGEgdG9wLWxldmVsIG9uZS4gKi9cbiAgICB0cmlnZ2Vyc1N1Ym1lbnUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLl9jb250ZXh0TWVudUl0ZW1JbnN0YW5jZSAmJiB0aGlzLl9wYXJlbnRNZW51KTtcbiAgICB9XG5cbiAgICAvKiogVG9nZ2xlcyB0aGUgY29udGV4dCBtZW51IGJldHdlZW4gdGhlIG9wZW4gYW5kIGNsb3NlZCBzdGF0ZXMuICovXG4gICAgdG9nZ2xlQ29udGV4dE1lbnUob3JpZ2luPzogRm9jdXNPcmlnaW4pOiB2b2lkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dE1lbnVPcGVuID8gdGhpcy5jbG9zZUNvbnRleHRNZW51KCkgOiB0aGlzLm9wZW5Db250ZXh0TWVudShvcmlnaW4pO1xuICAgIH1cblxuICAgIC8qKiBPcGVucyB0aGUgY29udGV4dCBtZW51LiAqL1xuICAgIG9wZW5Db250ZXh0TWVudShvcmlnaW4/OiBGb2N1c09yaWdpbiwgcG9zaXRpb24/OiBQb2ludCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5jb250ZXh0TWVudU9wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NoZWNrQ29udGV4dE1lbnUoKTtcblxuICAgICAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheSgpO1xuICAgICAgICBjb25zdCBvdmVybGF5Q29uZmlnID0gb3ZlcmxheVJlZi5nZXRDb25maWcoKTtcblxuICAgICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uVG9DdXJzb3Iob3ZlcmxheUNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSwgcG9zaXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0UG9zaXRpb24ob3ZlcmxheUNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5IGFzIEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSk7XG4gICAgICAgIH1cblxuICAgICAgICBvdmVybGF5UmVmLmF0dGFjaCh0aGlzLl9nZXRQb3J0YWwoKSk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnUubGF6eUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dE1lbnUubGF6eUNvbnRlbnQuYXR0YWNoKHRoaXMuY29udGV4dE1lbnVEYXRhKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2Nsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uID0gdGhpcy5fY29udGV4dE1lbnVDbG9zaW5nQWN0aW9ucygpLnN1YnNjcmliZSgoKSA9PiB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKSk7XG5cbiAgICAgICAgdGhpcy5faW5pdENvbnRleHRNZW51KG9yaWdpbik7XG5cbiAgICAgICAgaWYgKHRoaXMuY29udGV4dE1lbnUgaW5zdGFuY2VvZiBOeENvbnRleHRNZW51Q29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51Ll9zdGFydEFuaW1hdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3RyaWdnZXJCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMuX3RyaWdnZXJCdXR0b24uc2V0VHJpZ2dlckFjdGl2ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0TWVudS5jbG9zZWQucGlwZSh0YWtlKDEpKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fdHJpZ2dlckJ1dHRvbj8uc2V0VHJpZ2dlckluYWN0aXZlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2FpdEZvckNsb3NlKCk7XG4gICAgfVxuXG4gICAgLyoqIENsb3NlcyB0aGUgY29udGV4dCBtZW51LiAqL1xuICAgIGNsb3NlQ29udGV4dE1lbnUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3JpZ2h0Q2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51LmNsb3NlZC5lbWl0KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTY3JvbGxTdHJ0ZWd5RmFjdG9yeShzY3JvbGxTdHJhdGVneTogTnhDb250ZXh0TWVudVNjcm9sbFN0cmF0ZWd5KTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3kge1xuICAgICAgICBzd2l0Y2ggKHNjcm9sbFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjYXNlICdjbG9zZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5jbG9zZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuc2Nyb2xsU3RyYXRlZ2llcy5yZXBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIENsb3NlcyB0aGUgY29udGV4dCBtZW51IGFuZCBkb2VzIHRoZSBuZWNlc3NhcnkgY2xlYW51cC4gKi9cbiAgICBwcml2YXRlIF9kZXN0cm95TWVudSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5UmVmIHx8ICF0aGlzLmNvbnRleHRNZW51T3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY29udGV4dE1lbnUgPSB0aGlzLmNvbnRleHRNZW51O1xuXG4gICAgICAgIHRoaXMuX2Nsb3NpbmdBY3Rpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlSZWYuZGV0YWNoKCk7XG5cbiAgICAgICAgY29udGV4dE1lbnUuX3Jlc2V0QW5pbWF0aW9uKCk7XG5cbiAgICAgICAgaWYgKGNvbnRleHRNZW51LmxhenlDb250ZW50KSB7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgZXhpdCBhbmltYXRpb24gdG8gZmluaXNoIGJlZm9yZSBkZXRhY2hpbmcgdGhlIGNvbnRlbnQuXG4gICAgICAgICAgICBjb250ZXh0TWVudS5fYW5pbWF0aW9uRG9uZVxuICAgICAgICAgICAgICAgIC5waXBlKFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXIoZXZlbnQgPT4gZXZlbnQudG9TdGF0ZSA9PT0gJ3ZvaWQnKSxcbiAgICAgICAgICAgICAgICAgICAgdGFrZSgxKSxcbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJydXB0IGlmIHRoZSBjb250ZW50IGdvdCByZS1hdHRhY2hlZC5cbiAgICAgICAgICAgICAgICAgICAgdGFrZVVudGlsKGNvbnRleHRNZW51LmxhenlDb250ZW50Ll9hdHRhY2hlZCksXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoe1xuICAgICAgICAgICAgICAgICAgICBuZXh0OiAoKSA9PiBjb250ZXh0TWVudS5sYXp5Q29udGVudD8uZGV0YWNoKCksXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIG1hdHRlciB3aGV0aGVyIHRoZSBjb250ZW50IGdvdCByZS1hdHRhY2hlZCwgcmVzZXQgdGhlIG1lbnUuXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiAoKSA9PiB0aGlzLl9yZXNldENvbnRleHRNZW51KCksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldENvbnRleHRNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBjb250ZXh0IG1lbnUgc3RhdGUgdG8gb3BlbiBhbmQgZm9jdXNlcyB0aGUgZmlyc3QgaXRlbSBpZlxuICAgICAqIHRoZSBjb250ZXh0IG1lbnUgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2luaXRDb250ZXh0TWVudShvcmlnaW4/OiBGb2N1c09yaWdpbik6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51LnBhcmVudE1lbnUgPSB0aGlzLnRyaWdnZXJzU3VibWVudSgpID8gdGhpcy5fcGFyZW50TWVudSA/PyB1bmRlZmluZWQgOiB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY29udGV4dE1lbnUuZGlyZWN0aW9uID0gdGhpcy5kaXI7XG4gICAgICAgIHRoaXMuX3NldElzQ29udGV4dE1lbnVPcGVuKHRydWUpO1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51LmZvY3VzRmlyc3RJdGVtKG9yaWdpbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9jdXNlcyB0aGUgY29udGV4dCBtZW51IHRyaWdnZXIuXG4gICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2V0cyB0aGUgY29udGV4dCBtZW51IHdoZW4gaXQncyBjbG9zZWQsIG1vc3QgaW1wb3J0YW50bHkgcmVzdG9yaW5nXG4gICAgICogZm9jdXMgdG8gdGhlIGNvbnRleHQgbWVudSB0cmlnZ2VyIGlmIHRoZSBjb250ZXh0IG1lbnUgd2FzIG9wZW5lZCB2aWEgdGhlIGtleWJvYXJkLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3Jlc2V0Q29udGV4dE1lbnUoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX3NldElzQ29udGV4dE1lbnVPcGVuKGZhbHNlKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKiBTZXQgc3RhdGUgcmF0aGVyIHRoYW4gdG9nZ2xlIHRvIHN1cHBvcnQgdHJpZ2dlcnMgc2hhcmluZyBhIG1lbnUuICovXG4gICAgcHJpdmF0ZSBfc2V0SXNDb250ZXh0TWVudU9wZW4oaXNPcGVuOiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRNZW51T3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5fY29udGV4dE1lbnVPcGVuID8gdGhpcy5jb250ZXh0TWVudU9wZW5lZC5lbWl0KCkgOiB0aGlzLmNvbnRleHRNZW51Q2xvc2VkLmVtaXQoKTtcblxuICAgICAgICBpZiAodGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKSkge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dE1lbnVJdGVtSW5zdGFuY2UhLl9oaWdobGlnaHRlZCA9IGlzT3BlbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNoZWNrcyB0aGF0IGEgdmFsaWQgaW5zdGFuY2Ugb2YgTnhDb250ZXh0TWVudUNvbXBvbmVudCBoYXMgYmVlbiBwYXNzZWQgaW50b1xuICAgICAqIG54Q29udGV4dE1lbnVUcmlnZ2VyRm9yLiBJZiBub3QsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY2hlY2tDb250ZXh0TWVudSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHRNZW51KSB7XG4gICAgICAgICAgICB0aHJvd054Q29udGV4dE1lbnVNaXNzaW5nRXJyb3IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgdGhlIG92ZXJsYXkgZnJvbSB0aGUgcHJvdmlkZWQgbWVudSdzIHRlbXBsYXRlIGFuZCBzYXZlcyBpdHNcbiAgICAgKiBPdmVybGF5UmVmIHNvIHRoYXQgaXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBET00gd2hlbiBvcGVuQ29udGV4dE1lbnUgaXMgY2FsbGVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoKTogT3ZlcmxheVJlZiB7XG4gICAgICAgIGlmICghdGhpcy5fb3ZlcmxheVJlZikge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5fZ2V0T3ZlcmxheUNvbmZpZygpO1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheVJlZiA9IHRoaXMuX292ZXJsYXkuY3JlYXRlKGNvbmZpZyk7XG5cbiAgICAgICAgICAgIC8vIENvbnN1bWUgdGhlIGBrZXlkb3duRXZlbnRzYCBpbiBvcmRlciB0byBwcmV2ZW50IHRoZW0gZnJvbSBnb2luZyB0byBhbm90aGVyIG92ZXJsYXkuXG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5UmVmLmtleWRvd25FdmVudHMoKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpKS5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5UmVmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGJ1aWxkcyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgb3ZlcmxheSwgdGhlIE92ZXJsYXlTdGF0ZS5cbiAgICAgKiBAcmV0dXJucyBPdmVybGF5Q29uZmlnXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0T3ZlcmxheUNvbmZpZygpOiBPdmVybGF5Q29uZmlnIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMuX292ZXJsYXlcbiAgICAgICAgICAgICAgICAucG9zaXRpb24oKVxuICAgICAgICAgICAgICAgIC5mbGV4aWJsZUNvbm5lY3RlZFRvKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgICAgICAgICAgLndpdGhMb2NrZWRQb3NpdGlvbigpXG4gICAgICAgICAgICAgICAgLndpdGhGbGV4aWJsZURpbWVuc2lvbnMoZmFsc2UpXG4gICAgICAgICAgICAgICAgLndpdGhUcmFuc2Zvcm1PcmlnaW5PbignLm54LWNvbnRleHQtbWVudScpLFxuICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IHRoaXMuX3Njcm9sbFN0cmF0ZWd5RmFjdG9yeSgpLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9kaXIgPz8gdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiBvbiBhIHBvc2l0aW9uIHN0cmF0ZWd5IHNvIHRoZSBvdmVybGF5IGlzIHBsYWNlZCBhdCB0aGUgY3Vyc29yLlxuICAgICAqIEBwYXJhbSBwb3NpdGlvblN0cmF0ZWd5IFN0cmF0ZWd5IHdob3NlIHBvc2l0aW9uIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gUG9zaXRpb24gb2YgdGhlIGN1cnNvci5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9zZXRQb3NpdGlvblRvQ3Vyc29yKHBvc2l0aW9uU3RyYXRlZ3k6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSwgY3Vyc29yUG9zaXRpb246IFBvaW50KSB7XG4gICAgICAgIHBvc2l0aW9uU3RyYXRlZ3kuc2V0T3JpZ2luKGN1cnNvclBvc2l0aW9uKTtcbiAgICAgICAgcG9zaXRpb25TdHJhdGVneS53aXRoUG9zaXRpb25zKFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvdmVybGF5WDogJ3N0YXJ0JyxcbiAgICAgICAgICAgICAgICBvdmVybGF5WTogJ3RvcCcsXG4gICAgICAgICAgICAgICAgb3JpZ2luWDogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgb3JpZ2luWTogJ2NlbnRlcicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG92ZXJsYXlYOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlZOiAndG9wJyxcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3ZlcmxheVg6ICdlbmQnLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlZOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBvcmlnaW5ZOiAnY2VudGVyJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFwcHJvcHJpYXRlIHBvc2l0aW9ucyBvbiBhIHBvc2l0aW9uIHN0cmF0ZWd5XG4gICAgICogc28gdGhlIG92ZXJsYXkgY29ubmVjdHMgd2l0aCB0aGUgdHJpZ2dlciBjb3JyZWN0bHkuXG4gICAgICogQHBhcmFtIHBvc2l0aW9uU3RyYXRlZ3kgU3RyYXRlZ3kgd2hvc2UgcG9zaXRpb24gdG8gdXBkYXRlLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3NldFBvc2l0aW9uKHBvc2l0aW9uU3RyYXRlZ3k6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneSkge1xuICAgICAgICBsZXQgb3JpZ2luWCA9ICdzdGFydCc7XG4gICAgICAgIGxldCBvcmlnaW5GYWxsYmFja1ggPSAnZW5kJztcbiAgICAgICAgY29uc3Qgb3ZlcmxheVkgPSAndG9wJztcbiAgICAgICAgY29uc3Qgb3ZlcmxheUZhbGxiYWNrWSA9ICdib3R0b20nO1xuICAgICAgICBsZXQgb3JpZ2luWSA9IG92ZXJsYXlZO1xuICAgICAgICBsZXQgb3JpZ2luRmFsbGJhY2tZID0gb3ZlcmxheUZhbGxiYWNrWTtcbiAgICAgICAgbGV0IG92ZXJsYXlYID0gb3JpZ2luWDtcbiAgICAgICAgbGV0IG92ZXJsYXlGYWxsYmFja1ggPSBvcmlnaW5GYWxsYmFja1g7XG4gICAgICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICAgICAgbGV0IG9mZnNldFkgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJzU3VibWVudSgpKSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBtZW51IGlzIGEgc3ViLW1lbnUsIGl0IHNob3VsZCBhbHdheXMgYWxpZ24gaXRzZWxmXG4gICAgICAgICAgICAvLyB0byB0aGUgZWRnZXMgb2YgdGhlIHRyaWdnZXIsIGluc3RlYWQgb2Ygb3ZlcmxhcHBpbmcgaXQuXG4gICAgICAgICAgICBvdmVybGF5RmFsbGJhY2tYID0gb3JpZ2luWCA9ICdlbmQnO1xuICAgICAgICAgICAgb3JpZ2luRmFsbGJhY2tYID0gb3ZlcmxheVggPSAnc3RhcnQnO1xuICAgICAgICAgICAgb2Zmc2V0WCA9IHRoaXMuZGlyID09PSAncnRsJyA/IC1NRU5VX1BBTkVMX09GRlNFVF9YIDogTUVOVV9QQU5FTF9PRkZTRVRfWDtcbiAgICAgICAgICAgIG9mZnNldFkgPSAtTUVOVV9QQU5FTF9UT1BfUEFERElORztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldFkgPSBNRU5VX1BBTkVMX09GRlNFVF9ZO1xuICAgICAgICAgICAgb3JpZ2luWSA9ICdib3R0b20nO1xuICAgICAgICAgICAgb3JpZ2luRmFsbGJhY2tZID0gJ3RvcCc7XG4gICAgICAgIH1cblxuICAgICAgICBwb3NpdGlvblN0cmF0ZWd5LndpdGhQb3NpdGlvbnMoW1xuICAgICAgICAgICAgeyBvcmlnaW5YLCBvcmlnaW5ZLCBvdmVybGF5WCwgb3ZlcmxheVksIG9mZnNldFgsIG9mZnNldFkgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiBvcmlnaW5GYWxsYmFja1gsXG4gICAgICAgICAgICAgICAgb3JpZ2luWSxcbiAgICAgICAgICAgICAgICBvdmVybGF5WDogb3ZlcmxheUZhbGxiYWNrWCxcbiAgICAgICAgICAgICAgICBvdmVybGF5WSxcbiAgICAgICAgICAgICAgICBvZmZzZXRYOiAtb2Zmc2V0WCxcbiAgICAgICAgICAgICAgICBvZmZzZXRZLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5YLFxuICAgICAgICAgICAgICAgIG9yaWdpblk6IG9yaWdpbkZhbGxiYWNrWSxcbiAgICAgICAgICAgICAgICBvdmVybGF5WCxcbiAgICAgICAgICAgICAgICBvdmVybGF5WTogb3ZlcmxheUZhbGxiYWNrWSxcbiAgICAgICAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgICAgICAgIG9mZnNldFk6IC1vZmZzZXRZLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5YOiBvcmlnaW5GYWxsYmFja1gsXG4gICAgICAgICAgICAgICAgb3JpZ2luWTogb3JpZ2luRmFsbGJhY2tZLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlYOiBvdmVybGF5RmFsbGJhY2tYLFxuICAgICAgICAgICAgICAgIG92ZXJsYXlZOiBvdmVybGF5RmFsbGJhY2tZLFxuICAgICAgICAgICAgICAgIG9mZnNldFg6IC1vZmZzZXRYLFxuICAgICAgICAgICAgICAgIG9mZnNldFk6IC1vZmZzZXRZLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSBhcyBDb25uZWN0ZWRQb3NpdGlvbltdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyZWFtIHRoYXQgZW1pdHMgd2hlbmV2ZXIgYW4gYWN0aW9uIHRoYXQgc2hvdWxkIGNsb3NlIHRoZSBjb250ZXh0IG1lbnUgb2NjdXJzLiAqL1xuICAgIHByaXZhdGUgX2NvbnRleHRNZW51Q2xvc2luZ0FjdGlvbnMoKSB7XG4gICAgICAgIGxldCBiYWNrZHJvcDogT2JzZXJ2YWJsZTxNb3VzZUV2ZW50PjtcbiAgICAgICAgbGV0IGRldGFjaG1lbnRzOiBPYnNlcnZhYmxlPHZvaWQ+O1xuXG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5UmVmKSB7XG4gICAgICAgICAgICBiYWNrZHJvcCA9IHRoaXMuX292ZXJsYXlSZWYuYmFja2Ryb3BDbGljaygpO1xuICAgICAgICAgICAgZGV0YWNobWVudHMgPSB0aGlzLl9vdmVybGF5UmVmLmRldGFjaG1lbnRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJlbnRDbG9zZSA9IHRoaXMuX3BhcmVudE1lbnUgPyB0aGlzLl9wYXJlbnRNZW51LmNsb3NlZCA6IG9ic2VydmFibGVPZigpO1xuXG4gICAgICAgIGNvbnN0IGhvdmVyID0gdGhpcy5fcGFyZW50TWVudVxuICAgICAgICAgICAgPyB0aGlzLl9wYXJlbnRNZW51Ll9ob3ZlcmVkKCkucGlwZShcbiAgICAgICAgICAgICAgICAgIGZpbHRlcihhY3RpdmUgPT4gYWN0aXZlICE9PSB0aGlzLl9jb250ZXh0TWVudUl0ZW1JbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5fY29udGV4dE1lbnVPcGVuKSxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBvYnNlcnZhYmxlT2YoKTtcblxuICAgICAgICByZXR1cm4gbWVyZ2UoYmFja2Ryb3AhLCBwYXJlbnRDbG9zZSwgaG92ZXIsIGRldGFjaG1lbnRzISk7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZXMgbW91c2UgcHJlc3NlcyBvbiB0aGUgdHJpZ2dlci4gKi9cbiAgICBfaGFuZGxlTW91c2Vkb3duKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIC8vIFNpbmNlIHJpZ2h0IG9yIG1pZGRsZSBidXR0b24gY2xpY2tzIHdvbid0IHRyaWdnZXIgdGhlIGBjbGlja2AgZXZlbnQsXG4gICAgICAgIC8vIHdlIHNob3VsZG4ndCBjb25zaWRlciB0aGUgbWVudSBhcyBvcGVuZWQgYnkgbW91c2UgaW4gdGhvc2UgY2FzZXMuXG4gICAgICAgIC8vIHRoaXMuX29wZW5lZEJ5ID0gZXZlbnQuYnV0dG9uID09PSAwID8gJ21vdXNlJyA6IG51bGw7XG5cbiAgICAgICAgLy8gU2luY2UgY2xpY2tpbmcgb24gdGhlIHRyaWdnZXIgd29uJ3QgY2xvc2UgdGhlIG1lbnUgaWYgaXQgb3BlbnMgYSBzdWItbWVudSxcbiAgICAgICAgLy8gd2Ugc2hvdWxkIHByZXZlbnQgZm9jdXMgZnJvbSBtb3Zpbmcgb250byBpdCB2aWEgY2xpY2sgdG8gYXZvaWQgdGhlXG4gICAgICAgIC8vIGhpZ2hsaWdodCBmcm9tIGxpbmdlcmluZyBvbiB0aGUgbWVudSBpdGVtLlxuICAgICAgICBpZiAodGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9oYW5kbGVSaWdodENsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09ICdjdXJzb3InKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmlnaHRDbGlja2VkID0gdHJ1ZTtcblxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAodGhpcy5fY29udGV4dE1lbnVPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICB5OiBldmVudC5jbGllbnRZLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wZW5Db250ZXh0TWVudSgnbW91c2UnLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqIEhhbmRsZXMga2V5IHByZXNzZXMgb24gdGhlIHRyaWdnZXIuICovXG4gICAgX2hhbmRsZUtleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZSAhPT0gJ2J1dHRvbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuXG4gICAgICAgIGlmICh0aGlzLnRyaWdnZXJzU3VibWVudSgpICYmICgoa2V5Q29kZSA9PT0gUklHSFRfQVJST1cgJiYgdGhpcy5kaXIgPT09ICdsdHInKSB8fCAoa2V5Q29kZSA9PT0gTEVGVF9BUlJPVyAmJiB0aGlzLmRpciA9PT0gJ3J0bCcpKSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnUoJ2tleWJvYXJkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogSGFuZGxlcyBjbGljayBldmVudHMgb24gdGhlIHRyaWdnZXIuICovXG4gICAgX2hhbmRsZUNsaWNrKGV2ZW50OiBNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgIT09ICdidXR0b24nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBvcmlnaW46IEZvY3VzT3JpZ2luID0gZXZlbnQuZGV0YWlsID8gJ3Byb2dyYW0nIDogJ2tleWJvYXJkJztcblxuICAgICAgICBpZiAodGhpcy50cmlnZ2Vyc1N1Ym1lbnUoKSkge1xuICAgICAgICAgICAgLy8gU3RvcCBldmVudCBwcm9wYWdhdGlvbiB0byBhdm9pZCBjbG9zaW5nIHRoZSBwYXJlbnQgbWVudS5cbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnUob3JpZ2luKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlQ29udGV4dE1lbnUob3JpZ2luKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIFN1YnNjcmliZXMgdG8gZG9jdW1lbnQgY2xpY2tzIHRvIGNsb3NlIHRoZSBjb250ZXh0IG1lbnUgb24gY2xpY2tzIG9uIHRoZSBiYWNrZ3JvdW5kLiAqL1xuICAgIHByaXZhdGUgX3dhaXRGb3JDbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JpZ2h0Q2xpY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvY3VtZW50Q2xpY2tPYnNlcnZhYmxlXG4gICAgICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcihldmVudCA9PiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZCksXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLmNvbnRleHRNZW51LmNsb3NlZCksXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlQ29udGV4dE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudENsaWNrT2JzZXJ2YWJsZVxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgbWFwKGV2ZW50ID0+IF9nZXRFdmVudFRhcmdldChldmVudCkpLFxuICAgICAgICAgICAgICAgIGZpbHRlcih0YXJnZXQgPT4gIXRoaXMuX2VsZW1lbnQubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQgYXMgTm9kZSB8IG51bGwpKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5jb250ZXh0TWVudS5jbG9zZWQpLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUNvbnRleHRNZW51KCk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogSGFuZGxlcyB0aGUgY2FzZXMgd2hlcmUgdGhlIHVzZXIgaG92ZXJzIG92ZXIgdGhlIHRyaWdnZXIuICovXG4gICAgcHJpdmF0ZSBfaGFuZGxlSG92ZXIoKSB7XG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBjaGFuZ2VzIGluIHRoZSBob3ZlcmVkIGl0ZW0gaW4gb3JkZXIgdG8gdG9nZ2xlIHRoZSBwYW5lbC5cbiAgICAgICAgaWYgKCF0aGlzLnRyaWdnZXJzU3VibWVudSgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wYXJlbnRNZW51IS5faG92ZXJlZCgpXG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBtaWdodCBoYXZlIG11bHRpcGxlIGNvbXBldGluZyB0cmlnZ2VycyBmb3IgdGhlIHNhbWUgbWVudSAoZS5nLiBhIHN1Yi1tZW51XG4gICAgICAgICAgICAvLyB3aXRoIGRpZmZlcmVudCBkYXRhIGFuZCB0cmlnZ2VycyksIHdlIGhhdmUgdG8gZGVsYXkgaXQgYnkgYSB0aWNrIHRvIGVuc3VyZSB0aGF0XG4gICAgICAgICAgICAvLyBpdCB3b24ndCBiZSBjbG9zZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgb3BlbmVkLlxuICAgICAgICAgICAgLnBpcGUoXG4gICAgICAgICAgICAgICAgZmlsdGVyKGFjdGl2ZSA9PiBhY3RpdmUgPT09IHRoaXMuX2NvbnRleHRNZW51SXRlbUluc3RhbmNlICYmICFhY3RpdmUuZGlzYWJsZWQpLFxuICAgICAgICAgICAgICAgIGRlbGF5KDAsIGFzYXBTY2hlZHVsZXIpLFxuICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95ZWQpLCAvLyBUT0RPIHRoaXMgbWF5IG5vdCBiZSBzdWZmaWNpZW50LCBzdWJzY3JpcHRpb25zIG1heSBiZSBwaWxpbmcgdXBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBzYW1lIG1lbnUgaXMgdXNlZCBiZXR3ZWVuIG11bHRpcGxlIHRyaWdnZXJzLCBpdCBtaWdodCBzdGlsbCBiZSBhbmltYXRpbmdcbiAgICAgICAgICAgICAgICAvLyB3aGlsZSB0aGUgbmV3IHRyaWdnZXIgdHJpZXMgdG8gcmUtb3BlbiBpdC4gV2FpdCBmb3IgdGhlIGFuaW1hdGlvbiB0byBmaW5pc2hcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgZG9pbmcgc28uIEFsc28gaW50ZXJydXB0IGlmIHRoZSB1c2VyIG1vdmVzIHRvIGFub3RoZXIgaXRlbS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0TWVudS5faXNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0aGUgYGRlbGF5KDApYCBoZXJlIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgIC8vICdjaGFuZ2VkIGFmdGVyIGNoZWNrZWQnIGVycm9ycyBpbiBzb21lIGNhc2VzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51Ll9hbmltYXRpb25Eb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAucGlwZSh0YWtlKDEpLCBkZWxheSgwLCBhc2FwU2NoZWR1bGVyKSwgdGFrZVVudGlsKHRoaXMuX3BhcmVudE1lbnUhLl9ob3ZlcmVkKCkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLm9wZW5Db250ZXh0TWVudSgnbW91c2UnKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuQ29udGV4dE1lbnUoJ21vdXNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEdldHMgdGhlIHBvcnRhbCB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byB0aGUgb3ZlcmxheS4gKi9cbiAgICBwcml2YXRlIF9nZXRQb3J0YWwoKTogVGVtcGxhdGVQb3J0YWwge1xuICAgICAgICAvLyBOb3RlIHRoYXQgd2UgY2FuIGF2b2lkIHRoaXMgY2hlY2sgYnkga2VlcGluZyB0aGUgcG9ydGFsIG9uIHRoZSBjb250ZXh0IG1lbnUgcGFuZWwuXG4gICAgICAgIC8vIFdoaWxlIGl0IHdvdWxkIGJlIGNsZWFuZXIsIHdlJ2QgaGF2ZSB0byBpbnRyb2R1Y2UgYW5vdGhlciByZXF1aXJlZCBtZXRob2Qgb25cbiAgICAgICAgLy8gYE54Q29udGV4dE1lbnVQYW5lbENvbXBvbmVudGAsIG1ha2luZyBpdCBoYXJkZXIgdG8gY29uc3VtZS5cbiAgICAgICAgaWYgKCF0aGlzLl9wb3J0YWwgfHwgdGhpcy5fcG9ydGFsLnRlbXBsYXRlUmVmICE9PSB0aGlzLmNvbnRleHRNZW51LnRlbXBsYXRlUmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9wb3J0YWwgPSBuZXcgVGVtcGxhdGVQb3J0YWwodGhpcy5jb250ZXh0TWVudS50ZW1wbGF0ZVJlZiwgdGhpcy5fdmlld0NvbnRhaW5lclJlZik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydGFsO1xuICAgIH1cbn1cbiJdfQ==