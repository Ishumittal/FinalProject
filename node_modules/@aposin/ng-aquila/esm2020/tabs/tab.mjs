import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, Component, ContentChild, Host, Inject, Input, Optional, TemplateRef, ViewChild, } from '@angular/core';
import { Subject } from 'rxjs';
import { NxTabContentDirective } from './tab-content';
import { NxTabGroupBase } from './tab-group-base';
import { NxTabLabelDirective } from './tab-label';
import * as i0 from "@angular/core";
import * as i1 from "./tab-group-base";
export class NxTabComponent {
    constructor(_tabGroup) {
        this._tabGroup = _tabGroup;
        this._disabled = false;
        /** Emits whenever the internal state of the tab changes. */
        this._stateChanges = new Subject();
        /**
         * Whether the tab is currently active.
         */
        this.isActive = false;
        if (!this._tabGroup) {
            throw Error(`The nx-tab element has to be wrapped in a nx-tab-group to work.
      Please provide a nx-tab-group element and place your tabs inside it.`);
        }
    }
    /**
     * Content for the tab label given by `<ng-template nxTabLabel>`.
     * @docs-private
     * */
    get templateLabel() {
        return this._templateLabel;
    }
    set templateLabel(value) {
        // Only update the templateLabel via query if there is actually
        // a nxTabLabel found. This works around an issue where a user may have
        // manually set `templateLabel` during creation mode, which would then get clobbered
        // by `undefined` when this query resolves.
        if (value) {
            this._templateLabel = value;
        }
    }
    /** Sets the label of the tab shown in the tablist. */
    get label() {
        return this._label;
    }
    set label(value) {
        if (this._label !== value) {
            this._label = value;
        }
    }
    /** Sets the tab to disabled. */
    get disabled() {
        return this._tabGroup?.disabled || this._disabled;
    }
    set disabled(value) {
        const coercedValue = coerceBooleanProperty(value);
        if (this._disabled !== coercedValue) {
            this._disabled = coercedValue;
        }
    }
    /** @docs-private */
    get headerViewRef() {
        return this._headerViewRef;
    }
    /** @docs-private */
    get contentViewRef() {
        // for lazy loading we only create the viewref when it is asked for
        if (!this._contentViewRef) {
            const contentTemplate = this._explicitContent || this._implicitContent;
            this._contentViewRef = contentTemplate.createEmbeddedView({});
        }
        return this._contentViewRef;
    }
    ngOnChanges(changes) {
        if ({}.hasOwnProperty.call(changes, 'label') || {}.hasOwnProperty.call(changes, 'disabled')) {
            this._stateChanges.next();
        }
    }
    ngAfterContentInit() {
        if (this.templateLabel) {
            this._headerViewRef = this.templateLabel.createEmbeddedView({});
        }
    }
    ngOnDestroy() {
        this._stateChanges.complete();
        this._contentViewRef.destroy();
        if (this._headerViewRef) {
            this._headerViewRef.destroy();
        }
    }
}
NxTabComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabComponent, deps: [{ token: NxTabGroupBase, host: true, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxTabComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTabComponent, selector: "nx-tab", inputs: { label: "label", disabled: "disabled" }, queries: [{ propertyName: "templateLabel", first: true, predicate: NxTabLabelDirective, descendants: true, read: TemplateRef, static: true }, { propertyName: "_explicitContent", first: true, predicate: NxTabContentDirective, descendants: true, read: TemplateRef, static: true }], viewQueries: [{ propertyName: "_implicitContent", first: true, predicate: TemplateRef, descendants: true, static: true }], exportAs: ["nxTab"], usesOnChanges: true, ngImport: i0, template: "<ng-template><ng-content></ng-content></ng-template>\n", changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTabComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-tab', exportAs: 'nxTab', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-template><ng-content></ng-content></ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1.NxTabGroupBase, decorators: [{
                    type: Inject,
                    args: [NxTabGroupBase]
                }, {
                    type: Optional
                }, {
                    type: Host
                }] }]; }, propDecorators: { templateLabel: [{
                type: ContentChild,
                args: [NxTabLabelDirective, { read: TemplateRef, static: true }]
            }], _implicitContent: [{
                type: ViewChild,
                args: [TemplateRef, { static: true }]
            }], _explicitContent: [{
                type: ContentChild,
                args: [NxTabContentDirective, { read: TemplateRef, static: true }]
            }], label: [{
                type: Input
            }], disabled: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctYXF1aWxhL3NyYy90YWJzL3RhYi50cyIsIi4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWFxdWlsYS9zcmMvdGFicy90YWIuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWdCLHFCQUFxQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDNUUsT0FBTyxFQUVILHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsWUFBWSxFQUVaLElBQUksRUFDSixNQUFNLEVBQ04sS0FBSyxFQUdMLFFBQVEsRUFFUixXQUFXLEVBQ1gsU0FBUyxHQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFL0IsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxhQUFhLENBQUM7OztBQVFsRCxNQUFNLE9BQU8sY0FBYztJQWtGdkIsWUFBZ0UsU0FBZ0M7UUFBaEMsY0FBUyxHQUFULFNBQVMsQ0FBdUI7UUFoRnhGLGNBQVMsR0FBRyxLQUFLLENBQUM7UUFFMUIsNERBQTREO1FBQ25ELGtCQUFhLEdBQUcsSUFBSSxPQUFPLEVBQVEsQ0FBQztRQXdFN0M7O1dBRUc7UUFDSCxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBR2IsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUU7WUFDakIsTUFBTSxLQUFLLENBQUM7MkVBQ21ELENBQUMsQ0FBQztTQUNwRTtJQUNMLENBQUM7SUFoRkQ7OztTQUdLO0lBQ0wsSUFDSSxhQUFhO1FBQ2IsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDO0lBQy9CLENBQUM7SUFDRCxJQUFJLGFBQWEsQ0FBQyxLQUF1QjtRQUNyQywrREFBK0Q7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WUFBWTt1QkFBQyxxQkFBcUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFLcEUsS0FBSztzQkFEUixLQUFLO2dCQVlGLFFBQVE7c0JBRFgsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJvb2xlYW5JbnB1dCwgY29lcmNlQm9vbGVhblByb3BlcnR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvZXJjaW9uJztcbmltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVtYmVkZGVkVmlld1JlZixcbiAgICBIb3N0LFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPbkNoYW5nZXMsXG4gICAgT25EZXN0cm95LFxuICAgIE9wdGlvbmFsLFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHsgTnhUYWJDb250ZW50RGlyZWN0aXZlIH0gZnJvbSAnLi90YWItY29udGVudCc7XG5pbXBvcnQgeyBOeFRhYkdyb3VwQmFzZSB9IGZyb20gJy4vdGFiLWdyb3VwLWJhc2UnO1xuaW1wb3J0IHsgTnhUYWJMYWJlbERpcmVjdGl2ZSB9IGZyb20gJy4vdGFiLWxhYmVsJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdueC10YWInLFxuICAgIGV4cG9ydEFzOiAnbnhUYWInLFxuICAgIHRlbXBsYXRlVXJsOiAndGFiLmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBOeFRhYkNvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95LCBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwcml2YXRlIF9sYWJlbCE6IHN0cmluZztcbiAgICBwcml2YXRlIF9kaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqIEVtaXRzIHdoZW5ldmVyIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgdGFiIGNoYW5nZXMuICovXG4gICAgcmVhZG9ubHkgX3N0YXRlQ2hhbmdlcyA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBDb250ZW50IGZvciB0aGUgdGFiIGxhYmVsIGdpdmVuIGJ5IGA8bmctdGVtcGxhdGUgbnhUYWJMYWJlbD5gLlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKiAqL1xuICAgIEBDb250ZW50Q2hpbGQoTnhUYWJMYWJlbERpcmVjdGl2ZSwgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgZ2V0IHRlbXBsYXRlTGFiZWwoKTogVGVtcGxhdGVSZWY8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZUxhYmVsO1xuICAgIH1cbiAgICBzZXQgdGVtcGxhdGVMYWJlbCh2YWx1ZTogVGVtcGxhdGVSZWY8YW55Pikge1xuICAgICAgICAvLyBPbmx5IHVwZGF0ZSB0aGUgdGVtcGxhdGVMYWJlbCB2aWEgcXVlcnkgaWYgdGhlcmUgaXMgYWN0dWFsbHlcbiAgICAgICAgLy8gYSBueFRhYkxhYmVsIGZvdW5kLiBUaGlzIHdvcmtzIGFyb3VuZCBhbiBpc3N1ZSB3aGVyZSBhIHVzZXIgbWF5IGhhdmVcbiAgICAgICAgLy8gbWFudWFsbHkgc2V0IGB0ZW1wbGF0ZUxhYmVsYCBkdXJpbmcgY3JlYXRpb24gbW9kZSwgd2hpY2ggd291bGQgdGhlbiBnZXQgY2xvYmJlcmVkXG4gICAgICAgIC8vIGJ5IGB1bmRlZmluZWRgIHdoZW4gdGhpcyBxdWVyeSByZXNvbHZlcy5cbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZUxhYmVsID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF90ZW1wbGF0ZUxhYmVsITogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKiBUZW1wbGF0ZSBpbnNpZGUgdGhlIE54VGFiIHZpZXcgdGhhdCBjb250YWlucyBhbiBgPG5nLWNvbnRlbnQ+YC4gKi9cbiAgICBAVmlld0NoaWxkKFRlbXBsYXRlUmVmLCB7IHN0YXRpYzogdHJ1ZSB9KSBfaW1wbGljaXRDb250ZW50ITogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBUZW1wbGF0ZSBwcm92aWRlZCBpbiB0aGUgdGFiIGNvbnRlbnQgdGhhdCB3aWxsIGJlIHVzZWQgaWYgcHJlc2VudCwgdXNlZCB0byBlbmFibGUgbGF6eS1sb2FkaW5nXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChOeFRhYkNvbnRlbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KVxuICAgIF9leHBsaWNpdENvbnRlbnQhOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqIFNldHMgdGhlIGxhYmVsIG9mIHRoZSB0YWIgc2hvd24gaW4gdGhlIHRhYmxpc3QuICovXG4gICAgQElucHV0KClcbiAgICBnZXQgbGFiZWwoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVsO1xuICAgIH1cbiAgICBzZXQgbGFiZWwodmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWwgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFNldHMgdGhlIHRhYiB0byBkaXNhYmxlZC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhYkdyb3VwPy5kaXNhYmxlZCB8fCB0aGlzLl9kaXNhYmxlZDtcbiAgICB9XG4gICAgc2V0IGRpc2FibGVkKHZhbHVlOiBCb29sZWFuSW5wdXQpIHtcbiAgICAgICAgY29uc3QgY29lcmNlZFZhbHVlID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcblxuICAgICAgICBpZiAodGhpcy5fZGlzYWJsZWQgIT09IGNvZXJjZWRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSBjb2VyY2VkVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9oZWFkZXJWaWV3UmVmITogRW1iZWRkZWRWaWV3UmVmPGFueT47XG4gICAgcHJpdmF0ZSBfY29udGVudFZpZXdSZWYhOiBFbWJlZGRlZFZpZXdSZWY8YW55PjtcblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGhlYWRlclZpZXdSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJWaWV3UmVmO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGNvbnRlbnRWaWV3UmVmKCkge1xuICAgICAgICAvLyBmb3IgbGF6eSBsb2FkaW5nIHdlIG9ubHkgY3JlYXRlIHRoZSB2aWV3cmVmIHdoZW4gaXQgaXMgYXNrZWQgZm9yXG4gICAgICAgIGlmICghdGhpcy5fY29udGVudFZpZXdSZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRUZW1wbGF0ZSA9IHRoaXMuX2V4cGxpY2l0Q29udGVudCB8fCB0aGlzLl9pbXBsaWNpdENvbnRlbnQ7XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50Vmlld1JlZiA9IGNvbnRlbnRUZW1wbGF0ZS5jcmVhdGVFbWJlZGRlZFZpZXcoe30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Vmlld1JlZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSB0YWIgaXMgY3VycmVudGx5IGFjdGl2ZS5cbiAgICAgKi9cbiAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChOeFRhYkdyb3VwQmFzZSkgQE9wdGlvbmFsKCkgQEhvc3QoKSBwcml2YXRlIF90YWJHcm91cDogTnhUYWJHcm91cEJhc2UgfCBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGFiR3JvdXApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBUaGUgbngtdGFiIGVsZW1lbnQgaGFzIHRvIGJlIHdyYXBwZWQgaW4gYSBueC10YWItZ3JvdXAgdG8gd29yay5cbiAgICAgIFBsZWFzZSBwcm92aWRlIGEgbngtdGFiLWdyb3VwIGVsZW1lbnQgYW5kIHBsYWNlIHlvdXIgdGFicyBpbnNpZGUgaXQuYCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNoYW5nZXMsICdsYWJlbCcpIHx8IHt9Lmhhc093blByb3BlcnR5LmNhbGwoY2hhbmdlcywgJ2Rpc2FibGVkJykpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlQ2hhbmdlcy5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlTGFiZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlclZpZXdSZWYgPSB0aGlzLnRlbXBsYXRlTGFiZWwuY3JlYXRlRW1iZWRkZWRWaWV3KHt9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zdGF0ZUNoYW5nZXMuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5fY29udGVudFZpZXdSZWYuZGVzdHJveSgpO1xuICAgICAgICBpZiAodGhpcy5faGVhZGVyVmlld1JlZikge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyVmlld1JlZi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCI8bmctdGVtcGxhdGU+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvbmctdGVtcGxhdGU+XG4iXX0=