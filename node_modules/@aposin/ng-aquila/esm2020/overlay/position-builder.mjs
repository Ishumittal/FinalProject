import { Injectable, Optional } from '@angular/core';
import { BASE_OFFSET, CLOCKWISE_DIRECTIONS, HORIZONTAL_DIRECTIONS, VERTICAL_DIRECTIONS } from './overlay-config';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/cdk/bidi";
/**
 * Creates an error to be thrown if the user provided an invalid popover direction.
 * @docs-private
 */
export function getNxOverlayInvalidDirectionError(direction) {
    return Error(`Overlay direction "${direction}" is invalid.`);
}
export const OVERLAY_POSITIONS = {
    top(isRtl) {
        return { overlayX: 'center', overlayY: 'bottom' };
    },
    'top-start': function (isRtl) {
        return { overlayX: isRtl ? 'end' : 'start', overlayY: 'bottom' };
    },
    'top-end': function (isRtl) {
        return { overlayX: isRtl ? 'start' : 'end', overlayY: 'bottom' };
    },
    bottom(isRtl) {
        return { overlayX: 'center', overlayY: 'top' };
    },
    'bottom-start': function (isRtl) {
        return { overlayX: isRtl ? 'end' : 'start', overlayY: 'top' };
    },
    'bottom-end': function (isRtl) {
        return { overlayX: isRtl ? 'start' : 'end', overlayY: 'top' };
    },
    left(isRtl) {
        return { overlayX: isRtl ? 'start' : 'end', overlayY: 'center' };
    },
    right(isRtl) {
        return { overlayX: isRtl ? 'end' : 'start', overlayY: 'center' };
    },
};
export const ORIGIN_POSITIONS = {
    top(isRtl) {
        return { originX: 'center', originY: 'top' };
    },
    'top-start': function (isRtl) {
        return { originX: isRtl ? 'end' : 'start', originY: 'top' };
    },
    'top-end': function (isRtl) {
        return { originX: isRtl ? 'start' : 'end', originY: 'top' };
    },
    bottom(isRtl) {
        return { originX: 'center', originY: 'bottom' };
    },
    'bottom-start': function (isRtl) {
        return { originX: isRtl ? 'end' : 'start', originY: 'bottom' };
    },
    'bottom-end': function (isRtl) {
        return { originX: isRtl ? 'start' : 'end', originY: 'bottom' };
    },
    left(isRtl) {
        return { originX: isRtl ? 'end' : 'start', originY: 'center' };
    },
    right(isRtl) {
        return { originX: isRtl ? 'start' : 'end', originY: 'center' };
    },
};
export class NxOverlayPositionBuilder {
    constructor(_overlay, _dir) {
        this._overlay = _overlay;
        this._dir = _dir;
    }
    createPositionStrategy(element, config) {
        const fallbacks = this._getFallbackPositions(config.direction, config);
        const origin = this.getOrigin(config.direction);
        const overlay = this.getOverlayPosition(config.direction);
        const offset = this.getOffset(config.direction, config);
        return this._overlay
            .position()
            .flexibleConnectedTo(element)
            .withPush(false)
            .withFlexibleDimensions(true)
            .withLockedPosition()
            .withGrowAfterOpen()
            .withPositions([
            {
                ...origin,
                ...overlay,
                ...offset,
            },
            ...fallbacks,
        ]);
    }
    /**
     * Returns the origin position based on the user's direction preference.
     */
    getOrigin(direction) {
        if (!direction || !(direction in ORIGIN_POSITIONS)) {
            throw getNxOverlayInvalidDirectionError(direction);
        }
        return ORIGIN_POSITIONS[direction](this.isRtl);
    }
    /** Returns the overlay position based on the user's direction preference */
    getOverlayPosition(direction) {
        if (!direction || !(direction in OVERLAY_POSITIONS)) {
            throw getNxOverlayInvalidDirectionError(direction);
        }
        return OVERLAY_POSITIONS[direction](this.isRtl);
    }
    /** Returns the overlay offset required by the user's direction preference */
    getOffset(direction, config) {
        if (!direction || !(direction in OVERLAY_POSITIONS)) {
            throw getNxOverlayInvalidDirectionError(direction);
        }
        const offset = config.offset || BASE_OFFSET;
        const [genericDirection] = direction.split('-');
        switch (genericDirection) {
            case 'top': {
                return {
                    offsetY: offset * -1,
                };
            }
            case 'bottom': {
                return {
                    offsetY: offset,
                };
            }
            case 'left': {
                return {
                    offsetX: offset * -1,
                };
            }
            case 'right': {
                return {
                    offsetX: offset,
                };
            }
            default: {
                throw getNxOverlayInvalidDirectionError(direction);
            }
        }
    }
    /** Returns an array of fallback positions for popover, following the algoritm:
     * 1) Slightly alternate preferred position if applicable. I.e. for 'top' try 'top-start' and 'top-end' positioning.
     * 2) Try the opposite position, i.e. for 'top' try 'bottom'.
     * 3) Slightly alternate opposite position, i.e. 'bottom-start', 'bottom-end'
     * 4) All remaining positions from positions list
     */
    _getFallbackPositions(direction, config) {
        if (!direction) {
            return [];
        }
        // create order of fallbacks like: if top then bottom, left, right
        const fallbackOrder = this._getFallbackOrder(direction, config);
        // add positions like {direction}-start and filter the requested direction
        const resolvedDirections = this._resolveFallbacks(fallbackOrder, config).filter(d => d !== direction);
        const fallbackPositions = [];
        resolvedDirections.forEach(fallbackDirection => {
            const origin = this.getOrigin(fallbackDirection);
            const overlay = this.getOverlayPosition(fallbackDirection);
            const offset = this.getOffset(fallbackDirection, config);
            fallbackPositions.push({
                ...origin,
                ...overlay,
                ...offset,
            });
        });
        return fallbackPositions;
    }
    /** Takes the defined fallback orders and adjusts it for the requested direction */
    _getFallbackOrder(direction, config) {
        let order;
        switch (config.fallbackOrientation) {
            case 'vertical':
                order = VERTICAL_DIRECTIONS;
                break;
            case 'horizontal':
                order = HORIZONTAL_DIRECTIONS;
                break;
            case 'clockwise':
                order = CLOCKWISE_DIRECTIONS;
                break;
            default:
                throw getNxOverlayInvalidDirectionError(config.fallbackOrientation || '');
        }
        // reorder the array to start from the requested position
        const [generalDirection] = this._splitDirection(direction);
        const directionIndex = order.indexOf(generalDirection);
        return [...order.slice(directionIndex), ...order.slice(0, directionIndex)];
    }
    // We often need the general direction like top or bottom if the requested direction
    // is like bottom-start
    _splitDirection(direction) {
        return direction.split('-');
    }
    get isRtl() {
        return this._dir?.value === 'rtl';
    }
    /** Returns the opposite position, using angular position naming: top, bottom, start, end, center */
    _getInversePosition(position) {
        const positionPairs = {
            top: 'bottom',
            bottom: 'top',
            start: 'end',
            end: 'start',
            center: 'center',
        };
        return positionPairs[position];
    }
    /** Resolve the fallback order to all possible direction. For top and bottom we want to add the start and end positions. */
    _resolveFallbacks(fallbacks, config) {
        if (!config.direction) {
            throw getNxOverlayInvalidDirectionError('');
        }
        const [generalDirection, addition] = this._splitDirection(config.direction);
        return fallbacks.reduce((resolved, direction) => {
            if (direction === 'top' || direction === 'bottom') {
                if (addition) {
                    // if we have something like bottom-start we want to do bottom-end first
                    resolved.push(`${direction}-${addition}`, `${direction}-${this._getInversePosition(addition)}`, direction);
                }
                else {
                    resolved.push(direction, `${direction}-start`, `${direction}-end`);
                }
            }
            else {
                resolved.push(direction);
            }
            return resolved;
        }, []);
    }
}
NxOverlayPositionBuilder.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxOverlayPositionBuilder, deps: [{ token: i1.Overlay }, { token: i2.Directionality, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });
NxOverlayPositionBuilder.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxOverlayPositionBuilder });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxOverlayPositionBuilder, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i2.Directionality, decorators: [{
                    type: Optional
                }] }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zaXRpb24tYnVpbGRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWFxdWlsYS9zcmMvb3ZlcmxheS9wb3NpdGlvbi1idWlsZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQVVBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXJELE9BQU8sRUFBRSxXQUFXLEVBQUUsb0JBQW9CLEVBQUUscUJBQXFCLEVBQXVDLG1CQUFtQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7QUFFdEo7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLGlDQUFpQyxDQUFDLFNBQWlCO0lBQy9ELE9BQU8sS0FBSyxDQUFDLHNCQUFzQixTQUFTLGVBQWUsQ0FBQyxDQUFDO0FBQ2pFLENBQUM7QUFFRCxNQUFNLENBQUMsTUFBTSxpQkFBaUIsR0FBbUY7SUFDN0csR0FBRyxDQUFDLEtBQUs7UUFDTCxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLENBQUM7SUFDdEQsQ0FBQztJQUNELFdBQVcsRUFBRSxVQUFVLEtBQUs7UUFDeEIsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsQ0FBQztJQUNyRSxDQUFDO0lBQ0QsU0FBUyxFQUFFLFVBQVUsS0FBSztRQUN0QixPQUFPLEVBQUUsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxDQUFDO0lBQ3JFLENBQUM7SUFDRCxNQUFNLENBQUMsS0FBSztRQUNSLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBQztJQUNuRCxDQUFDO0lBQ0QsY0FBYyxFQUFF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RUFBRTtZQUNsRSxJQUFJLFNBQVMsS0FBSyxLQUFLLElBQUksU0FBUyxLQUFLLFFBQVEsRUFBRTtnQkFDL0MsSUFBSSxRQUFRLEVBQUU7b0JBQ1Ysd0VBQXdFO29CQUN4RSxRQUFRLENBQUMsSUFBSSxDQUNULEdBQUcsU0FBUyxJQUFJLFFBQVEsRUFBd0IsRUFDaEQsR0FBRyxTQUFTLElBQUksSUFBSSxDQUFDLG1CQUFtQixDQUFDLFFBQVEsQ0FBQyxFQUF3QixFQUMxRSxTQUFTLENBQ1osQ0FBQztpQkFDTDtxQkFBTTtvQkFDSCxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxHQUFHLFNBQVMsUUFBOEIsRUFBRSxHQUFHLFNBQVMsTUFBNEIsQ0FBQyxDQUFDO2lCQUNsSDthQUNKO2lCQUFNO2dCQUNILFFBQVEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDNUI7WUFDRCxPQUFPLFFBQVEsQ0FBQztRQUNwQixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDWCxDQUFDOztxSEFoTFEsd0JBQXdCO3lIQUF4Qix3QkFBd0I7MkZBQXhCLHdCQUF3QjtrQkFEcEMsVUFBVTs7MEJBRWlDLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3Rpb25hbGl0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9iaWRpJztcbmltcG9ydCB7XG4gICAgQ29ubmVjdGlvblBvc2l0aW9uUGFpcixcbiAgICBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3lPcmlnaW4sXG4gICAgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3MsXG4gICAgT3JpZ2luQ29ubmVjdGlvblBvc2l0aW9uLFxuICAgIE92ZXJsYXksXG4gICAgT3ZlcmxheUNvbm5lY3Rpb25Qb3NpdGlvbixcbiAgICBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MsXG59IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEJBU0VfT0ZGU0VULCBDTE9DS1dJU0VfRElSRUNUSU9OUywgSE9SSVpPTlRBTF9ESVJFQ1RJT05TLCBOeE92ZXJsYXlDb25maWcsIE54T3ZlcmxheURpcmVjdGlvbiwgVkVSVElDQUxfRElSRUNUSU9OUyB9IGZyb20gJy4vb3ZlcmxheS1jb25maWcnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gZXJyb3IgdG8gYmUgdGhyb3duIGlmIHRoZSB1c2VyIHByb3ZpZGVkIGFuIGludmFsaWQgcG9wb3ZlciBkaXJlY3Rpb24uXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROeE92ZXJsYXlJbnZhbGlkRGlyZWN0aW9uRXJyb3IoZGlyZWN0aW9uOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gRXJyb3IoYE92ZXJsYXkgZGlyZWN0aW9uIFwiJHtkaXJlY3Rpb259XCIgaXMgaW52YWxpZC5gKTtcbn1cblxuZXhwb3J0IGNvbnN0IE9WRVJMQVlfUE9TSVRJT05TOiB7IFtrZXkgaW4gTnhPdmVybGF5RGlyZWN0aW9uXTogKGlzUnRsOiBib29sZWFuKSA9PiBPdmVybGF5Q29ubmVjdGlvblBvc2l0aW9uIH0gPSB7XG4gICAgdG9wKGlzUnRsKSB7XG4gICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICdib3R0b20nIH07XG4gICAgfSxcbiAgICAndG9wLXN0YXJ0JzogZnVuY3Rpb24gKGlzUnRsKSB7XG4gICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiBpc1J0bCA/ICdlbmQnIDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICdib3R0b20nIH07XG4gICAgfSxcbiAgICAndG9wLWVuZCc6IGZ1bmN0aW9uIChpc1J0bCkge1xuICAgICAgICByZXR1cm4geyBvdmVybGF5WDogaXNSdGwgPyAnc3RhcnQnIDogJ2VuZCcsIG92ZXJsYXlZOiAnYm90dG9tJyB9O1xuICAgIH0sXG4gICAgYm90dG9tKGlzUnRsKSB7XG4gICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiAnY2VudGVyJywgb3ZlcmxheVk6ICd0b3AnIH07XG4gICAgfSxcbiAgICAnYm90dG9tLXN0YXJ0JzogZnVuY3Rpb24gKGlzUnRsKSB7XG4gICAgICAgIHJldHVybiB7IG92ZXJsYXlYOiBpc1J0bCA/ICdlbmQnIDogJ3N0YXJ0Jywgb3ZlcmxheVk6ICd0b3AnIH07XG4gICAgfSxcbiAgICAnYm90dG9tLWVuZCc6IGZ1bmN0aW9uIChpc1J0bCkge1xuICAgICAgICByZXR1cm4geyBvdmVybGF5WDogaXNSdGwgPyAnc3RhcnQnIDogJ2VuZCcsIG92ZXJsYXlZOiAndG9wJyB9O1xuICAgIH0sXG4gICAgbGVmdChpc1J0bCkge1xuICAgICAgICByZXR1cm4geyBvdmVybGF5WDogaXNSdGwgPyAnc3RhcnQnIDogJ2VuZCcsIG92ZXJsYXlZOiAnY2VudGVyJyB9O1xuICAgIH0sXG4gICAgcmlnaHQoaXNSdGwpIHtcbiAgICAgICAgcmV0dXJuIHsgb3ZlcmxheVg6IGlzUnRsID8gJ2VuZCcgOiAnc3RhcnQnLCBvdmVybGF5WTogJ2NlbnRlcicgfTtcbiAgICB9LFxufTtcbmV4cG9ydCBjb25zdCBPUklHSU5fUE9TSVRJT05TOiB7IFtrZXkgaW4gTnhPdmVybGF5RGlyZWN0aW9uXTogKGFyZzA6IGJvb2xlYW4pID0+IE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbiB9ID0ge1xuICAgIHRvcChpc1J0bCkge1xuICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogJ3RvcCcgfTtcbiAgICB9LFxuICAgICd0b3Atc3RhcnQnOiBmdW5jdGlvbiAoaXNSdGwpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogaXNSdGwgPyAnZW5kJyA6ICdzdGFydCcsIG9yaWdpblk6ICd0b3AnIH07XG4gICAgfSxcbiAgICAndG9wLWVuZCc6IGZ1bmN0aW9uIChpc1J0bCkge1xuICAgICAgICByZXR1cm4geyBvcmlnaW5YOiBpc1J0bCA/ICdzdGFydCcgOiAnZW5kJywgb3JpZ2luWTogJ3RvcCcgfTtcbiAgICB9LFxuICAgIGJvdHRvbShpc1J0bCkge1xuICAgICAgICByZXR1cm4geyBvcmlnaW5YOiAnY2VudGVyJywgb3JpZ2luWTogJ2JvdHRvbScgfTtcbiAgICB9LFxuICAgICdib3R0b20tc3RhcnQnOiBmdW5jdGlvbiAoaXNSdGwpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogaXNSdGwgPyAnZW5kJyA6ICdzdGFydCcsIG9yaWdpblk6ICdib3R0b20nIH07XG4gICAgfSxcbiAgICAnYm90dG9tLWVuZCc6IGZ1bmN0aW9uIChpc1J0bCkge1xuICAgICAgICByZXR1cm4geyBvcmlnaW5YOiBpc1J0bCA/ICdzdGFydCcgOiAnZW5kJywgb3JpZ2luWTogJ2JvdHRvbScgfTtcbiAgICB9LFxuICAgIGxlZnQoaXNSdGwpIHtcbiAgICAgICAgcmV0dXJuIHsgb3JpZ2luWDogaXNSdGwgPyAnZW5kJyA6ICdzdGFydCcsIG9yaWdpblk6ICdjZW50ZXInIH07XG4gICAgfSxcbiAgICByaWdodChpc1J0bCkge1xuICAgICAgICByZXR1cm4geyBvcmlnaW5YOiBpc1J0bCA/ICdzdGFydCcgOiAnZW5kJywgb3JpZ2luWTogJ2NlbnRlcicgfTtcbiAgICB9LFxufTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE54T3ZlcmxheVBvc2l0aW9uQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSwgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfZGlyOiBEaXJlY3Rpb25hbGl0eSB8IG51bGwpIHt9XG5cbiAgICBjcmVhdGVQb3NpdGlvblN0cmF0ZWd5KGVsZW1lbnQ6IEZsZXhpYmxlQ29ubmVjdGVkUG9zaXRpb25TdHJhdGVneU9yaWdpbiwgY29uZmlnOiBOeE92ZXJsYXlDb25maWcpIHtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tzID0gdGhpcy5fZ2V0RmFsbGJhY2tQb3NpdGlvbnMoY29uZmlnLmRpcmVjdGlvbiBhcyBOeE92ZXJsYXlEaXJlY3Rpb24sIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHRoaXMuZ2V0T3JpZ2luKGNvbmZpZy5kaXJlY3Rpb24pO1xuICAgICAgICBjb25zdCBvdmVybGF5ID0gdGhpcy5nZXRPdmVybGF5UG9zaXRpb24oY29uZmlnLmRpcmVjdGlvbik7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0KGNvbmZpZy5kaXJlY3Rpb24sIGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5XG4gICAgICAgICAgICAucG9zaXRpb24oKVxuICAgICAgICAgICAgLmZsZXhpYmxlQ29ubmVjdGVkVG8oZWxlbWVudClcbiAgICAgICAgICAgIC53aXRoUHVzaChmYWxzZSlcbiAgICAgICAgICAgIC53aXRoRmxleGlibGVEaW1lbnNpb25zKHRydWUpXG4gICAgICAgICAgICAud2l0aExvY2tlZFBvc2l0aW9uKClcbiAgICAgICAgICAgIC53aXRoR3Jvd0FmdGVyT3BlbigpXG4gICAgICAgICAgICAud2l0aFBvc2l0aW9ucyhbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAuLi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIC4uLm92ZXJsYXksXG4gICAgICAgICAgICAgICAgICAgIC4uLm9mZnNldCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLmZhbGxiYWNrcyxcbiAgICAgICAgICAgIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9yaWdpbiBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdXNlcidzIGRpcmVjdGlvbiBwcmVmZXJlbmNlLlxuICAgICAqL1xuICAgIGdldE9yaWdpbihkaXJlY3Rpb246IE54T3ZlcmxheURpcmVjdGlvbiB8IHVuZGVmaW5lZCk6IE9yaWdpbkNvbm5lY3Rpb25Qb3NpdGlvbiB7XG4gICAgICAgIGlmICghZGlyZWN0aW9uIHx8ICEoZGlyZWN0aW9uIGluIE9SSUdJTl9QT1NJVElPTlMpKSB7XG4gICAgICAgICAgICB0aHJvdyBnZXROeE92ZXJsYXlJbnZhbGlkRGlyZWN0aW9uRXJyb3IoZGlyZWN0aW9uIGFzIHN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9SSUdJTl9QT1NJVElPTlNbZGlyZWN0aW9uXSh0aGlzLmlzUnRsKTtcbiAgICB9XG5cbiAgICAvKiogUmV0dXJucyB0aGUgb3ZlcmxheSBwb3NpdGlvbiBiYXNlZCBvbiB0aGUgdXNlcidzIGRpcmVjdGlvbiBwcmVmZXJlbmNlICovXG4gICAgZ2V0T3ZlcmxheVBvc2l0aW9uKGRpcmVjdGlvbjogTnhPdmVybGF5RGlyZWN0aW9uIHwgdW5kZWZpbmVkKTogT3ZlcmxheUNvbm5lY3Rpb25Qb3NpdGlvbiB7XG4gICAgICAgIGlmICghZGlyZWN0aW9uIHx8ICEoZGlyZWN0aW9uIGluIE9WRVJMQVlfUE9TSVRJT05TKSkge1xuICAgICAgICAgICAgdGhyb3cgZ2V0TnhPdmVybGF5SW52YWxpZERpcmVjdGlvbkVycm9yKGRpcmVjdGlvbiBhcyBzdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPVkVSTEFZX1BPU0lUSU9OU1tkaXJlY3Rpb25dKHRoaXMuaXNSdGwpO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBvdmVybGF5IG9mZnNldCByZXF1aXJlZCBieSB0aGUgdXNlcidzIGRpcmVjdGlvbiBwcmVmZXJlbmNlICovXG4gICAgZ2V0T2Zmc2V0KGRpcmVjdGlvbjogTnhPdmVybGF5RGlyZWN0aW9uIHwgdW5kZWZpbmVkLCBjb25maWc6IE54T3ZlcmxheUNvbmZpZykge1xuICAgICAgICBpZiAoIWRpcmVjdGlvbiB8fCAhKGRpcmVjdGlvbiBpbiBPVkVSTEFZX1BPU0lUSU9OUykpIHtcbiAgICAgICAgICAgIHRocm93IGdldE54T3ZlcmxheUludmFsaWREaXJlY3Rpb25FcnJvcihkaXJlY3Rpb24gYXMgc3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvZmZzZXQgPSBjb25maWcub2Zmc2V0IHx8IEJBU0VfT0ZGU0VUO1xuICAgICAgICBjb25zdCBbZ2VuZXJpY0RpcmVjdGlvbl0gPSBkaXJlY3Rpb24uc3BsaXQoJy0nKTtcbiAgICAgICAgc3dpdGNoIChnZW5lcmljRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICd0b3AnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WTogb2Zmc2V0ICogLTEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXRZOiBvZmZzZXQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WDogb2Zmc2V0ICogLTEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3JpZ2h0Jzoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFg6IG9mZnNldCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHRocm93IGdldE54T3ZlcmxheUludmFsaWREaXJlY3Rpb25FcnJvcihkaXJlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFsbGJhY2sgcG9zaXRpb25zIGZvciBwb3BvdmVyLCBmb2xsb3dpbmcgdGhlIGFsZ29yaXRtOlxuICAgICAqIDEpIFNsaWdodGx5IGFsdGVybmF0ZSBwcmVmZXJyZWQgcG9zaXRpb24gaWYgYXBwbGljYWJsZS4gSS5lLiBmb3IgJ3RvcCcgdHJ5ICd0b3Atc3RhcnQnIGFuZCAndG9wLWVuZCcgcG9zaXRpb25pbmcuXG4gICAgICogMikgVHJ5IHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiwgaS5lLiBmb3IgJ3RvcCcgdHJ5ICdib3R0b20nLlxuICAgICAqIDMpIFNsaWdodGx5IGFsdGVybmF0ZSBvcHBvc2l0ZSBwb3NpdGlvbiwgaS5lLiAnYm90dG9tLXN0YXJ0JywgJ2JvdHRvbS1lbmQnXG4gICAgICogNCkgQWxsIHJlbWFpbmluZyBwb3NpdGlvbnMgZnJvbSBwb3NpdGlvbnMgbGlzdFxuICAgICAqL1xuICAgIHByaXZhdGUgX2dldEZhbGxiYWNrUG9zaXRpb25zKGRpcmVjdGlvbjogTnhPdmVybGF5RGlyZWN0aW9uLCBjb25maWc6IE54T3ZlcmxheUNvbmZpZyk6IENvbm5lY3Rpb25Qb3NpdGlvblBhaXJbXSB7XG4gICAgICAgIGlmICghZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjcmVhdGUgb3JkZXIgb2YgZmFsbGJhY2tzIGxpa2U6IGlmIHRvcCB0aGVuIGJvdHRvbSwgbGVmdCwgcmlnaHRcbiAgICAgICAgY29uc3QgZmFsbGJhY2tPcmRlciA9IHRoaXMuX2dldEZhbGxiYWNrT3JkZXIoZGlyZWN0aW9uLCBjb25maWcpO1xuICAgICAgICAvLyBhZGQgcG9zaXRpb25zIGxpa2Uge2RpcmVjdGlvbn0tc3RhcnQgYW5kIGZpbHRlciB0aGUgcmVxdWVzdGVkIGRpcmVjdGlvblxuICAgICAgICBjb25zdCByZXNvbHZlZERpcmVjdGlvbnMgPSB0aGlzLl9yZXNvbHZlRmFsbGJhY2tzKGZhbGxiYWNrT3JkZXIsIGNvbmZpZykuZmlsdGVyKGQgPT4gZCAhPT0gZGlyZWN0aW9uKTtcblxuICAgICAgICBjb25zdCBmYWxsYmFja1Bvc2l0aW9uczogQ29ubmVjdGlvblBvc2l0aW9uUGFpcltdID0gW107XG5cbiAgICAgICAgcmVzb2x2ZWREaXJlY3Rpb25zLmZvckVhY2goZmFsbGJhY2tEaXJlY3Rpb24gPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gdGhpcy5nZXRPcmlnaW4oZmFsbGJhY2tEaXJlY3Rpb24pO1xuICAgICAgICAgICAgY29uc3Qgb3ZlcmxheSA9IHRoaXMuZ2V0T3ZlcmxheVBvc2l0aW9uKGZhbGxiYWNrRGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuZ2V0T2Zmc2V0KGZhbGxiYWNrRGlyZWN0aW9uLCBjb25maWcpO1xuICAgICAgICAgICAgZmFsbGJhY2tQb3NpdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgLi4ub3JpZ2luLFxuICAgICAgICAgICAgICAgIC4uLm92ZXJsYXksXG4gICAgICAgICAgICAgICAgLi4ub2Zmc2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBmYWxsYmFja1Bvc2l0aW9ucztcbiAgICB9XG5cbiAgICAvKiogVGFrZXMgdGhlIGRlZmluZWQgZmFsbGJhY2sgb3JkZXJzIGFuZCBhZGp1c3RzIGl0IGZvciB0aGUgcmVxdWVzdGVkIGRpcmVjdGlvbiAqL1xuICAgIHByaXZhdGUgX2dldEZhbGxiYWNrT3JkZXIoZGlyZWN0aW9uOiBOeE92ZXJsYXlEaXJlY3Rpb24sIGNvbmZpZzogTnhPdmVybGF5Q29uZmlnKSB7XG4gICAgICAgIGxldCBvcmRlcjogTnhPdmVybGF5RGlyZWN0aW9uW107XG4gICAgICAgIHN3aXRjaCAoY29uZmlnLmZhbGxiYWNrT3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ3ZlcnRpY2FsJzpcbiAgICAgICAgICAgICAgICBvcmRlciA9IFZFUlRJQ0FMX0RJUkVDVElPTlM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdob3Jpem9udGFsJzpcbiAgICAgICAgICAgICAgICBvcmRlciA9IEhPUklaT05UQUxfRElSRUNUSU9OUztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Nsb2Nrd2lzZSc6XG4gICAgICAgICAgICAgICAgb3JkZXIgPSBDTE9DS1dJU0VfRElSRUNUSU9OUztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgZ2V0TnhPdmVybGF5SW52YWxpZERpcmVjdGlvbkVycm9yKGNvbmZpZy5mYWxsYmFja09yaWVudGF0aW9uIHx8ICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZW9yZGVyIHRoZSBhcnJheSB0byBzdGFydCBmcm9tIHRoZSByZXF1ZXN0ZWQgcG9zaXRpb25cbiAgICAgICAgY29uc3QgW2dlbmVyYWxEaXJlY3Rpb25dID0gdGhpcy5fc3BsaXREaXJlY3Rpb24oZGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uSW5kZXggPSBvcmRlci5pbmRleE9mKGdlbmVyYWxEaXJlY3Rpb24gYXMgTnhPdmVybGF5RGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIFsuLi5vcmRlci5zbGljZShkaXJlY3Rpb25JbmRleCksIC4uLm9yZGVyLnNsaWNlKDAsIGRpcmVjdGlvbkluZGV4KV07XG4gICAgfVxuXG4gICAgLy8gV2Ugb2Z0ZW4gbmVlZCB0aGUgZ2VuZXJhbCBkaXJlY3Rpb24gbGlrZSB0b3Agb3IgYm90dG9tIGlmIHRoZSByZXF1ZXN0ZWQgZGlyZWN0aW9uXG4gICAgLy8gaXMgbGlrZSBib3R0b20tc3RhcnRcbiAgICBwcml2YXRlIF9zcGxpdERpcmVjdGlvbihkaXJlY3Rpb246IE54T3ZlcmxheURpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gZGlyZWN0aW9uLnNwbGl0KCctJyk7XG4gICAgfVxuXG4gICAgZ2V0IGlzUnRsKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyPy52YWx1ZSA9PT0gJ3J0bCc7XG4gICAgfVxuXG4gICAgLyoqIFJldHVybnMgdGhlIG9wcG9zaXRlIHBvc2l0aW9uLCB1c2luZyBhbmd1bGFyIHBvc2l0aW9uIG5hbWluZzogdG9wLCBib3R0b20sIHN0YXJ0LCBlbmQsIGNlbnRlciAqL1xuICAgIHByaXZhdGUgX2dldEludmVyc2VQb3NpdGlvbihwb3NpdGlvbjogc3RyaW5nKTogVmVydGljYWxDb25uZWN0aW9uUG9zIHwgSG9yaXpvbnRhbENvbm5lY3Rpb25Qb3Mge1xuICAgICAgICBjb25zdCBwb3NpdGlvblBhaXJzOiB7IFtrOiBzdHJpbmddOiBWZXJ0aWNhbENvbm5lY3Rpb25Qb3MgfCBIb3Jpem9udGFsQ29ubmVjdGlvblBvcyB9ID0ge1xuICAgICAgICAgICAgdG9wOiAnYm90dG9tJyxcbiAgICAgICAgICAgIGJvdHRvbTogJ3RvcCcsXG4gICAgICAgICAgICBzdGFydDogJ2VuZCcsXG4gICAgICAgICAgICBlbmQ6ICdzdGFydCcsXG4gICAgICAgICAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcG9zaXRpb25QYWlyc1twb3NpdGlvbl07XG4gICAgfVxuXG4gICAgLyoqIFJlc29sdmUgdGhlIGZhbGxiYWNrIG9yZGVyIHRvIGFsbCBwb3NzaWJsZSBkaXJlY3Rpb24uIEZvciB0b3AgYW5kIGJvdHRvbSB3ZSB3YW50IHRvIGFkZCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMuICovXG4gICAgcHJpdmF0ZSBfcmVzb2x2ZUZhbGxiYWNrcyhmYWxsYmFja3M6IE54T3ZlcmxheURpcmVjdGlvbltdLCBjb25maWc6IE54T3ZlcmxheUNvbmZpZykge1xuICAgICAgICBpZiAoIWNvbmZpZy5kaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IGdldE54T3ZlcmxheUludmFsaWREaXJlY3Rpb25FcnJvcignJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2dlbmVyYWxEaXJlY3Rpb24sIGFkZGl0aW9uXSA9IHRoaXMuX3NwbGl0RGlyZWN0aW9uKGNvbmZpZy5kaXJlY3Rpb24pO1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tzLnJlZHVjZSgocmVzb2x2ZWQ6IE54T3ZlcmxheURpcmVjdGlvbltdLCBkaXJlY3Rpb24pID0+IHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd0b3AnIHx8IGRpcmVjdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSBzb21ldGhpbmcgbGlrZSBib3R0b20tc3RhcnQgd2Ugd2FudCB0byBkbyBib3R0b20tZW5kIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkLnB1c2goXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtkaXJlY3Rpb259LSR7YWRkaXRpb259YCBhcyBOeE92ZXJsYXlEaXJlY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHtkaXJlY3Rpb259LSR7dGhpcy5fZ2V0SW52ZXJzZVBvc2l0aW9uKGFkZGl0aW9uKX1gIGFzIE54T3ZlcmxheURpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZC5wdXNoKGRpcmVjdGlvbiwgYCR7ZGlyZWN0aW9ufS1zdGFydGAgYXMgTnhPdmVybGF5RGlyZWN0aW9uLCBgJHtkaXJlY3Rpb259LWVuZGAgYXMgTnhPdmVybGF5RGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkLnB1c2goZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlZDtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cbiJdfQ==