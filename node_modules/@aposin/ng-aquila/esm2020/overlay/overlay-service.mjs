import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { ComponentPortal, TemplatePortal } from '@angular/cdk/portal';
import { Inject, Injectable, InjectionToken, Injector, Optional, SkipSelf, TemplateRef } from '@angular/core';
import { Subject } from 'rxjs';
import { NxOverlayConfig } from './overlay-config';
import { NxOverlayContainerComponent } from './overlay-container.component';
import { NxOverlayRef } from './overlay-ref';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "@angular/router";
import * as i3 from "./position-builder";
import * as i4 from "@angular/cdk/bidi";
/** Injection token that determines the scroll handling while a overlay is open. */
export const NX_OVERLAY_SCROLL_STRATEGY = new InjectionToken('nx-overlay-scroll-strategy');
/** @docs-private */
export function NX_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.reposition();
}
/** @docs-private */
export const NX_OVERLAY_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_OVERLAY_SCROLL_STRATEGY,
    useFactory: NX_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
export class NxOverlayService {
    constructor(_overlay, _injector, _router, _positionBuilder, _parentOverlayService, _dir, _defaultScrollStrategyFactory) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._router = _router;
        this._positionBuilder = _positionBuilder;
        this._parentOverlayService = _parentOverlayService;
        this._dir = _dir;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this._afterAllClosedAtThisLevel = new Subject();
        this._afterOpenedAtThisLevel = new Subject();
        this._openOverlaysAtThisLevel = [];
        /** Strategy factory that will be used to handle scrolling while an overlay panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
    }
    /** Keeps track of the currently-open overlays. */
    get openOverlays() {
        return this._parentOverlayService ? this._parentOverlayService.openOverlays : this._openOverlaysAtThisLevel;
    }
    /** The text direction of the containing app. */
    get dir() {
        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';
    }
    /**
     * Opens a panel containing the given component and attaches it to an element.
     * @param componentOrTemplateRef Type of the component to load into the dialog,
     *     or a TemplateRef to instantiate as the panel content.
     * @param config Extra configuration options.
     * @returns Reference to the newly-opened panel.
     */
    open(componentOrTemplateRef, origin, config) {
        config = _applyConfigDefaults(config, new NxOverlayConfig());
        if (config.id && this.getOverlayById(config.id)) {
            throw Error(`Overlay with id "${config.id}" exists already. The overlay id must be unique.`);
        }
        const cdkOverlayRef = this._createOverlay(config, origin);
        const overlayContainer = this._attachOverlayContainer(cdkOverlayRef, config);
        const overlayRef = this._attachOverlayContent(componentOrTemplateRef, overlayContainer, cdkOverlayRef, config, origin);
        this.openOverlays.push(overlayRef);
        overlayRef.afterClosed().subscribe(() => this._removeOpenOverlay(overlayRef));
        if (config.triggerButton) {
            config.triggerButton.setTriggerActive();
        }
        return overlayRef;
    }
    /**
     * Finds an open overlay by its id.
     * @param id ID to use when looking up the overlay.
     */
    getOverlayById(id) {
        return this.openOverlays.find(overlay => overlay.id === id);
    }
    ngOnDestroy() {
        // Only close the overlays at this level on destroy
        // since the parent service may still be active.
        this._closeOverlays(this._openOverlaysAtThisLevel);
        this._afterAllClosedAtThisLevel.complete();
        this._afterOpenedAtThisLevel.complete();
    }
    /**
     * Creates the overlay into which the overlay will be loaded.
     * @param config The overlay configuration.
     * @returns A promise resolving to the OverlayRef for the created overlay.
     */
    _createOverlay(config, origin) {
        const overlayConfig = this._getOverlayConfig(config, origin);
        return this._overlay.create(overlayConfig);
    }
    /*
     **
     * Creates a CDK overlay configuration from the overlay service config.
     * @param overlayConfig The nx overlay service configuration.
     * @returns The CDK overlay configuration.
     */
    _getOverlayConfig(overlayConfig, origin) {
        const state = new OverlayConfig({
            positionStrategy: overlayConfig.positionStrategy || this._positionBuilder.createPositionStrategy(origin, overlayConfig),
            scrollStrategy: overlayConfig.scrollStrategy || this._scrollStrategyFactory(),
            panelClass: overlayConfig.panelClass,
            hasBackdrop: overlayConfig.hasBackdrop,
            width: overlayConfig.width,
            height: overlayConfig.height,
            minWidth: overlayConfig.minWidth,
            minHeight: overlayConfig.minHeight,
            maxWidth: overlayConfig.maxWidth,
            maxHeight: overlayConfig.maxHeight,
            disposeOnNavigation: overlayConfig.closeOnNavigation,
            direction: this.dir,
        });
        if (overlayConfig.backdropClass) {
            state.backdropClass = overlayConfig.backdropClass;
        }
        return state;
    }
    get isRtl() {
        return this._dir?.value === 'rtl';
    }
    /**
     * Attaches an NxOverlayContainer to the already-created overlay.
     * @param cdkOverlay Reference to the dialog's underlying overlay.
     * @param config The overlay configuration.
     * @returns A promise resolving to a ComponentRef for the attached container.
     */
    _attachOverlayContainer(cdkOverlay, config) {
        const userInjector = config?.viewContainerRef?.injector;
        const injector = Injector.create({
            parent: userInjector || this._injector,
            providers: [{ provide: NxOverlayConfig, useValue: config }],
        });
        const containerPortal = new ComponentPortal(NxOverlayContainerComponent, config.viewContainerRef, injector, config.componentFactoryResolver);
        const containerRef = cdkOverlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * Attaches the user-provided component to the already-created NxOverlayContainer.
     * @param componentOrTemplateRef The type of component being loaded into the dialog,
     *     or a TemplateRef to instantiate as the content.
     * @param overlayContainer Reference to the wrapping NxOverlayContainer.
     * @param cdkOverlayRef Reference to the overlay in which the overlay resides.
     * @param config The overlay configuration.
     * @returns A promise resolving to the NxOverlayRef that should be returned to the user.
     */
    _attachOverlayContent(componentOrTemplateRef, overlayContainer, cdkOverlayRef, config, origin) {
        // Create a reference to the overlay we're creating in order to give the user a handle
        // to modify and close it.
        const overlayRef = new NxOverlayRef(cdkOverlayRef, overlayContainer, origin, this._router, config.id);
        if (componentOrTemplateRef instanceof TemplateRef) {
            overlayContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, { $implicit: overlayRef }));
        }
        else {
            const injector = this._createInjector(config, overlayRef, overlayContainer);
            const contentRef = overlayContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));
            overlayRef.componentInstance = contentRef.instance;
        }
        return overlayRef;
    }
    /**
     * Creates a custom injector to be used inside the overlay. This allows a component loaded inside
     * of a overlay to close itself and, optionally, to return a value.
     * @param config Config object that is used to construct the overlay.
     * @param overlayRef Reference to the overlay.
     * @param container Overlay container element that wraps all of the contents.
     * @returns The custom injector that can be used inside the overlay.
     */
    _createInjector(config, overlayRef, overlayContainer) {
        const userInjector = config?.viewContainerRef?.injector;
        // The NxOverlayContainer is injected in the portal as the NxOverlayContainer and the overlays's
        // content are created out of the same ViewContainerRef and as such, are siblings for injector
        // purposes. To allow the hierarchy that is expected, the NxOverlayContainer is explicitly
        // added to the injection tokens.
        const providers = [
            { provide: NxOverlayContainerComponent, useValue: overlayContainer },
            { provide: NxOverlayRef, useValue: overlayRef },
        ];
        return Injector.create({ parent: userInjector || this._injector, providers });
    }
    /**
     * Removes a overlay from the array of open overlays.
     * @param overlayRef Overlay to be removed.
     */
    _removeOpenOverlay(overlayRef) {
        const index = this.openOverlays.indexOf(overlayRef);
        if (index > -1) {
            this.openOverlays.splice(index, 1);
        }
    }
    /** Closes all of the overlays in an array. */
    _closeOverlays(overlays) {
        let i = overlays.length;
        while (i--) {
            // The `_openOverlays` property isn't updated after close until the rxjs subscription
            // runs on the next microtask, in addition to modifying the array as we're going
            // through it. We loop through all of them and call close without assuming that
            // they'll be removed from the list instantaneously.
            overlays[i].close();
        }
    }
}
NxOverlayService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxOverlayService, deps: [{ token: i1.Overlay }, { token: i0.Injector }, { token: i2.Router }, { token: i3.NxOverlayPositionBuilder }, { token: NxOverlayService, optional: true, skipSelf: true }, { token: i4.Directionality, optional: true }, { token: NX_OVERLAY_SCROLL_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });
NxOverlayService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxOverlayService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxOverlayService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.Injector }, { type: i2.Router }, { type: i3.NxOverlayPositionBuilder }, { type: NxOverlayService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i4.Directionality, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NX_OVERLAY_SCROLL_STRATEGY]
                }] }]; } });
/**
 * Applies default options to the overlay config.
 * @param config Config to be modified.
 * @param defaultOptions Default options provided.
 * @returns The new configuration object.
 */
function _applyConfigDefaults(config, defaultOptions) {
    return { ...defaultOptions, ...config };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS1zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctYXF1aWxhL3NyYy9vdmVybGF5L292ZXJsYXktc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQTJDLE9BQU8sRUFBRSxhQUFhLEVBQThCLE1BQU0sc0JBQXNCLENBQUM7QUFDbkksT0FBTyxFQUFFLGVBQWUsRUFBaUIsY0FBYyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDckYsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsY0FBYyxFQUFFLFFBQVEsRUFBYSxRQUFRLEVBQUUsUUFBUSxFQUFrQixXQUFXLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFekksT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDbkQsT0FBTyxFQUFFLDJCQUEyQixFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDNUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7O0FBRzdDLG1GQUFtRjtBQUNuRixNQUFNLENBQUMsTUFBTSwwQkFBMEIsR0FBRyxJQUFJLGNBQWMsQ0FBdUIsNEJBQTRCLENBQUMsQ0FBQztBQUVqSCxvQkFBb0I7QUFDcEIsTUFBTSxVQUFVLDJDQUEyQyxDQUFDLE9BQWdCO0lBQ3hFLE9BQU8sR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQ3ZELENBQUM7QUFFRCxvQkFBb0I7QUFDcEIsTUFBTSxDQUFDLE1BQU0sbUNBQW1DLEdBQUc7SUFDL0MsT0FBTyxFQUFFLDBCQUEwQjtJQUNuQyxVQUFVLEVBQUUsMkNBQTJDO0lBQ3ZELElBQUksRUFBRSxDQUFDLE9BQU8sQ0FBQztDQUNsQixDQUFDO0FBU0YsTUFBTSxPQUFPLGdCQUFnQjtJQVF6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QUFDLENBQUM7U0FDdEM7SUFDTCxDQUFDO0lBRUQsOENBQThDO0lBQ3RDLGNBQWMsQ0FBQyxRQUE2QjtRQUNoRCxJQUFJLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1FBRXhCLE9BQU8sQ0FBQyxFQUFFLEVBQUU7WUFDUixxRkFBcUY7WUFDckYsZ0ZBQWdGO1lBQ2hGLCtFQUErRTtZQUMvRSxvREFBb0Q7WUFDcEQsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDO1NBQ3ZCO0lBQ0wsQ0FBQzs7NkdBdE5RLGdCQUFnQiwrSEFha0MsZ0JBQWdCLDJGQUUvRCwwQkFBMEI7aUhBZjdCLGdCQUFnQjsyRkFBaEIsZ0JBQWdCO2tCQUQ1QixVQUFVO21LQWNvRCxnQkFBZ0I7MEJBQXRFLFFBQVE7OzBCQUFJLFFBQVE7OzBCQUNwQixRQUFROzswQkFDUixNQUFNOzJCQUFDLDBCQUEwQjs7QUEwTTFDOzs7OztHQUtHO0FBQ0gsU0FBUyxvQkFBb0IsQ0FBQyxNQUF3QixFQUFFLGNBQWdDO0lBQ3BGLE9BQU8sRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLE1BQU0sRUFBRSxDQUFDO0FBQzVDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3Rpb24sIERpcmVjdGlvbmFsaXR5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2JpZGknO1xuaW1wb3J0IHsgRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5T3JpZ2luLCBPdmVybGF5LCBPdmVybGF5Q29uZmlnLCBPdmVybGF5UmVmLCBTY3JvbGxTdHJhdGVneSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9vdmVybGF5JztcbmltcG9ydCB7IENvbXBvbmVudFBvcnRhbCwgQ29tcG9uZW50VHlwZSwgVGVtcGxhdGVQb3J0YWwgfSBmcm9tICdAYW5ndWxhci9jZGsvcG9ydGFsJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0aW9uVG9rZW4sIEluamVjdG9yLCBPbkRlc3Ryb3ksIE9wdGlvbmFsLCBTa2lwU2VsZiwgU3RhdGljUHJvdmlkZXIsIFRlbXBsYXRlUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBSb3V0ZXIgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOeE92ZXJsYXlDb25maWcgfSBmcm9tICcuL292ZXJsYXktY29uZmlnJztcbmltcG9ydCB7IE54T3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCB9IGZyb20gJy4vb3ZlcmxheS1jb250YWluZXIuY29tcG9uZW50JztcbmltcG9ydCB7IE54T3ZlcmxheVJlZiB9IGZyb20gJy4vb3ZlcmxheS1yZWYnO1xuaW1wb3J0IHsgTnhPdmVybGF5UG9zaXRpb25CdWlsZGVyIH0gZnJvbSAnLi9wb3NpdGlvbi1idWlsZGVyJztcblxuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGRldGVybWluZXMgdGhlIHNjcm9sbCBoYW5kbGluZyB3aGlsZSBhIG92ZXJsYXkgaXMgb3Blbi4gKi9cbmV4cG9ydCBjb25zdCBOWF9PVkVSTEFZX1NDUk9MTF9TVFJBVEVHWSA9IG5ldyBJbmplY3Rpb25Ub2tlbjwoKSA9PiBTY3JvbGxTdHJhdGVneT4oJ254LW92ZXJsYXktc2Nyb2xsLXN0cmF0ZWd5Jyk7XG5cbi8qKiBAZG9jcy1wcml2YXRlICovXG5leHBvcnQgZnVuY3Rpb24gTlhfT1ZFUkxBWV9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVJfRkFDVE9SWShvdmVybGF5OiBPdmVybGF5KTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3kge1xuICAgIHJldHVybiAoKSA9PiBvdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMucmVwb3NpdGlvbigpO1xufVxuXG4vKiogQGRvY3MtcHJpdmF0ZSAqL1xuZXhwb3J0IGNvbnN0IE5YX09WRVJMQVlfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSID0ge1xuICAgIHByb3ZpZGU6IE5YX09WRVJMQVlfU0NST0xMX1NUUkFURUdZLFxuICAgIHVzZUZhY3Rvcnk6IE5YX09WRVJMQVlfU0NST0xMX1NUUkFURUdZX1BST1ZJREVSX0ZBQ1RPUlksXG4gICAgZGVwczogW092ZXJsYXldLFxufTtcblxuLyoqIFBvc3NpYmxlIHN0YXRlcyBvZiB0aGUgbGlmZWN5Y2xlIG9mIGEgb3ZlcmxheS4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIE54T3ZlcmxheVN0YXRlIHtcbiAgICBPUEVOLFxuICAgIENMT1NFRCxcbn1cblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE54T3ZlcmxheVNlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2FmdGVyQWxsQ2xvc2VkQXRUaGlzTGV2ZWwgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX2FmdGVyT3BlbmVkQXRUaGlzTGV2ZWwgPSBuZXcgU3ViamVjdDxOeE92ZXJsYXlSZWY8YW55Pj4oKTtcbiAgICBwcml2YXRlIF9vcGVuT3ZlcmxheXNBdFRoaXNMZXZlbDogTnhPdmVybGF5UmVmPGFueT5bXSA9IFtdO1xuXG4gICAgLyoqIFN0cmF0ZWd5IGZhY3RvcnkgdGhhdCB3aWxsIGJlIHVzZWQgdG8gaGFuZGxlIHNjcm9sbGluZyB3aGlsZSBhbiBvdmVybGF5IHBhbmVsIGlzIG9wZW4uICovXG4gICAgcHJpdmF0ZSBfc2Nyb2xsU3RyYXRlZ3lGYWN0b3J5ID0gdGhpcy5fZGVmYXVsdFNjcm9sbFN0cmF0ZWd5RmFjdG9yeTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIF9vdmVybGF5OiBPdmVybGF5LFxuICAgICAgICBwcml2YXRlIF9pbmplY3RvcjogSW5qZWN0b3IsXG4gICAgICAgIHByaXZhdGUgX3JvdXRlcjogUm91dGVyLFxuICAgICAgICBwcml2YXRlIF9wb3NpdGlvbkJ1aWxkZXI6IE54T3ZlcmxheVBvc2l0aW9uQnVpbGRlcixcbiAgICAgICAgQE9wdGlvbmFsKCkgQFNraXBTZWxmKCkgcHJpdmF0ZSBfcGFyZW50T3ZlcmxheVNlcnZpY2U6IE54T3ZlcmxheVNlcnZpY2UgfCBudWxsLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9kaXI6IERpcmVjdGlvbmFsaXR5IHwgbnVsbCxcbiAgICAgICAgQEluamVjdChOWF9PVkVSTEFZX1NDUk9MTF9TVFJBVEVHWSkgcHJpdmF0ZSBfZGVmYXVsdFNjcm9sbFN0cmF0ZWd5RmFjdG9yeTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3ksXG4gICAgKSB7fVxuXG4gICAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50bHktb3BlbiBvdmVybGF5cy4gKi9cbiAgICBnZXQgb3Blbk92ZXJsYXlzKCk6IE54T3ZlcmxheVJlZjxhbnk+W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50T3ZlcmxheVNlcnZpY2UgPyB0aGlzLl9wYXJlbnRPdmVybGF5U2VydmljZS5vcGVuT3ZlcmxheXMgOiB0aGlzLl9vcGVuT3ZlcmxheXNBdFRoaXNMZXZlbDtcbiAgICB9XG5cbiAgICAvKiogVGhlIHRleHQgZGlyZWN0aW9uIG9mIHRoZSBjb250YWluaW5nIGFwcC4gKi9cbiAgICBnZXQgZGlyKCk6IERpcmVjdGlvbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kaXIgJiYgdGhpcy5fZGlyLnZhbHVlID09PSAncnRsJyA/ICdydGwnIDogJ2x0cic7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBwYW5lbCBjb250YWluaW5nIHRoZSBnaXZlbiBjb21wb25lbnQgYW5kIGF0dGFjaGVzIGl0IHRvIGFuIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudE9yVGVtcGxhdGVSZWYgVHlwZSBvZiB0aGUgY29tcG9uZW50IHRvIGxvYWQgaW50byB0aGUgZGlhbG9nLFxuICAgICAqICAgICBvciBhIFRlbXBsYXRlUmVmIHRvIGluc3RhbnRpYXRlIGFzIHRoZSBwYW5lbCBjb250ZW50LlxuICAgICAqIEBwYXJhbSBjb25maWcgRXh0cmEgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIFJlZmVyZW5jZSB0byB0aGUgbmV3bHktb3BlbmVkIHBhbmVsLlxuICAgICAqL1xuICAgIG9wZW48VCwgRCA9IGFueSwgUiA9IGFueT4oXG4gICAgICAgIGNvbXBvbmVudE9yVGVtcGxhdGVSZWY6IENvbXBvbmVudFR5cGU8VD4gfCBUZW1wbGF0ZVJlZjxUPixcbiAgICAgICAgb3JpZ2luOiBGbGV4aWJsZUNvbm5lY3RlZFBvc2l0aW9uU3RyYXRlZ3lPcmlnaW4sXG4gICAgICAgIGNvbmZpZz86IE54T3ZlcmxheUNvbmZpZzxEPixcbiAgICApOiBOeE92ZXJsYXlSZWY8VCwgUj4ge1xuICAgICAgICBjb25maWcgPSBfYXBwbHlDb25maWdEZWZhdWx0cyhjb25maWcsIG5ldyBOeE92ZXJsYXlDb25maWcoKSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pZCAmJiB0aGlzLmdldE92ZXJsYXlCeUlkKGNvbmZpZy5pZCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBPdmVybGF5IHdpdGggaWQgXCIke2NvbmZpZy5pZH1cIiBleGlzdHMgYWxyZWFkeS4gVGhlIG92ZXJsYXkgaWQgbXVzdCBiZSB1bmlxdWUuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjZGtPdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheShjb25maWcsIG9yaWdpbik7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlDb250YWluZXIgPSB0aGlzLl9hdHRhY2hPdmVybGF5Q29udGFpbmVyKGNka092ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSB0aGlzLl9hdHRhY2hPdmVybGF5Q29udGVudDxULCBSPihjb21wb25lbnRPclRlbXBsYXRlUmVmLCBvdmVybGF5Q29udGFpbmVyLCBjZGtPdmVybGF5UmVmLCBjb25maWcsIG9yaWdpbik7XG5cbiAgICAgICAgdGhpcy5vcGVuT3ZlcmxheXMucHVzaChvdmVybGF5UmVmKTtcbiAgICAgICAgb3ZlcmxheVJlZi5hZnRlckNsb3NlZCgpLnN1YnNjcmliZSgoKSA9PiB0aGlzLl9yZW1vdmVPcGVuT3ZlcmxheShvdmVybGF5UmVmKSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy50cmlnZ2VyQnV0dG9uKSB7XG4gICAgICAgICAgICBjb25maWcudHJpZ2dlckJ1dHRvbi5zZXRUcmlnZ2VyQWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG92ZXJsYXlSZWY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYW4gb3BlbiBvdmVybGF5IGJ5IGl0cyBpZC5cbiAgICAgKiBAcGFyYW0gaWQgSUQgdG8gdXNlIHdoZW4gbG9va2luZyB1cCB0aGUgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBnZXRPdmVybGF5QnlJZChpZDogc3RyaW5nKTogTnhPdmVybGF5UmVmPGFueT4gfCB1bmRlZmluZWQge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVuT3ZlcmxheXMuZmluZChvdmVybGF5ID0+IG92ZXJsYXkuaWQgPT09IGlkKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgLy8gT25seSBjbG9zZSB0aGUgb3ZlcmxheXMgYXQgdGhpcyBsZXZlbCBvbiBkZXN0cm95XG4gICAgICAgIC8vIHNpbmNlIHRoZSBwYXJlbnQgc2VydmljZSBtYXkgc3RpbGwgYmUgYWN0aXZlLlxuICAgICAgICB0aGlzLl9jbG9zZU92ZXJsYXlzKHRoaXMuX29wZW5PdmVybGF5c0F0VGhpc0xldmVsKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJBbGxDbG9zZWRBdFRoaXNMZXZlbC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9hZnRlck9wZW5lZEF0VGhpc0xldmVsLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgb3ZlcmxheSBpbnRvIHdoaWNoIHRoZSBvdmVybGF5IHdpbGwgYmUgbG9hZGVkLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIG92ZXJsYXkgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBPdmVybGF5UmVmIGZvciB0aGUgY3JlYXRlZCBvdmVybGF5LlxuICAgICAqL1xuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoY29uZmlnOiBOeE92ZXJsYXlDb25maWcsIG9yaWdpbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5T3JpZ2luKTogT3ZlcmxheVJlZiB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZywgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkuY3JlYXRlKG92ZXJsYXlDb25maWcpO1xuICAgIH1cblxuICAgIC8qXG4gICAgICoqXG4gICAgICogQ3JlYXRlcyBhIENESyBvdmVybGF5IGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgb3ZlcmxheSBzZXJ2aWNlIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0gb3ZlcmxheUNvbmZpZyBUaGUgbnggb3ZlcmxheSBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybnMgVGhlIENESyBvdmVybGF5IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0T3ZlcmxheUNvbmZpZyhvdmVybGF5Q29uZmlnOiBOeE92ZXJsYXlDb25maWcsIG9yaWdpbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5T3JpZ2luKTogT3ZlcmxheUNvbmZpZyB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gbmV3IE92ZXJsYXlDb25maWcoe1xuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneTogb3ZlcmxheUNvbmZpZy5wb3NpdGlvblN0cmF0ZWd5IHx8IHRoaXMuX3Bvc2l0aW9uQnVpbGRlci5jcmVhdGVQb3NpdGlvblN0cmF0ZWd5KG9yaWdpbiwgb3ZlcmxheUNvbmZpZyksXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogb3ZlcmxheUNvbmZpZy5zY3JvbGxTdHJhdGVneSB8fCB0aGlzLl9zY3JvbGxTdHJhdGVneUZhY3RvcnkoKSxcbiAgICAgICAgICAgIHBhbmVsQ2xhc3M6IG92ZXJsYXlDb25maWcucGFuZWxDbGFzcyxcbiAgICAgICAgICAgIGhhc0JhY2tkcm9wOiBvdmVybGF5Q29uZmlnLmhhc0JhY2tkcm9wLFxuICAgICAgICAgICAgd2lkdGg6IG92ZXJsYXlDb25maWcud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG92ZXJsYXlDb25maWcuaGVpZ2h0LFxuICAgICAgICAgICAgbWluV2lkdGg6IG92ZXJsYXlDb25maWcubWluV2lkdGgsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IG92ZXJsYXlDb25maWcubWluSGVpZ2h0LFxuICAgICAgICAgICAgbWF4V2lkdGg6IG92ZXJsYXlDb25maWcubWF4V2lkdGgsXG4gICAgICAgICAgICBtYXhIZWlnaHQ6IG92ZXJsYXlDb25maWcubWF4SGVpZ2h0LFxuICAgICAgICAgICAgZGlzcG9zZU9uTmF2aWdhdGlvbjogb3ZlcmxheUNvbmZpZy5jbG9zZU9uTmF2aWdhdGlvbixcbiAgICAgICAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChvdmVybGF5Q29uZmlnLmJhY2tkcm9wQ2xhc3MpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2tkcm9wQ2xhc3MgPSBvdmVybGF5Q29uZmlnLmJhY2tkcm9wQ2xhc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuXG4gICAgZ2V0IGlzUnRsKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlyPy52YWx1ZSA9PT0gJ3J0bCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYW4gTnhPdmVybGF5Q29udGFpbmVyIHRvIHRoZSBhbHJlYWR5LWNyZWF0ZWQgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gY2RrT3ZlcmxheSBSZWZlcmVuY2UgdG8gdGhlIGRpYWxvZydzIHVuZGVybHlpbmcgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBvdmVybGF5IGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byBhIENvbXBvbmVudFJlZiBmb3IgdGhlIGF0dGFjaGVkIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9hdHRhY2hPdmVybGF5Q29udGFpbmVyKGNka092ZXJsYXk6IE92ZXJsYXlSZWYsIGNvbmZpZzogTnhPdmVybGF5Q29uZmlnKTogTnhPdmVybGF5Q29udGFpbmVyQ29tcG9uZW50IHtcbiAgICAgICAgY29uc3QgdXNlckluamVjdG9yID0gY29uZmlnPy52aWV3Q29udGFpbmVyUmVmPy5pbmplY3RvcjtcbiAgICAgICAgY29uc3QgaW5qZWN0b3IgPSBJbmplY3Rvci5jcmVhdGUoe1xuICAgICAgICAgICAgcGFyZW50OiB1c2VySW5qZWN0b3IgfHwgdGhpcy5faW5qZWN0b3IsXG4gICAgICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IE54T3ZlcmxheUNvbmZpZywgdXNlVmFsdWU6IGNvbmZpZyB9XSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3QgY29udGFpbmVyUG9ydGFsID0gbmV3IENvbXBvbmVudFBvcnRhbChOeE92ZXJsYXlDb250YWluZXJDb21wb25lbnQsIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmLCBpbmplY3RvciwgY29uZmlnLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IGNka092ZXJsYXkuYXR0YWNoPE54T3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudD4oY29udGFpbmVyUG9ydGFsKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyUmVmLmluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSB1c2VyLXByb3ZpZGVkIGNvbXBvbmVudCB0byB0aGUgYWxyZWFkeS1jcmVhdGVkIE54T3ZlcmxheUNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50T3JUZW1wbGF0ZVJlZiBUaGUgdHlwZSBvZiBjb21wb25lbnQgYmVpbmcgbG9hZGVkIGludG8gdGhlIGRpYWxvZyxcbiAgICAgKiAgICAgb3IgYSBUZW1wbGF0ZVJlZiB0byBpbnN0YW50aWF0ZSBhcyB0aGUgY29udGVudC5cbiAgICAgKiBAcGFyYW0gb3ZlcmxheUNvbnRhaW5lciBSZWZlcmVuY2UgdG8gdGhlIHdyYXBwaW5nIE54T3ZlcmxheUNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gY2RrT3ZlcmxheVJlZiBSZWZlcmVuY2UgdG8gdGhlIG92ZXJsYXkgaW4gd2hpY2ggdGhlIG92ZXJsYXkgcmVzaWRlcy5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBvdmVybGF5IGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgTnhPdmVybGF5UmVmIHRoYXQgc2hvdWxkIGJlIHJldHVybmVkIHRvIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHByaXZhdGUgX2F0dGFjaE92ZXJsYXlDb250ZW50PFQsIFI+KFxuICAgICAgICBjb21wb25lbnRPclRlbXBsYXRlUmVmOiBDb21wb25lbnRUeXBlPFQ+IHwgVGVtcGxhdGVSZWY8VD4sXG4gICAgICAgIG92ZXJsYXlDb250YWluZXI6IE54T3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCxcbiAgICAgICAgY2RrT3ZlcmxheVJlZjogT3ZlcmxheVJlZixcbiAgICAgICAgY29uZmlnOiBOeE92ZXJsYXlDb25maWcsXG4gICAgICAgIG9yaWdpbjogRmxleGlibGVDb25uZWN0ZWRQb3NpdGlvblN0cmF0ZWd5T3JpZ2luLFxuICAgICk6IE54T3ZlcmxheVJlZjxULCBSPiB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHJlZmVyZW5jZSB0byB0aGUgb3ZlcmxheSB3ZSdyZSBjcmVhdGluZyBpbiBvcmRlciB0byBnaXZlIHRoZSB1c2VyIGEgaGFuZGxlXG4gICAgICAgIC8vIHRvIG1vZGlmeSBhbmQgY2xvc2UgaXQuXG4gICAgICAgIGNvbnN0IG92ZXJsYXlSZWYgPSBuZXcgTnhPdmVybGF5UmVmPFQsIFI+KGNka092ZXJsYXlSZWYsIG92ZXJsYXlDb250YWluZXIsIG9yaWdpbiwgdGhpcy5fcm91dGVyLCBjb25maWcuaWQpO1xuXG4gICAgICAgIGlmIChjb21wb25lbnRPclRlbXBsYXRlUmVmIGluc3RhbmNlb2YgVGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIG92ZXJsYXlDb250YWluZXIuYXR0YWNoVGVtcGxhdGVQb3J0YWwobmV3IFRlbXBsYXRlUG9ydGFsPFQ+KGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIG51bGwhLCB7ICRpbXBsaWNpdDogb3ZlcmxheVJlZiB9IGFzIGFueSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5qZWN0b3IgPSB0aGlzLl9jcmVhdGVJbmplY3RvcjxUPihjb25maWcsIG92ZXJsYXlSZWYsIG92ZXJsYXlDb250YWluZXIpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudFJlZiA9IG92ZXJsYXlDb250YWluZXIuYXR0YWNoQ29tcG9uZW50UG9ydGFsPFQ+KG5ldyBDb21wb25lbnRQb3J0YWwoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiwgY29uZmlnLnZpZXdDb250YWluZXJSZWYsIGluamVjdG9yKSk7XG4gICAgICAgICAgICBvdmVybGF5UmVmLmNvbXBvbmVudEluc3RhbmNlID0gY29udGVudFJlZi5pbnN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdmVybGF5UmVmO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjdXN0b20gaW5qZWN0b3IgdG8gYmUgdXNlZCBpbnNpZGUgdGhlIG92ZXJsYXkuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IGxvYWRlZCBpbnNpZGVcbiAgICAgKiBvZiBhIG92ZXJsYXkgdG8gY2xvc2UgaXRzZWxmIGFuZCwgb3B0aW9uYWxseSwgdG8gcmV0dXJuIGEgdmFsdWUuXG4gICAgICogQHBhcmFtIGNvbmZpZyBDb25maWcgb2JqZWN0IHRoYXQgaXMgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIG92ZXJsYXkuXG4gICAgICogQHBhcmFtIG92ZXJsYXlSZWYgUmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5LlxuICAgICAqIEBwYXJhbSBjb250YWluZXIgT3ZlcmxheSBjb250YWluZXIgZWxlbWVudCB0aGF0IHdyYXBzIGFsbCBvZiB0aGUgY29udGVudHMuXG4gICAgICogQHJldHVybnMgVGhlIGN1c3RvbSBpbmplY3RvciB0aGF0IGNhbiBiZSB1c2VkIGluc2lkZSB0aGUgb3ZlcmxheS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9jcmVhdGVJbmplY3RvcjxUPihjb25maWc6IE54T3ZlcmxheUNvbmZpZywgb3ZlcmxheVJlZjogTnhPdmVybGF5UmVmPFQ+LCBvdmVybGF5Q29udGFpbmVyOiBOeE92ZXJsYXlDb250YWluZXJDb21wb25lbnQpOiBJbmplY3RvciB7XG4gICAgICAgIGNvbnN0IHVzZXJJbmplY3RvciA9IGNvbmZpZz8udmlld0NvbnRhaW5lclJlZj8uaW5qZWN0b3I7XG5cbiAgICAgICAgLy8gVGhlIE54T3ZlcmxheUNvbnRhaW5lciBpcyBpbmplY3RlZCBpbiB0aGUgcG9ydGFsIGFzIHRoZSBOeE92ZXJsYXlDb250YWluZXIgYW5kIHRoZSBvdmVybGF5cydzXG4gICAgICAgIC8vIGNvbnRlbnQgYXJlIGNyZWF0ZWQgb3V0IG9mIHRoZSBzYW1lIFZpZXdDb250YWluZXJSZWYgYW5kIGFzIHN1Y2gsIGFyZSBzaWJsaW5ncyBmb3IgaW5qZWN0b3JcbiAgICAgICAgLy8gcHVycG9zZXMuIFRvIGFsbG93IHRoZSBoaWVyYXJjaHkgdGhhdCBpcyBleHBlY3RlZCwgdGhlIE54T3ZlcmxheUNvbnRhaW5lciBpcyBleHBsaWNpdGx5XG4gICAgICAgIC8vIGFkZGVkIHRvIHRoZSBpbmplY3Rpb24gdG9rZW5zLlxuICAgICAgICBjb25zdCBwcm92aWRlcnM6IFN0YXRpY1Byb3ZpZGVyW10gPSBbXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE54T3ZlcmxheUNvbnRhaW5lckNvbXBvbmVudCwgdXNlVmFsdWU6IG92ZXJsYXlDb250YWluZXIgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTnhPdmVybGF5UmVmLCB1c2VWYWx1ZTogb3ZlcmxheVJlZiB9LFxuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBJbmplY3Rvci5jcmVhdGUoeyBwYXJlbnQ6IHVzZXJJbmplY3RvciB8fCB0aGlzLl9pbmplY3RvciwgcHJvdmlkZXJzIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBvdmVybGF5IGZyb20gdGhlIGFycmF5IG9mIG9wZW4gb3ZlcmxheXMuXG4gICAgICogQHBhcmFtIG92ZXJsYXlSZWYgT3ZlcmxheSB0byBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3JlbW92ZU9wZW5PdmVybGF5KG92ZXJsYXlSZWY6IE54T3ZlcmxheVJlZjxhbnk+KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcGVuT3ZlcmxheXMuaW5kZXhPZihvdmVybGF5UmVmKTtcblxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuT3ZlcmxheXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDbG9zZXMgYWxsIG9mIHRoZSBvdmVybGF5cyBpbiBhbiBhcnJheS4gKi9cbiAgICBwcml2YXRlIF9jbG9zZU92ZXJsYXlzKG92ZXJsYXlzOiBOeE92ZXJsYXlSZWY8YW55PltdKSB7XG4gICAgICAgIGxldCBpID0gb3ZlcmxheXMubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIC8vIFRoZSBgX29wZW5PdmVybGF5c2AgcHJvcGVydHkgaXNuJ3QgdXBkYXRlZCBhZnRlciBjbG9zZSB1bnRpbCB0aGUgcnhqcyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHJ1bnMgb24gdGhlIG5leHQgbWljcm90YXNrLCBpbiBhZGRpdGlvbiB0byBtb2RpZnlpbmcgdGhlIGFycmF5IGFzIHdlJ3JlIGdvaW5nXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0LiBXZSBsb29wIHRocm91Z2ggYWxsIG9mIHRoZW0gYW5kIGNhbGwgY2xvc2Ugd2l0aG91dCBhc3N1bWluZyB0aGF0XG4gICAgICAgICAgICAvLyB0aGV5J2xsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCBpbnN0YW50YW5lb3VzbHkuXG4gICAgICAgICAgICBvdmVybGF5c1tpXS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFwcGxpZXMgZGVmYXVsdCBvcHRpb25zIHRvIHRoZSBvdmVybGF5IGNvbmZpZy5cbiAqIEBwYXJhbSBjb25maWcgQ29uZmlnIHRvIGJlIG1vZGlmaWVkLlxuICogQHBhcmFtIGRlZmF1bHRPcHRpb25zIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZC5cbiAqIEByZXR1cm5zIFRoZSBuZXcgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIF9hcHBseUNvbmZpZ0RlZmF1bHRzKGNvbmZpZz86IE54T3ZlcmxheUNvbmZpZywgZGVmYXVsdE9wdGlvbnM/OiBOeE92ZXJsYXlDb25maWcpOiBOeE92ZXJsYXlDb25maWcge1xuICAgIHJldHVybiB7IC4uLmRlZmF1bHRPcHRpb25zLCAuLi5jb25maWcgfTtcbn1cbiJdfQ==