import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';
import { ChangeDetectionStrategy, Component, ContentChildren, EventEmitter, Input, Optional, Output, TemplateRef, ViewChild, ViewChildren, } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import { NxAutocompleteOptionComponent } from './autocomplete-option.component';
import * as i0 from "@angular/core";
import * as i1 from "@aposin/ng-aquila/formfield";
import * as i2 from "./autocomplete-option.component";
import * as i3 from "@angular/common";
/**
 * Autocomplete IDs need to be unique across components, so this counter exists outside of
 * the component definition.
 */
let _uniqueAutocompleteIdCounter = 0;
/** Event object that is emitted when an autocomplete option is selected. */
export class NxAutocompleteSelectedEvent {
    constructor(
    /** Reference to the autocomplete panel that emitted the event. */
    source, 
    /** Option that was selected. */
    option) {
        this.source = source;
        this.option = option;
    }
}
export class NxAutocompleteComponent {
    constructor(_cdr, _elementRef, formFieldComponent) {
        this._cdr = _cdr;
        this._elementRef = _elementRef;
        this.formFieldComponent = formFieldComponent;
        /** Whether the autocomplete panel should be visible, depending on option length. */
        this.showPanel = false;
        this._isOpen = false;
        this._items = null;
        this._hasItems = false;
        /** Event that is emitted whenever an option from the list is selected. */
        this.optionSelected = new EventEmitter();
        /** Event that is emitted when the autocomplete panel is opened. */
        this.opened = new EventEmitter();
        /** Event that is emitted when the autocomplete panel is closed. */
        this.closed = new EventEmitter();
        this._classList = {};
        /** Unique ID to be used by autocomplete trigger's "aria-owns" property. */
        this.id = `nx-autocomplete-${_uniqueAutocompleteIdCounter++}`;
        this._destroyed = new Subject();
        /**
         * Value to string converter function.
         * As an autocomplete option can hold any value, a converter might be needed
         * to get a string representation of the value, which can be stored in the input.
         *
         * Default: value ? value.toString() : null.
         */
        this.valueFormatter = (value) => (value ? value.toString() : null);
    }
    /** Whether the autocomplete panel is open. */
    get isOpen() {
        return this._isOpen && this.showPanel;
    }
    /** Items observable. If given, autocomplete takes care of the options and ng-content is discarderd */
    set items(val) {
        this._hasItems = true;
        if (Array.isArray(val)) {
            this._items = val;
        }
        else if (val instanceof Observable) {
            this._itemsSubscription?.unsubscribe();
            this._itemsSubscription = val.subscribe(itms => {
                this._items = itms;
                this._cdr.markForCheck();
                // and check visibility in next cycle, when options are set
                setTimeout(() => this._setVisibility());
            });
        }
        else if (val === null) {
            this._items = val;
        }
        else {
            throw new Error('Invalid argument for autocomplete items. It has to be Array<string> or Observable<Array<string>>');
        }
    }
    get items() {
        return this._items; // TODO properly coerce input as empty array
    }
    /**
     * @docs-private
     * Is items observable set
     */
    get hasItems() {
        return this._hasItems;
    }
    /** Autocomplete options */
    get options() {
        return this.hasItems ? this._vOptions : this._cOptions;
    }
    /**
     * Takes classes set on the host nx-autocomplete element and applies them to the panel
     * inside the overlay container to allow for easy styling.
     */
    set classList(value) {
        if (value?.length) {
            value.split(' ').forEach(className => (this._classList[className.trim()] = true));
            this._elementRef.nativeElement.className = '';
        }
    }
    ngAfterViewInit() {
        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();
        this._setVisibility();
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this._itemsSubscription?.unsubscribe();
    }
    /**
     * Sets the panel scrollTop. This allows us to manually scroll to display options
     * above or below the fold, as they are not actually being focused when active.
     */
    _setScrollTop(scrollTop) {
        if (this.panel) {
            this.panel.nativeElement.scrollTop = scrollTop;
        }
    }
    /** Returns the panel's scrollTop. */
    _getScrollTop() {
        return this.panel ? this.panel.nativeElement.scrollTop : 0;
    }
    /** Panel should hide itself when the option list is empty. */
    _setVisibility() {
        this.showPanel = !!this.options?.length;
        this._classList['nx-autocomplete-visible'] = this.showPanel;
        this._classList['nx-autocomplete-hidden'] = !this.showPanel;
        this._cdr.markForCheck();
    }
    /** Emits the `select` event. */
    _emitSelectEvent(option) {
        const event = new NxAutocompleteSelectedEvent(this, option);
        this.optionSelected.emit(event);
    }
    get _isInOutlineField() {
        return this.formFieldComponent !== null && this.formFieldComponent.appearance === 'outline';
    }
}
NxAutocompleteComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxAutocompleteComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i0.ElementRef }, { token: i1.NxFormfieldComponent, optional: true }], target: i0.ɵɵFactoryTarget.Component });
NxAutocompleteComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxAutocompleteComponent, selector: "nx-autocomplete", inputs: { items: "items", classList: ["class", "classList"], valueFormatter: ["nxValueFormatter", "valueFormatter"] }, outputs: { optionSelected: "optionSelected", opened: "opened", closed: "closed" }, host: { classAttribute: "nx-autocomplete" }, queries: [{ propertyName: "_cOptions", predicate: NxAutocompleteOptionComponent, descendants: true }], viewQueries: [{ propertyName: "template", first: true, predicate: TemplateRef, descendants: true }, { propertyName: "panel", first: true, predicate: ["panel"], descendants: true }, { propertyName: "_vOptions", predicate: NxAutocompleteOptionComponent, descendants: true }], exportAs: ["nxAutocomplete"], ngImport: i0, template: "<ng-template>\n    <div\n        class=\"nx-autocomplete-panel\"\n        role=\"listbox\"\n        [id]=\"id\"\n        [ngClass]=\"_classList\"\n        [class.nx-autocomplete-panel--in-outline-field]=\"_isInOutlineField\"\n        #panel\n    >\n        <ng-container *ngIf=\"hasItems\">\n            <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n                {{ item }}\n            </nx-autocomplete-option>\n        </ng-container>\n        <ng-container *ngIf=\"!hasItems\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</ng-template>\n", styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:var(--dropdown-panel-background-color);box-shadow:var(--shadow-small);overflow-y:auto;overflow-x:hidden;max-height:280px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option,.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option__label{font-size:var(--dropdown-item-outline-font-size);line-height:var(--dropdown-item-outline-line-height);font-weight:var(--dropdown-item-outline-font-weight);letter-spacing:var(--dropdown-item-outline-letter-spacing)}@media screen and (-ms-high-contrast: active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}\n"], components: [{ type: i2.NxAutocompleteOptionComponent, selector: "nx-autocomplete-option", inputs: ["disabled", "value"], outputs: ["onSelectionChange"] }], directives: [{ type: i3.NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { type: i3.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i3.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxAutocompleteComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-autocomplete', changeDetection: ChangeDetectionStrategy.OnPush, exportAs: 'nxAutocomplete', host: {
                        class: 'nx-autocomplete',
                    }, template: "<ng-template>\n    <div\n        class=\"nx-autocomplete-panel\"\n        role=\"listbox\"\n        [id]=\"id\"\n        [ngClass]=\"_classList\"\n        [class.nx-autocomplete-panel--in-outline-field]=\"_isInOutlineField\"\n        #panel\n    >\n        <ng-container *ngIf=\"hasItems\">\n            <nx-autocomplete-option *ngFor=\"let item of items\" [value]=\"item\">\n                {{ item }}\n            </nx-autocomplete-option>\n        </ng-container>\n        <ng-container *ngIf=\"!hasItems\">\n            <ng-content></ng-content>\n        </ng-container>\n    </div>\n</ng-template>\n", styles: [":host ::ng-deep .c-input::-ms-clear{width:0;height:0}.nx-autocomplete-panel{background-color:var(--dropdown-panel-background-color);box-shadow:var(--shadow-small);overflow-y:auto;overflow-x:hidden;max-height:280px;width:100%;border-radius:4px}.nx-autocomplete-panel.nx-autocomplete-visible{visibility:visible}.nx-autocomplete-panel.nx-autocomplete-hidden{visibility:hidden}.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option,.nx-autocomplete-panel--in-outline-field ::ng-deep nx-autocomplete-option .nx-autocomplete-option__label{font-size:var(--dropdown-item-outline-font-size);line-height:var(--dropdown-item-outline-line-height);font-weight:var(--dropdown-item-outline-font-weight);letter-spacing:var(--dropdown-item-outline-letter-spacing)}@media screen and (-ms-high-contrast: active){.nx-autocomplete-panel{box-shadow:0 0 0 1px windowText}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i0.ElementRef }, { type: i1.NxFormfieldComponent, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { template: [{
                type: ViewChild,
                args: [TemplateRef]
            }], panel: [{
                type: ViewChild,
                args: ['panel']
            }], items: [{
                type: Input
            }], optionSelected: [{
                type: Output
            }], opened: [{
                type: Output
            }], closed: [{
                type: Output
            }], _vOptions: [{
                type: ViewChildren,
                args: [NxAutocompleteOptionComponent]
            }], _cOptions: [{
                type: ContentChildren,
                args: [NxAutocompleteOptionComponent, { descendants: true }]
            }], classList: [{
                type: Input,
                args: ['class']
            }], valueFormatter: [{
                type: Input,
                args: ['nxValueFormatter']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25nLWFxdWlsYS9zcmMvYXV0b2NvbXBsZXRlL2F1dG9jb21wbGV0ZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL2F1dG9jb21wbGV0ZS9hdXRvY29tcGxldGUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDL0QsT0FBTyxFQUVILHVCQUF1QixFQUV2QixTQUFTLEVBQ1QsZUFBZSxFQUVmLFlBQVksRUFDWixLQUFLLEVBRUwsUUFBUSxFQUNSLE1BQU0sRUFFTixXQUFXLEVBQ1gsU0FBUyxFQUNULFlBQVksR0FDZixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsVUFBVSxFQUFFLE9BQU8sRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFFekQsT0FBTyxFQUFFLDZCQUE2QixFQUFFLE1BQU0saUNBQWlDLENBQUM7Ozs7O0FBRWhGOzs7R0FHRztBQUNILElBQUksNEJBQTRCLEdBQUcsQ0FBQyxDQUFDO0FBRXJDLDRFQUE0RTtBQUM1RSxNQUFNLE9BQU8sMkJBQTJCO0lBQ3BDO0lBQ0ksa0VBQWtFO0lBQzNELE1BQStCO0lBQ3RDLGdDQUFnQztJQUN6QixNQUFxQztRQUZyQyxXQUFNLEdBQU4sTUFBTSxDQUF5QjtRQUUvQixXQUFNLEdBQU4sTUFBTSxDQUErQjtJQUM3QyxDQUFDO0NBQ1A7QUFZRCxNQUFNLE9BQU8sdUJBQXVCO0lBMkdoQyxZQUFvQixJQUF1QixFQUFVLFdBQXVCLEVBQXNCLGtCQUErQztRQUE3SCxTQUFJLEdBQUosSUFBSSxDQUFtQjtRQUFVLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQXNCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBNkI7UUF2R2pKLG9GQUFv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QUM7UUFDNUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELElBQUksaUJBQWlCO1FBQ2pCLE9BQU8sSUFBSSxDQUFDLGtCQUFrQixLQUFLLElBQUksSUFBSSxJQUFJLENBQUMsa0JBQWtCLENBQUMsVUFBVSxLQUFLLFNBQVMsQ0FBQztJQUNoRyxDQUFDOztvSEF2SlEsdUJBQXVCO3dHQUF2Qix1QkFBdUIsd1VBdUVmLDZCQUE2QiwwRkF6RG5DLFdBQVcsZ0pBcURSLDZCQUE2Qiw4RUNwSC9DLDhsQkFtQkE7MkZEOEJhLHVCQUF1QjtrQkFWbkMsU0FBUzsrQkFDSSxpQkFBaUIsbUJBR1YsdUJBQXVCLENBQUMsTUFBTSxZQUNyQyxnQkFBZ0IsUUFDcEI7d0JBQ0YsS0FBSyxFQUFFLGlCQUFpQjtxQkFDM0I7OzBCQTZHOEUsUUFBUTs0Q0E3Ri9ELFFBQVE7c0JBQS9CLFNBQVM7dUJBQUMsV0FBVztnQkFNRixLQUFLO3NCQUF4QixTQUFTO3VCQUFDLE9BQU87Z0JBSWQsS0FBSztzQkFEUixLQUFLO2dCQW1DYSxjQUFjO3NCQUFoQyxNQUFNO2dCQUdZLE1BQU07c0JBQXhCLE1BQU07Z0JBR1ksTUFBTTtzQkFBeEIsTUFBTTtnQkFJQyxTQUFTO3NCQURoQixZQUFZO3VCQUFDLDZCQUE2QjtnQkFLbkMsU0FBUztzQkFEaEIsZUFBZTt1QkFBQyw2QkFBNkIsRUFBRSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUU7Z0JBYWpFLFNBQVM7c0JBRFosS0FBSzt1QkFBQyxPQUFPO2dCQXNCZCxjQUFjO3NCQURiLEtBQUs7dUJBQUMsa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aXZlRGVzY2VuZGFudEtleU1hbmFnZXIgfSBmcm9tICdAYW5ndWxhci9jZGsvYTExeSc7XG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBJbnB1dCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgVmlld0NoaWxkcmVuLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE54Rm9ybWZpZWxkQ29tcG9uZW50IH0gZnJvbSAnQGFwb3Npbi9uZy1hcXVpbGEvZm9ybWZpZWxkJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudCB9IGZyb20gJy4vYXV0b2NvbXBsZXRlLW9wdGlvbi5jb21wb25lbnQnO1xuXG4vKipcbiAqIEF1dG9jb21wbGV0ZSBJRHMgbmVlZCB0byBiZSB1bmlxdWUgYWNyb3NzIGNvbXBvbmVudHMsIHNvIHRoaXMgY291bnRlciBleGlzdHMgb3V0c2lkZSBvZlxuICogdGhlIGNvbXBvbmVudCBkZWZpbml0aW9uLlxuICovXG5sZXQgX3VuaXF1ZUF1dG9jb21wbGV0ZUlkQ291bnRlciA9IDA7XG5cbi8qKiBFdmVudCBvYmplY3QgdGhhdCBpcyBlbWl0dGVkIHdoZW4gYW4gYXV0b2NvbXBsZXRlIG9wdGlvbiBpcyBzZWxlY3RlZC4gKi9cbmV4cG9ydCBjbGFzcyBOeEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAvKiogUmVmZXJlbmNlIHRvIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgdGhhdCBlbWl0dGVkIHRoZSBldmVudC4gKi9cbiAgICAgICAgcHVibGljIHNvdXJjZTogTnhBdXRvY29tcGxldGVDb21wb25lbnQsXG4gICAgICAgIC8qKiBPcHRpb24gdGhhdCB3YXMgc2VsZWN0ZWQuICovXG4gICAgICAgIHB1YmxpYyBvcHRpb246IE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50LFxuICAgICkge31cbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdueC1hdXRvY29tcGxldGUnLFxuICAgIHRlbXBsYXRlVXJsOiAnYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnYXV0b2NvbXBsZXRlLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgZXhwb3J0QXM6ICdueEF1dG9jb21wbGV0ZScsXG4gICAgaG9zdDoge1xuICAgICAgICBjbGFzczogJ254LWF1dG9jb21wbGV0ZScsXG4gICAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTnhBdXRvY29tcGxldGVDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKiBNYW5hZ2VzIGFjdGl2ZSBpdGVtIGluIG9wdGlvbiBsaXN0IGJhc2VkIG9uIGtleSBldmVudHMuICovXG4gICAgX2tleU1hbmFnZXIhOiBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcjxOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudD47XG5cbiAgICAvKiogV2hldGhlciB0aGUgYXV0b2NvbXBsZXRlIHBhbmVsIHNob3VsZCBiZSB2aXNpYmxlLCBkZXBlbmRpbmcgb24gb3B0aW9uIGxlbmd0aC4gKi9cbiAgICBzaG93UGFuZWwgPSBmYWxzZTtcblxuICAgIC8qKiBXaGV0aGVyIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgaXMgb3Blbi4gKi9cbiAgICBnZXQgaXNPcGVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuICYmIHRoaXMuc2hvd1BhbmVsO1xuICAgIH1cbiAgICBfaXNPcGVuID0gZmFsc2U7XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIEBWaWV3Q2hpbGQoVGVtcGxhdGVSZWYpIHRlbXBsYXRlITogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKiBFbGVtZW50IGZvciB0aGUgcGFuZWwgY29udGFpbmluZyB0aGUgYXV0b2NvbXBsZXRlIG9wdGlvbnMuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgncGFuZWwnKSBwYW5lbCE6IEVsZW1lbnRSZWY7XG5cbiAgICAvKiogSXRlbXMgb2JzZXJ2YWJsZS4gSWYgZ2l2ZW4sIGF1dG9jb21wbGV0ZSB0YWtlcyBjYXJlIG9mIHRoZSBvcHRpb25zIGFuZCBuZy1jb250ZW50IGlzIGRpc2NhcmRlcmQgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBpdGVtcyh2YWw6IHN0cmluZ1tdIHwgT2JzZXJ2YWJsZTxzdHJpbmdbXT4pIHtcbiAgICAgICAgdGhpcy5faGFzSXRlbXMgPSB0cnVlO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtc1N1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX2l0ZW1zU3Vic2NyaXB0aW9uID0gdmFsLnN1YnNjcmliZShpdG1zID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pdGVtcyA9IGl0bXM7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICAgICAgICAgIC8vIGFuZCBjaGVjayB2aXNpYmlsaXR5IGluIG5leHQgY3ljbGUsIHdoZW4gb3B0aW9ucyBhcmUgc2V0XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLl9zZXRWaXNpYmlsaXR5KCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9pdGVtcyA9IHZhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBmb3IgYXV0b2NvbXBsZXRlIGl0ZW1zLiBJdCBoYXMgdG8gYmUgQXJyYXk8c3RyaW5nPiBvciBPYnNlcnZhYmxlPEFycmF5PHN0cmluZz4+Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCk6IHN0cmluZ1tdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zIGFzIHN0cmluZ1tdOyAvLyBUT0RPIHByb3Blcmx5IGNvZXJjZSBpbnB1dCBhcyBlbXB0eSBhcnJheVxuICAgIH1cbiAgICBwcml2YXRlIF9pdGVtczogc3RyaW5nW10gfCBudWxsID0gbnVsbDtcbiAgICBwcml2YXRlIF9pdGVtc1N1YnNjcmlwdGlvbj86IFN1YnNjcmlwdGlvbjtcblxuICAgIC8qKlxuICAgICAqIEBkb2NzLXByaXZhdGVcbiAgICAgKiBJcyBpdGVtcyBvYnNlcnZhYmxlIHNldFxuICAgICAqL1xuICAgIGdldCBoYXNJdGVtcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0l0ZW1zO1xuICAgIH1cbiAgICBwcml2YXRlIF9oYXNJdGVtcyA9IGZhbHNlO1xuXG4gICAgLyoqIEV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuZXZlciBhbiBvcHRpb24gZnJvbSB0aGUgbGlzdCBpcyBzZWxlY3RlZC4gKi9cbiAgICBAT3V0cHV0KCkgcmVhZG9ubHkgb3B0aW9uU2VsZWN0ZWQ6IEV2ZW50RW1pdHRlcjxOeEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxOeEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQ+KCk7XG5cbiAgICAvKiogRXZlbnQgdGhhdCBpcyBlbWl0dGVkIHdoZW4gdGhlIGF1dG9jb21wbGV0ZSBwYW5lbCBpcyBvcGVuZWQuICovXG4gICAgQE91dHB1dCgpIHJlYWRvbmx5IG9wZW5lZDogRXZlbnRFbWl0dGVyPHZvaWQ+ID0gbmV3IEV2ZW50RW1pdHRlcjx2b2lkPigpO1xuXG4gICAgLyoqIEV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHRoZSBhdXRvY29tcGxldGUgcGFuZWwgaXMgY2xvc2VkLiAqL1xuICAgIEBPdXRwdXQoKSByZWFkb25seSBjbG9zZWQ6IEV2ZW50RW1pdHRlcjx2b2lkPiA9IG5ldyBFdmVudEVtaXR0ZXI8dm9pZD4oKTtcblxuICAgIC8qKiBBdXRvY29tcGxldGUgb3B0aW9ucyBpbiB2aWV3IC0gaWUgZnJvbSBpdGVtcyAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oTnhBdXRvY29tcGxldGVPcHRpb25Db21wb25lbnQpXG4gICAgcHJpdmF0ZSBfdk9wdGlvbnMhOiBRdWVyeUxpc3Q8TnhBdXRvY29tcGxldGVPcHRpb25Db21wb25lbnQ+O1xuXG4gICAgLyoqIEF1dG9jb21wbGV0ZSBvcHRpb25zIGluIGNvbnRlbnQgLSBpZSB1c2VyIHByb3ZpZGVkICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudCwgeyBkZXNjZW5kYW50czogdHJ1ZSB9KVxuICAgIHByaXZhdGUgX2NPcHRpb25zITogUXVlcnlMaXN0PE54QXV0b2NvbXBsZXRlT3B0aW9uQ29tcG9uZW50PjtcblxuICAgIC8qKiBBdXRvY29tcGxldGUgb3B0aW9ucyAqL1xuICAgIGdldCBvcHRpb25zKCk6IFF1ZXJ5TGlzdDxOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNJdGVtcyA/IHRoaXMuX3ZPcHRpb25zIDogdGhpcy5fY09wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGFrZXMgY2xhc3NlcyBzZXQgb24gdGhlIGhvc3QgbngtYXV0b2NvbXBsZXRlIGVsZW1lbnQgYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgcGFuZWxcbiAgICAgKiBpbnNpZGUgdGhlIG92ZXJsYXkgY29udGFpbmVyIHRvIGFsbG93IGZvciBlYXN5IHN0eWxpbmcuXG4gICAgICovXG4gICAgQElucHV0KCdjbGFzcycpXG4gICAgc2V0IGNsYXNzTGlzdCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGlmICh2YWx1ZT8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YWx1ZS5zcGxpdCgnICcpLmZvckVhY2goY2xhc3NOYW1lID0+ICh0aGlzLl9jbGFzc0xpc3RbY2xhc3NOYW1lLnRyaW0oKV0gPSB0cnVlKSk7XG4gICAgICAgICAgICB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2xhc3NOYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2NsYXNzTGlzdDogeyBba2V5OiBzdHJpbmddOiBib29sZWFuIH0gPSB7fTtcblxuICAgIC8qKiBVbmlxdWUgSUQgdG8gYmUgdXNlZCBieSBhdXRvY29tcGxldGUgdHJpZ2dlcidzIFwiYXJpYS1vd25zXCIgcHJvcGVydHkuICovXG4gICAgaWQgPSBgbngtYXV0b2NvbXBsZXRlLSR7X3VuaXF1ZUF1dG9jb21wbGV0ZUlkQ291bnRlcisrfWA7XG5cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9kZXN0cm95ZWQgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gc3RyaW5nIGNvbnZlcnRlciBmdW5jdGlvbi5cbiAgICAgKiBBcyBhbiBhdXRvY29tcGxldGUgb3B0aW9uIGNhbiBob2xkIGFueSB2YWx1ZSwgYSBjb252ZXJ0ZXIgbWlnaHQgYmUgbmVlZGVkXG4gICAgICogdG8gZ2V0IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB2YWx1ZSwgd2hpY2ggY2FuIGJlIHN0b3JlZCBpbiB0aGUgaW5wdXQuXG4gICAgICpcbiAgICAgKiBEZWZhdWx0OiB2YWx1ZSA/IHZhbHVlLnRvU3RyaW5nKCkgOiBudWxsLlxuICAgICAqL1xuICAgIEBJbnB1dCgnbnhWYWx1ZUZvcm1hdHRlcicpXG4gICAgdmFsdWVGb3JtYXR0ZXI6ICh2YWx1ZTogYW55KSA9PiBzdHJpbmcgPSAodmFsdWU6IGFueSkgPT4gKHZhbHVlID8gdmFsdWUudG9TdHJpbmcoKSA6IG51bGwpO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfY2RyOiBDaGFuZ2VEZXRlY3RvclJlZiwgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZiwgQE9wdGlvbmFsKCkgcHJpdmF0ZSBmb3JtRmllbGRDb21wb25lbnQ6IE54Rm9ybWZpZWxkQ29tcG9uZW50IHwgbnVsbCkge31cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fa2V5TWFuYWdlciA9IG5ldyBBY3RpdmVEZXNjZW5kYW50S2V5TWFuYWdlcjxOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudD4odGhpcy5vcHRpb25zKS53aXRoV3JhcCgpO1xuICAgICAgICB0aGlzLl9zZXRWaXNpYmlsaXR5KCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuICAgICAgICB0aGlzLl9pdGVtc1N1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwYW5lbCBzY3JvbGxUb3AuIFRoaXMgYWxsb3dzIHVzIHRvIG1hbnVhbGx5IHNjcm9sbCB0byBkaXNwbGF5IG9wdGlvbnNcbiAgICAgKiBhYm92ZSBvciBiZWxvdyB0aGUgZm9sZCwgYXMgdGhleSBhcmUgbm90IGFjdHVhbGx5IGJlaW5nIGZvY3VzZWQgd2hlbiBhY3RpdmUuXG4gICAgICovXG4gICAgX3NldFNjcm9sbFRvcChzY3JvbGxUb3A6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5wYW5lbCkge1xuICAgICAgICAgICAgdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSBwYW5lbCdzIHNjcm9sbFRvcC4gKi9cbiAgICBfZ2V0U2Nyb2xsVG9wKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhbmVsID8gdGhpcy5wYW5lbC5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCA6IDA7XG4gICAgfVxuXG4gICAgLyoqIFBhbmVsIHNob3VsZCBoaWRlIGl0c2VsZiB3aGVuIHRoZSBvcHRpb24gbGlzdCBpcyBlbXB0eS4gKi9cbiAgICBfc2V0VmlzaWJpbGl0eSgpIHtcbiAgICAgICAgdGhpcy5zaG93UGFuZWwgPSAhIXRoaXMub3B0aW9ucz8ubGVuZ3RoO1xuICAgICAgICB0aGlzLl9jbGFzc0xpc3RbJ254LWF1dG9jb21wbGV0ZS12aXNpYmxlJ10gPSB0aGlzLnNob3dQYW5lbDtcbiAgICAgICAgdGhpcy5fY2xhc3NMaXN0WydueC1hdXRvY29tcGxldGUtaGlkZGVuJ10gPSAhdGhpcy5zaG93UGFuZWw7XG4gICAgICAgIHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKiogRW1pdHMgdGhlIGBzZWxlY3RgIGV2ZW50LiAqL1xuICAgIF9lbWl0U2VsZWN0RXZlbnQob3B0aW9uOiBOeEF1dG9jb21wbGV0ZU9wdGlvbkNvbXBvbmVudCk6IHZvaWQge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBOeEF1dG9jb21wbGV0ZVNlbGVjdGVkRXZlbnQodGhpcywgb3B0aW9uKTtcbiAgICAgICAgdGhpcy5vcHRpb25TZWxlY3RlZC5lbWl0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBnZXQgX2lzSW5PdXRsaW5lRmllbGQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1GaWVsZENvbXBvbmVudCAhPT0gbnVsbCAmJiB0aGlzLmZvcm1GaWVsZENvbXBvbmVudC5hcHBlYXJhbmNlID09PSAnb3V0bGluZSc7XG4gICAgfVxufVxuIiwiPG5nLXRlbXBsYXRlPlxuICAgIDxkaXZcbiAgICAgICAgY2xhc3M9XCJueC1hdXRvY29tcGxldGUtcGFuZWxcIlxuICAgICAgICByb2xlPVwibGlzdGJveFwiXG4gICAgICAgIFtpZF09XCJpZFwiXG4gICAgICAgIFtuZ0NsYXNzXT1cIl9jbGFzc0xpc3RcIlxuICAgICAgICBbY2xhc3MubngtYXV0b2NvbXBsZXRlLXBhbmVsLS1pbi1vdXRsaW5lLWZpZWxkXT1cIl9pc0luT3V0bGluZUZpZWxkXCJcbiAgICAgICAgI3BhbmVsXG4gICAgPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaGFzSXRlbXNcIj5cbiAgICAgICAgICAgIDxueC1hdXRvY29tcGxldGUtb3B0aW9uICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zXCIgW3ZhbHVlXT1cIml0ZW1cIj5cbiAgICAgICAgICAgICAgICB7eyBpdGVtIH19XG4gICAgICAgICAgICA8L254LWF1dG9jb21wbGV0ZS1vcHRpb24+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIWhhc0l0ZW1zXCI+XG4gICAgICAgICAgICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cbiJdfQ==