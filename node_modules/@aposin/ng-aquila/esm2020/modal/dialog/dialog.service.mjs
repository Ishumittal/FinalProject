import { Overlay, OverlayConfig } from '@angular/cdk/overlay';
import { ComponentPortal, TemplatePortal } from '@angular/cdk/portal';
import { Inject, Injectable, InjectionToken, Injector, Optional, SkipSelf, TemplateRef } from '@angular/core';
import { defer, Subject } from 'rxjs';
import { startWith, takeUntil } from 'rxjs/operators';
import { NxModalConfig } from './modal-config';
import { NxModalContainer } from './modal-container.component';
import { NxModalRef } from './modal-ref';
import * as i0 from "@angular/core";
import * as i1 from "@angular/cdk/overlay";
import * as i2 from "./modal-config";
/** Injection token that can be used to access the data that was passed in to a modal. */
export const NX_MODAL_DATA = new InjectionToken('NxModalData');
/** Injection token that can be used to specify default modal options. */
export const NX_MODAL_DEFAULT_OPTIONS = new InjectionToken('nx-modal-default-options');
/** Injection token that determines the scroll handling while a modal is open. */
export const NX_MODAL_SCROLL_STRATEGY = new InjectionToken('nx-modal-scroll-strategy');
/** @docs-private */
export function NX_MODAL_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {
    return () => overlay.scrollStrategies.block();
}
/** @docs-private */
export const NX_MODAL_SCROLL_STRATEGY_PROVIDER = {
    provide: NX_MODAL_SCROLL_STRATEGY,
    useFactory: NX_MODAL_SCROLL_STRATEGY_PROVIDER_FACTORY,
    deps: [Overlay],
};
/**
 * Service to open Material Design modal modals.
 */
export class NxDialogService {
    constructor(_overlay, _injector, _defaultOptions, _parentDialogService, _overlayContainer, _defaultScrollStrategyFactory) {
        this._overlay = _overlay;
        this._injector = _injector;
        this._defaultOptions = _defaultOptions;
        this._parentDialogService = _parentDialogService;
        this._overlayContainer = _overlayContainer;
        this._defaultScrollStrategyFactory = _defaultScrollStrategyFactory;
        this._openModalsAtThisLevel = [];
        this._afterAllClosedAtThisLevel = new Subject();
        this._afterOpenedAtThisLevel = new Subject();
        this._ariaHiddenElements = new Map();
        /**
         * Stream that emits when all open modal have finished closing.
         * Will emit on subscribe if there are no open modals to begin with.
         */
        this.afterAllClosed = defer(() => this.openModals.length ? this._afterAllClosed : this._afterAllClosed.pipe(startWith(undefined)));
        this._destroyed = new Subject();
        /** Strategy factory that will be used to handle scrolling while the modal panel is open. */
        this._scrollStrategyFactory = this._defaultScrollStrategyFactory;
    }
    /** Keeps track of the currently-open modals. */
    get openModals() {
        return this._parentDialogService ? this._parentDialogService.openModals : this._openModalsAtThisLevel;
    }
    /** Stream that emits when a modal has been opened. */
    get afterOpened() {
        return this._parentDialogService ? this._parentDialogService.afterOpened : this._afterOpenedAtThisLevel;
    }
    get _afterAllClosed() {
        const parent = this._parentDialogService;
        return parent ? parent._afterAllClosed : this._afterAllClosedAtThisLevel;
    }
    /**
     * Opens a modal modal containing the given component.
     * @param componentOrTemplateRef Type of the component to load into the dialog,
     *     or a TemplateRef to instantiate as the modal content.
     * @param config Extra configuration options.
     * @returns Reference to the newly-opened modal.
     */
    open(componentOrTemplateRef, config) {
        config = _applyConfigDefaults(config, this._defaultOptions || new NxModalConfig());
        if (config.id && this.getModalById(config.id)) {
            throw Error(`Modal with id "${config.id}" exists already. The modal id must be unique.`);
        }
        const overlayRef = this._createOverlay(config);
        const modalContainer = this._attachModalContainer(overlayRef, config);
        const modalRef = this._attachModalContent(componentOrTemplateRef, modalContainer, overlayRef, config);
        // If this is the first modal that we're opening, hide all the non-overlay content.
        if (!this.openModals.length) {
            this._hideNonModalContentFromAssistiveTechnology();
        }
        this.openModals.push(modalRef);
        modalRef.afterClosed().subscribe(() => this._removeOpenModal(modalRef));
        this.afterOpened.next(modalRef);
        return modalRef;
    }
    /**
     * Closes all of the currently-open modals.
     */
    closeAll() {
        this._closeModals(this.openModals);
    }
    /**
     * Finds an open modal by its id.
     * @param id ID to use when looking up the modal.
     */
    getModalById(id) {
        return this.openModals.find(modal => modal.id === id);
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        // Only close the modals at this level on destroy
        // since the parent service may still be active.
        this._closeModals(this._openModalsAtThisLevel);
        this._afterAllClosedAtThisLevel.complete();
        this._afterOpenedAtThisLevel.complete();
    }
    /**
     * Creates the overlay into which the modal will be loaded.
     * @param config The modal configuration.
     * @returns A promise resolving to the OverlayRef for the created overlay.
     */
    _createOverlay(config) {
        const overlayConfig = this._getOverlayConfig(config);
        return this._overlay.create(overlayConfig);
    }
    /**
     * Creates an overlay config from a modal config.
     * @param modalConfig The modal configuration.
     * @returns The overlay configuration.
     */
    _getOverlayConfig(modalConfig) {
        const state = new OverlayConfig({
            positionStrategy: this._overlay.position().global(),
            scrollStrategy: modalConfig.scrollStrategy || this._scrollStrategyFactory(),
            panelClass: modalConfig.panelClass,
            hasBackdrop: modalConfig.hasBackdrop,
            minWidth: modalConfig.minWidth,
            minHeight: modalConfig.minHeight,
            maxWidth: modalConfig.maxWidth,
            maxHeight: modalConfig.maxHeight,
            disposeOnNavigation: modalConfig.closeOnNavigation,
            direction: modalConfig.direction,
        });
        if (modalConfig.backdropClass) {
            state.backdropClass = modalConfig.backdropClass;
        }
        return state;
    }
    /**
     * Attaches an NxModalContainer to a dialog's already-created overlay.
     * @param overlay Reference to the dialog's underlying overlay.
     * @param config The modal configuration.
     * @returns A promise resolving to a ComponentRef for the attached container.
     */
    _attachModalContainer(overlay, config) {
        const userInjector = config?.viewContainerRef?.injector;
        const injector = Injector.create({
            parent: userInjector || this._injector,
            providers: [{ provide: NxModalConfig, useValue: config }],
        });
        const containerPortal = new ComponentPortal(NxModalContainer, config.viewContainerRef, injector, config.componentFactoryResolver);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    /**
     * Attaches the user-provided component to the already-created NxModalContainer.
     * @param componentOrTemplateRef The type of component being loaded into the dialog,
     *     or a TemplateRef to instantiate as the content.
     * @param modalContainer Reference to the wrapping NxModalContainer.
     * @param overlayRef Reference to the overlay in which the modal resides.
     * @param config The modal configuration.
     * @returns A promise resolving to the NxModalRef that should be returned to the user.
     */
    _attachModalContent(componentOrTemplateRef, modalContainer, overlayRef, config) {
        // Create a reference to the modal we're creating in order to give the user a handle
        // to modify and close it.
        const modalRef = new NxModalRef(overlayRef, modalContainer, config.id);
        // When the modal backdrop is clicked, we want to close it.
        if (config.hasBackdrop) {
            overlayRef
                .backdropClick()
                .pipe(takeUntil(this._destroyed))
                .subscribe(() => {
                if (!modalRef.disableClose) {
                    modalRef.close();
                }
            });
        }
        if (componentOrTemplateRef instanceof TemplateRef) {
            modalContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, { $implicit: config.data, modalRef }));
        }
        else {
            const injector = this._createInjector(config, modalRef, modalContainer);
            const contentRef = modalContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));
            modalRef.componentInstance = contentRef.instance;
        }
        modalRef.updateSize(config.width, config.height).updatePosition(config.position);
        return modalRef;
    }
    /**
     * Creates a custom injector to be used inside the modal. This allows a component loaded inside
     * of a modal to close itself and, optionally, to return a value.
     * @param config Config object that is used to construct the modal.
     * @param modalRef Reference to the modal.
     * @param container Modal container element that wraps all of the contents.
     * @returns The custom injector that can be used inside the modal.
     */
    _createInjector(config, modalRef, modalContainer) {
        const userInjector = config?.viewContainerRef?.injector;
        // The NxModalContainer is injected in the portal as the NxModalContainer and the dialog's
        // content are created out of the same ViewContainerRef and as such, are siblings for injector
        // purposes. To allow the hierarchy that is expected, the NxModalContainer is explicitly
        // added to the injection tokens.
        const providers = [
            { provide: NxModalContainer, useValue: modalContainer },
            { provide: NX_MODAL_DATA, useValue: config.data },
            { provide: NxModalRef, useValue: modalRef },
        ];
        return Injector.create({ parent: userInjector || this._injector, providers });
    }
    /**
     * Removes a modal from the array of open modals.
     * @param modalRef Modal to be removed.
     */
    _removeOpenModal(modalRef) {
        const index = this.openModals.indexOf(modalRef);
        if (index > -1) {
            this.openModals.splice(index, 1);
            // If all the modals were closed, remove/restore the `aria-hidden`
            // to a the siblings and emit to the `afterAllClosed` stream.
            if (!this.openModals.length) {
                this._ariaHiddenElements.forEach((previousValue, element) => {
                    if (previousValue) {
                        element.setAttribute('aria-hidden', previousValue);
                    }
                    else {
                        element.removeAttribute('aria-hidden');
                    }
                });
                this._ariaHiddenElements.clear();
                this._afterAllClosed.next();
            }
        }
    }
    /**
     * Hides all of the content that isn't an overlay from assistive technology.
     */
    _hideNonModalContentFromAssistiveTechnology() {
        const overlayContainer = this._overlayContainer.getContainerElement();
        // Ensure that the overlay container is attached to the DOM.
        if (overlayContainer.parentElement) {
            const siblings = overlayContainer.parentElement.children;
            for (let i = siblings.length - 1; i > -1; i--) {
                const sibling = siblings[i];
                if (sibling !== overlayContainer && sibling.nodeName !== 'SCRIPT' && sibling.nodeName !== 'STYLE' && !sibling.hasAttribute('aria-live')) {
                    this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                    sibling.setAttribute('aria-hidden', 'true');
                }
            }
        }
    }
    /** Closes all of the modals in an array. */
    _closeModals(modals) {
        let i = modals.length;
        while (i--) {
            // The `_openModals` property isn't updated after close until the rxjs subscription
            // runs on the next microtask, in addition to modifying the array as we're going
            // through it. We loop through all of them and call close without assuming that
            // they'll be removed from the list instantaneously.
            modals[i].close();
        }
    }
}
NxDialogService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDialogService, deps: [{ token: i1.Overlay }, { token: i0.Injector }, { token: NX_MODAL_DEFAULT_OPTIONS, optional: true }, { token: NxDialogService, optional: true, skipSelf: true }, { token: i1.OverlayContainer }, { token: NX_MODAL_SCROLL_STRATEGY }], target: i0.ɵɵFactoryTarget.Injectable });
NxDialogService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDialogService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxDialogService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Overlay }, { type: i0.Injector }, { type: i2.NxModalConfig, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [NX_MODAL_DEFAULT_OPTIONS]
                }] }, { type: NxDialogService, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }] }, { type: i1.OverlayContainer }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [NX_MODAL_SCROLL_STRATEGY]
                }] }]; } });
/**
 * Applies default options to the modal config.
 * @param config Config to be modified.
 * @param defaultOptions Default options provided.
 * @returns The new configuration object.
 */
function _applyConfigDefaults(config, defaultOptions) {
    return { ...defaultOptions, ...config };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlhbG9nLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL21vZGFsL2RpYWxvZy9kaWFsb2cuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsT0FBTyxFQUFFLGFBQWEsRUFBZ0QsTUFBTSxzQkFBc0IsQ0FBQztBQUM1RyxPQUFPLEVBQUUsZUFBZSxFQUFpQixjQUFjLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNyRixPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFhLFFBQVEsRUFBRSxRQUFRLEVBQWtCLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6SSxPQUFPLEVBQUUsS0FBSyxFQUFjLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRCxPQUFPLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXRELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw2QkFBNkIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sYUFBYSxDQUFDOzs7O0FBRXpDLHlGQUF5RjtBQUN6RixNQUFNLENBQUMsTUFBTSxhQUFhLEdBQUcsSUFBSSxjQUFjLENBQU0sYUFBYSxDQUFDLENBQUM7QUFFcEUseUVBQXlFO0FBQ3pFLE1BQU0sQ0FBQyxNQUFNLHdCQUF3QixHQUFHLElBQUksY0FBYyxDQUFnQiwwQkFBMEIsQ0FBQyxDQUFDO0FBRXRHLGlGQUFpRjtBQUNqRixNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLGNBQWMsQ0FBdUIsMEJBQTBCLENBQUMsQ0FBQztBQUU3RyxvQkFBb0I7QUFDcEIsTUFBTSxVQUFVLHlDQUF5QyxDQUFDLE9BQWdCO0lBQ3RFLE9BQU8sR0FB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UUFBUSxJQUFJLE9BQU8sQ0FBQyxRQUFRLEtBQUssT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxXQUFXLENBQUMsRUFBRTtvQkFDckksSUFBSSxDQUFDLG1CQUFtQixDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO29CQUMzRSxPQUFPLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRSxNQUFNLENBQUMsQ0FBQztpQkFDL0M7YUFDSjtTQUNKO0lBQ0wsQ0FBQztJQUVELDRDQUE0QztJQUNwQyxZQUFZLENBQUMsTUFBeUI7UUFDMUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztRQUV0QixPQUFPLENBQUMsRUFBRSxFQUFFO1lBQ1IsbUZBQW1GO1lBQ25GLGdGQUFnRjtZQUNoRiwrRUFBK0U7WUFDL0Usb0RBQW9EO1lBQ3BELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUNyQjtJQUNMLENBQUM7OzRHQXpSUSxlQUFlLGlFQXFDQSx3QkFBd0IsNkJBQ1UsZUFBZSw2RUFFN0Qsd0JBQXdCO2dIQXhDM0IsZUFBZTsyRkFBZixlQUFlO2tCQUQzQixVQUFVOzswQkFzQ0YsUUFBUTs7MEJBQUksTUFBTTsyQkFBQyx3QkFBd0I7OEJBQ1UsZUFBZTswQkFBcEUsUUFBUTs7MEJBQUksUUFBUTs7MEJBRXBCLE1BQU07MkJBQUMsd0JBQXdCOztBQW9QeEM7Ozs7O0dBS0c7QUFDSCxTQUFTLG9CQUFvQixDQUFDLE1BQXNCLEVBQUUsY0FBOEI7SUFDaEYsT0FBTyxFQUFFLEdBQUcsY0FBYyxFQUFFLEdBQUcsTUFBTSxFQUFFLENBQUM7QUFDNUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE92ZXJsYXksIE92ZXJsYXlDb25maWcsIE92ZXJsYXlDb250YWluZXIsIE92ZXJsYXlSZWYsIFNjcm9sbFN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvY2RrL292ZXJsYXknO1xuaW1wb3J0IHsgQ29tcG9uZW50UG9ydGFsLCBDb21wb25lbnRUeXBlLCBUZW1wbGF0ZVBvcnRhbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9wb3J0YWwnO1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiwgSW5qZWN0b3IsIE9uRGVzdHJveSwgT3B0aW9uYWwsIFNraXBTZWxmLCBTdGF0aWNQcm92aWRlciwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRlZmVyLCBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzdGFydFdpdGgsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgTnhNb2RhbENvbmZpZyB9IGZyb20gJy4vbW9kYWwtY29uZmlnJztcbmltcG9ydCB7IE54TW9kYWxDb250YWluZXIgfSBmcm9tICcuL21vZGFsLWNvbnRhaW5lci5jb21wb25lbnQnO1xuaW1wb3J0IHsgTnhNb2RhbFJlZiB9IGZyb20gJy4vbW9kYWwtcmVmJztcblxuLyoqIEluamVjdGlvbiB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGUgZGF0YSB0aGF0IHdhcyBwYXNzZWQgaW4gdG8gYSBtb2RhbC4gKi9cbmV4cG9ydCBjb25zdCBOWF9NT0RBTF9EQVRBID0gbmV3IEluamVjdGlvblRva2VuPGFueT4oJ054TW9kYWxEYXRhJyk7XG5cbi8qKiBJbmplY3Rpb24gdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGRlZmF1bHQgbW9kYWwgb3B0aW9ucy4gKi9cbmV4cG9ydCBjb25zdCBOWF9NT0RBTF9ERUZBVUxUX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48TnhNb2RhbENvbmZpZz4oJ254LW1vZGFsLWRlZmF1bHQtb3B0aW9ucycpO1xuXG4vKiogSW5qZWN0aW9uIHRva2VuIHRoYXQgZGV0ZXJtaW5lcyB0aGUgc2Nyb2xsIGhhbmRsaW5nIHdoaWxlIGEgbW9kYWwgaXMgb3Blbi4gKi9cbmV4cG9ydCBjb25zdCBOWF9NT0RBTF9TQ1JPTExfU1RSQVRFR1kgPSBuZXcgSW5qZWN0aW9uVG9rZW48KCkgPT4gU2Nyb2xsU3RyYXRlZ3k+KCdueC1tb2RhbC1zY3JvbGwtc3RyYXRlZ3knKTtcblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBmdW5jdGlvbiBOWF9NT0RBTF9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVJfRkFDVE9SWShvdmVybGF5OiBPdmVybGF5KTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3kge1xuICAgIHJldHVybiAoKSA9PiBvdmVybGF5LnNjcm9sbFN0cmF0ZWdpZXMuYmxvY2soKTtcbn1cblxuLyoqIEBkb2NzLXByaXZhdGUgKi9cbmV4cG9ydCBjb25zdCBOWF9NT0RBTF9TQ1JPTExfU1RSQVRFR1lfUFJPVklERVIgPSB7XG4gICAgcHJvdmlkZTogTlhfTU9EQUxfU0NST0xMX1NUUkFURUdZLFxuICAgIHVzZUZhY3Rvcnk6IE5YX01PREFMX1NDUk9MTF9TVFJBVEVHWV9QUk9WSURFUl9GQUNUT1JZLFxuICAgIGRlcHM6IFtPdmVybGF5XSxcbn07XG5cbi8qKlxuICogU2VydmljZSB0byBvcGVuIE1hdGVyaWFsIERlc2lnbiBtb2RhbCBtb2RhbHMuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBOeERpYWxvZ1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHByaXZhdGUgX29wZW5Nb2RhbHNBdFRoaXNMZXZlbDogTnhNb2RhbFJlZjxhbnk+W10gPSBbXTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9hZnRlckFsbENsb3NlZEF0VGhpc0xldmVsID0gbmV3IFN1YmplY3Q8dm9pZD4oKTtcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9hZnRlck9wZW5lZEF0VGhpc0xldmVsID0gbmV3IFN1YmplY3Q8TnhNb2RhbFJlZjxhbnk+PigpO1xuICAgIHByaXZhdGUgX2FyaWFIaWRkZW5FbGVtZW50cyA9IG5ldyBNYXA8RWxlbWVudCwgc3RyaW5nIHwgbnVsbD4oKTtcblxuICAgIC8qKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudGx5LW9wZW4gbW9kYWxzLiAqL1xuICAgIGdldCBvcGVuTW9kYWxzKCk6IE54TW9kYWxSZWY8YW55PltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudERpYWxvZ1NlcnZpY2UgPyB0aGlzLl9wYXJlbnREaWFsb2dTZXJ2aWNlLm9wZW5Nb2RhbHMgOiB0aGlzLl9vcGVuTW9kYWxzQXRUaGlzTGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gYSBtb2RhbCBoYXMgYmVlbiBvcGVuZWQuICovXG4gICAgZ2V0IGFmdGVyT3BlbmVkKCk6IFN1YmplY3Q8TnhNb2RhbFJlZjxhbnk+PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJlbnREaWFsb2dTZXJ2aWNlID8gdGhpcy5fcGFyZW50RGlhbG9nU2VydmljZS5hZnRlck9wZW5lZCA6IHRoaXMuX2FmdGVyT3BlbmVkQXRUaGlzTGV2ZWw7XG4gICAgfVxuXG4gICAgZ2V0IF9hZnRlckFsbENsb3NlZCgpOiBTdWJqZWN0PHZvaWQ+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fcGFyZW50RGlhbG9nU2VydmljZTtcbiAgICAgICAgcmV0dXJuIHBhcmVudCA/IHBhcmVudC5fYWZ0ZXJBbGxDbG9zZWQgOiB0aGlzLl9hZnRlckFsbENsb3NlZEF0VGhpc0xldmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gYWxsIG9wZW4gbW9kYWwgaGF2ZSBmaW5pc2hlZCBjbG9zaW5nLlxuICAgICAqIFdpbGwgZW1pdCBvbiBzdWJzY3JpYmUgaWYgdGhlcmUgYXJlIG5vIG9wZW4gbW9kYWxzIHRvIGJlZ2luIHdpdGguXG4gICAgICovXG4gICAgcmVhZG9ubHkgYWZ0ZXJBbGxDbG9zZWQ6IE9ic2VydmFibGU8dm9pZD4gPSBkZWZlcigoKSA9PlxuICAgICAgICB0aGlzLm9wZW5Nb2RhbHMubGVuZ3RoID8gdGhpcy5fYWZ0ZXJBbGxDbG9zZWQgOiB0aGlzLl9hZnRlckFsbENsb3NlZC5waXBlKHN0YXJ0V2l0aCh1bmRlZmluZWQpKSxcbiAgICApIGFzIE9ic2VydmFibGU8YW55PjtcblxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2Rlc3Ryb3llZCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG5cbiAgICAvKiogU3RyYXRlZ3kgZmFjdG9yeSB0aGF0IHdpbGwgYmUgdXNlZCB0byBoYW5kbGUgc2Nyb2xsaW5nIHdoaWxlIHRoZSBtb2RhbCBwYW5lbCBpcyBvcGVuLiAqL1xuICAgIHByaXZhdGUgX3Njcm9sbFN0cmF0ZWd5RmFjdG9yeSA9IHRoaXMuX2RlZmF1bHRTY3JvbGxTdHJhdGVneUZhY3Rvcnk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfb3ZlcmxheTogT3ZlcmxheSxcbiAgICAgICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxuICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KE5YX01PREFMX0RFRkFVTFRfT1BUSU9OUykgcHJpdmF0ZSBfZGVmYXVsdE9wdGlvbnM6IE54TW9kYWxDb25maWcgfCBudWxsLFxuICAgICAgICBAT3B0aW9uYWwoKSBAU2tpcFNlbGYoKSBwcml2YXRlIF9wYXJlbnREaWFsb2dTZXJ2aWNlOiBOeERpYWxvZ1NlcnZpY2UgfCBudWxsLFxuICAgICAgICBwcml2YXRlIF9vdmVybGF5Q29udGFpbmVyOiBPdmVybGF5Q29udGFpbmVyLFxuICAgICAgICBASW5qZWN0KE5YX01PREFMX1NDUk9MTF9TVFJBVEVHWSkgcHJpdmF0ZSBfZGVmYXVsdFNjcm9sbFN0cmF0ZWd5RmFjdG9yeTogKCkgPT4gU2Nyb2xsU3RyYXRlZ3ksXG4gICAgKSB7fVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgYSBtb2RhbCBtb2RhbCBjb250YWluaW5nIHRoZSBnaXZlbiBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudE9yVGVtcGxhdGVSZWYgVHlwZSBvZiB0aGUgY29tcG9uZW50IHRvIGxvYWQgaW50byB0aGUgZGlhbG9nLFxuICAgICAqICAgICBvciBhIFRlbXBsYXRlUmVmIHRvIGluc3RhbnRpYXRlIGFzIHRoZSBtb2RhbCBjb250ZW50LlxuICAgICAqIEBwYXJhbSBjb25maWcgRXh0cmEgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqIEByZXR1cm5zIFJlZmVyZW5jZSB0byB0aGUgbmV3bHktb3BlbmVkIG1vZGFsLlxuICAgICAqL1xuICAgIG9wZW48VCwgRCA9IGFueSwgUiA9IGFueT4oY29tcG9uZW50T3JUZW1wbGF0ZVJlZjogQ29tcG9uZW50VHlwZTxUPiB8IFRlbXBsYXRlUmVmPFQ+LCBjb25maWc/OiBOeE1vZGFsQ29uZmlnPEQ+KTogTnhNb2RhbFJlZjxULCBSPiB7XG4gICAgICAgIGNvbmZpZyA9IF9hcHBseUNvbmZpZ0RlZmF1bHRzKGNvbmZpZywgdGhpcy5fZGVmYXVsdE9wdGlvbnMgfHwgbmV3IE54TW9kYWxDb25maWcoKSk7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5pZCAmJiB0aGlzLmdldE1vZGFsQnlJZChjb25maWcuaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTW9kYWwgd2l0aCBpZCBcIiR7Y29uZmlnLmlkfVwiIGV4aXN0cyBhbHJlYWR5LiBUaGUgbW9kYWwgaWQgbXVzdCBiZSB1bmlxdWUuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBvdmVybGF5UmVmID0gdGhpcy5fY3JlYXRlT3ZlcmxheShjb25maWcpO1xuICAgICAgICBjb25zdCBtb2RhbENvbnRhaW5lciA9IHRoaXMuX2F0dGFjaE1vZGFsQ29udGFpbmVyKG92ZXJsYXlSZWYsIGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IG1vZGFsUmVmID0gdGhpcy5fYXR0YWNoTW9kYWxDb250ZW50PFQsIFI+KGNvbXBvbmVudE9yVGVtcGxhdGVSZWYsIG1vZGFsQ29udGFpbmVyLCBvdmVybGF5UmVmLCBjb25maWcpO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IG1vZGFsIHRoYXQgd2UncmUgb3BlbmluZywgaGlkZSBhbGwgdGhlIG5vbi1vdmVybGF5IGNvbnRlbnQuXG4gICAgICAgIGlmICghdGhpcy5vcGVuTW9kYWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5faGlkZU5vbk1vZGFsQ29udGVudEZyb21Bc3Npc3RpdmVUZWNobm9sb2d5KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9wZW5Nb2RhbHMucHVzaChtb2RhbFJlZik7XG4gICAgICAgIG1vZGFsUmVmLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKCgpID0+IHRoaXMuX3JlbW92ZU9wZW5Nb2RhbChtb2RhbFJlZikpO1xuICAgICAgICB0aGlzLmFmdGVyT3BlbmVkLm5leHQobW9kYWxSZWYpO1xuXG4gICAgICAgIHJldHVybiBtb2RhbFJlZjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIG9mIHRoZSBjdXJyZW50bHktb3BlbiBtb2RhbHMuXG4gICAgICovXG4gICAgY2xvc2VBbGwoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2Nsb3NlTW9kYWxzKHRoaXMub3Blbk1vZGFscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYW4gb3BlbiBtb2RhbCBieSBpdHMgaWQuXG4gICAgICogQHBhcmFtIGlkIElEIHRvIHVzZSB3aGVuIGxvb2tpbmcgdXAgdGhlIG1vZGFsLlxuICAgICAqL1xuICAgIGdldE1vZGFsQnlJZChpZDogc3RyaW5nKTogTnhNb2RhbFJlZjxhbnk+IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3Blbk1vZGFscy5maW5kKG1vZGFsID0+IG1vZGFsLmlkID09PSBpZCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5uZXh0KCk7XG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZC5jb21wbGV0ZSgpO1xuXG4gICAgICAgIC8vIE9ubHkgY2xvc2UgdGhlIG1vZGFscyBhdCB0aGlzIGxldmVsIG9uIGRlc3Ryb3lcbiAgICAgICAgLy8gc2luY2UgdGhlIHBhcmVudCBzZXJ2aWNlIG1heSBzdGlsbCBiZSBhY3RpdmUuXG4gICAgICAgIHRoaXMuX2Nsb3NlTW9kYWxzKHRoaXMuX29wZW5Nb2RhbHNBdFRoaXNMZXZlbCk7XG4gICAgICAgIHRoaXMuX2FmdGVyQWxsQ2xvc2VkQXRUaGlzTGV2ZWwuY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy5fYWZ0ZXJPcGVuZWRBdFRoaXNMZXZlbC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG92ZXJsYXkgaW50byB3aGljaCB0aGUgbW9kYWwgd2lsbCBiZSBsb2FkZWQuXG4gICAgICogQHBhcmFtIGNvbmZpZyBUaGUgbW9kYWwgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBPdmVybGF5UmVmIGZvciB0aGUgY3JlYXRlZCBvdmVybGF5LlxuICAgICAqL1xuICAgIHByaXZhdGUgX2NyZWF0ZU92ZXJsYXkoY29uZmlnOiBOeE1vZGFsQ29uZmlnKTogT3ZlcmxheVJlZiB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlDb25maWcgPSB0aGlzLl9nZXRPdmVybGF5Q29uZmlnKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5LmNyZWF0ZShvdmVybGF5Q29uZmlnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgY29uZmlnIGZyb20gYSBtb2RhbCBjb25maWcuXG4gICAgICogQHBhcmFtIG1vZGFsQ29uZmlnIFRoZSBtb2RhbCBjb25maWd1cmF0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBvdmVybGF5IGNvbmZpZ3VyYXRpb24uXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0T3ZlcmxheUNvbmZpZyhtb2RhbENvbmZpZzogTnhNb2RhbENvbmZpZyk6IE92ZXJsYXlDb25maWcge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IG5ldyBPdmVybGF5Q29uZmlnKHtcbiAgICAgICAgICAgIHBvc2l0aW9uU3RyYXRlZ3k6IHRoaXMuX292ZXJsYXkucG9zaXRpb24oKS5nbG9iYWwoKSxcbiAgICAgICAgICAgIHNjcm9sbFN0cmF0ZWd5OiBtb2RhbENvbmZpZy5zY3JvbGxTdHJhdGVneSB8fCB0aGlzLl9zY3JvbGxTdHJhdGVneUZhY3RvcnkoKSxcbiAgICAgICAgICAgIHBhbmVsQ2xhc3M6IG1vZGFsQ29uZmlnLnBhbmVsQ2xhc3MsXG4gICAgICAgICAgICBoYXNCYWNrZHJvcDogbW9kYWxDb25maWcuaGFzQmFja2Ryb3AsXG4gICAgICAgICAgICBtaW5XaWR0aDogbW9kYWxDb25maWcubWluV2lkdGgsXG4gICAgICAgICAgICBtaW5IZWlnaHQ6IG1vZGFsQ29uZmlnLm1pbkhlaWdodCxcbiAgICAgICAgICAgIG1heFdpZHRoOiBtb2RhbENvbmZpZy5tYXhXaWR0aCxcbiAgICAgICAgICAgIG1heEhlaWdodDogbW9kYWxDb25maWcubWF4SGVpZ2h0LFxuICAgICAgICAgICAgZGlzcG9zZU9uTmF2aWdhdGlvbjogbW9kYWxDb25maWcuY2xvc2VPbk5hdmlnYXRpb24sXG4gICAgICAgICAgICBkaXJlY3Rpb246IG1vZGFsQ29uZmlnLmRpcmVjdGlvbixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG1vZGFsQ29uZmlnLmJhY2tkcm9wQ2xhc3MpIHtcbiAgICAgICAgICAgIHN0YXRlLmJhY2tkcm9wQ2xhc3MgPSBtb2RhbENvbmZpZy5iYWNrZHJvcENsYXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFuIE54TW9kYWxDb250YWluZXIgdG8gYSBkaWFsb2cncyBhbHJlYWR5LWNyZWF0ZWQgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gb3ZlcmxheSBSZWZlcmVuY2UgdG8gdGhlIGRpYWxvZydzIHVuZGVybHlpbmcgb3ZlcmxheS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIFRoZSBtb2RhbCBjb25maWd1cmF0aW9uLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYSBDb21wb25lbnRSZWYgZm9yIHRoZSBhdHRhY2hlZCBjb250YWluZXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfYXR0YWNoTW9kYWxDb250YWluZXIob3ZlcmxheTogT3ZlcmxheVJlZiwgY29uZmlnOiBOeE1vZGFsQ29uZmlnKTogTnhNb2RhbENvbnRhaW5lciB7XG4gICAgICAgIGNvbnN0IHVzZXJJbmplY3RvciA9IGNvbmZpZz8udmlld0NvbnRhaW5lclJlZj8uaW5qZWN0b3I7XG4gICAgICAgIGNvbnN0IGluamVjdG9yID0gSW5qZWN0b3IuY3JlYXRlKHtcbiAgICAgICAgICAgIHBhcmVudDogdXNlckluamVjdG9yIHx8IHRoaXMuX2luamVjdG9yLFxuICAgICAgICAgICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBOeE1vZGFsQ29uZmlnLCB1c2VWYWx1ZTogY29uZmlnIH1dLFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBjb250YWluZXJQb3J0YWwgPSBuZXcgQ29tcG9uZW50UG9ydGFsKE54TW9kYWxDb250YWluZXIsIGNvbmZpZy52aWV3Q29udGFpbmVyUmVmLCBpbmplY3RvciwgY29uZmlnLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlcik7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclJlZiA9IG92ZXJsYXkuYXR0YWNoPE54TW9kYWxDb250YWluZXI+KGNvbnRhaW5lclBvcnRhbCk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lclJlZi5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyB0aGUgdXNlci1wcm92aWRlZCBjb21wb25lbnQgdG8gdGhlIGFscmVhZHktY3JlYXRlZCBOeE1vZGFsQ29udGFpbmVyLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRPclRlbXBsYXRlUmVmIFRoZSB0eXBlIG9mIGNvbXBvbmVudCBiZWluZyBsb2FkZWQgaW50byB0aGUgZGlhbG9nLFxuICAgICAqICAgICBvciBhIFRlbXBsYXRlUmVmIHRvIGluc3RhbnRpYXRlIGFzIHRoZSBjb250ZW50LlxuICAgICAqIEBwYXJhbSBtb2RhbENvbnRhaW5lciBSZWZlcmVuY2UgdG8gdGhlIHdyYXBwaW5nIE54TW9kYWxDb250YWluZXIuXG4gICAgICogQHBhcmFtIG92ZXJsYXlSZWYgUmVmZXJlbmNlIHRvIHRoZSBvdmVybGF5IGluIHdoaWNoIHRoZSBtb2RhbCByZXNpZGVzLlxuICAgICAqIEBwYXJhbSBjb25maWcgVGhlIG1vZGFsIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHJlc29sdmluZyB0byB0aGUgTnhNb2RhbFJlZiB0aGF0IHNob3VsZCBiZSByZXR1cm5lZCB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9hdHRhY2hNb2RhbENvbnRlbnQ8VCwgUj4oXG4gICAgICAgIGNvbXBvbmVudE9yVGVtcGxhdGVSZWY6IENvbXBvbmVudFR5cGU8VD4gfCBUZW1wbGF0ZVJlZjxUPixcbiAgICAgICAgbW9kYWxDb250YWluZXI6IE54TW9kYWxDb250YWluZXIsXG4gICAgICAgIG92ZXJsYXlSZWY6IE92ZXJsYXlSZWYsXG4gICAgICAgIGNvbmZpZzogTnhNb2RhbENvbmZpZyxcbiAgICApOiBOeE1vZGFsUmVmPFQsIFI+IHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIHRoZSBtb2RhbCB3ZSdyZSBjcmVhdGluZyBpbiBvcmRlciB0byBnaXZlIHRoZSB1c2VyIGEgaGFuZGxlXG4gICAgICAgIC8vIHRvIG1vZGlmeSBhbmQgY2xvc2UgaXQuXG4gICAgICAgIGNvbnN0IG1vZGFsUmVmID0gbmV3IE54TW9kYWxSZWY8VCwgUj4ob3ZlcmxheVJlZiwgbW9kYWxDb250YWluZXIsIGNvbmZpZy5pZCk7XG5cbiAgICAgICAgLy8gV2hlbiB0aGUgbW9kYWwgYmFja2Ryb3AgaXMgY2xpY2tlZCwgd2Ugd2FudCB0byBjbG9zZSBpdC5cbiAgICAgICAgaWYgKGNvbmZpZy5oYXNCYWNrZHJvcCkge1xuICAgICAgICAgICAgb3ZlcmxheVJlZlxuICAgICAgICAgICAgICAgIC5iYWNrZHJvcENsaWNrKClcbiAgICAgICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVkKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RhbFJlZi5kaXNhYmxlQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGFsUmVmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb21wb25lbnRPclRlbXBsYXRlUmVmIGluc3RhbmNlb2YgVGVtcGxhdGVSZWYpIHtcbiAgICAgICAgICAgIG1vZGFsQ29udGFpbmVyLmF0dGFjaFRlbXBsYXRlUG9ydGFsKG5ldyBUZW1wbGF0ZVBvcnRhbDxUPihjb21wb25lbnRPclRlbXBsYXRlUmVmLCBudWxsISwgeyAkaW1wbGljaXQ6IGNvbmZpZy5kYXRhLCBtb2RhbFJlZiB9IGFzIGFueSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5qZWN0b3IgPSB0aGlzLl9jcmVhdGVJbmplY3RvcjxUPihjb25maWcsIG1vZGFsUmVmLCBtb2RhbENvbnRhaW5lcik7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50UmVmID0gbW9kYWxDb250YWluZXIuYXR0YWNoQ29tcG9uZW50UG9ydGFsPFQ+KG5ldyBDb21wb25lbnRQb3J0YWwoY29tcG9uZW50T3JUZW1wbGF0ZVJlZiwgY29uZmlnLnZpZXdDb250YWluZXJSZWYsIGluamVjdG9yKSk7XG4gICAgICAgICAgICBtb2RhbFJlZi5jb21wb25lbnRJbnN0YW5jZSA9IGNvbnRlbnRSZWYuaW5zdGFuY2U7XG4gICAgICAgIH1cblxuICAgICAgICBtb2RhbFJlZi51cGRhdGVTaXplKGNvbmZpZy53aWR0aCwgY29uZmlnLmhlaWdodCkudXBkYXRlUG9zaXRpb24oY29uZmlnLnBvc2l0aW9uKTtcblxuICAgICAgICByZXR1cm4gbW9kYWxSZWY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGN1c3RvbSBpbmplY3RvciB0byBiZSB1c2VkIGluc2lkZSB0aGUgbW9kYWwuIFRoaXMgYWxsb3dzIGEgY29tcG9uZW50IGxvYWRlZCBpbnNpZGVcbiAgICAgKiBvZiBhIG1vZGFsIHRvIGNsb3NlIGl0c2VsZiBhbmQsIG9wdGlvbmFsbHksIHRvIHJldHVybiBhIHZhbHVlLlxuICAgICAqIEBwYXJhbSBjb25maWcgQ29uZmlnIG9iamVjdCB0aGF0IGlzIHVzZWQgdG8gY29uc3RydWN0IHRoZSBtb2RhbC5cbiAgICAgKiBAcGFyYW0gbW9kYWxSZWYgUmVmZXJlbmNlIHRvIHRoZSBtb2RhbC5cbiAgICAgKiBAcGFyYW0gY29udGFpbmVyIE1vZGFsIGNvbnRhaW5lciBlbGVtZW50IHRoYXQgd3JhcHMgYWxsIG9mIHRoZSBjb250ZW50cy5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3VzdG9tIGluamVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgaW5zaWRlIHRoZSBtb2RhbC5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9jcmVhdGVJbmplY3RvcjxUPihjb25maWc6IE54TW9kYWxDb25maWcsIG1vZGFsUmVmOiBOeE1vZGFsUmVmPFQ+LCBtb2RhbENvbnRhaW5lcjogTnhNb2RhbENvbnRhaW5lcik6IEluamVjdG9yIHtcbiAgICAgICAgY29uc3QgdXNlckluamVjdG9yID0gY29uZmlnPy52aWV3Q29udGFpbmVyUmVmPy5pbmplY3RvcjtcblxuICAgICAgICAvLyBUaGUgTnhNb2RhbENvbnRhaW5lciBpcyBpbmplY3RlZCBpbiB0aGUgcG9ydGFsIGFzIHRoZSBOeE1vZGFsQ29udGFpbmVyIGFuZCB0aGUgZGlhbG9nJ3NcbiAgICAgICAgLy8gY29udGVudCBhcmUgY3JlYXRlZCBvdXQgb2YgdGhlIHNhbWUgVmlld0NvbnRhaW5lclJlZiBhbmQgYXMgc3VjaCwgYXJlIHNpYmxpbmdzIGZvciBpbmplY3RvclxuICAgICAgICAvLyBwdXJwb3Nlcy4gVG8gYWxsb3cgdGhlIGhpZXJhcmNoeSB0aGF0IGlzIGV4cGVjdGVkLCB0aGUgTnhNb2RhbENvbnRhaW5lciBpcyBleHBsaWNpdGx5XG4gICAgICAgIC8vIGFkZGVkIHRvIHRoZSBpbmplY3Rpb24gdG9rZW5zLlxuICAgICAgICBjb25zdCBwcm92aWRlcnM6IFN0YXRpY1Byb3ZpZGVyW10gPSBbXG4gICAgICAgICAgICB7IHByb3ZpZGU6IE54TW9kYWxDb250YWluZXIsIHVzZVZhbHVlOiBtb2RhbENvbnRhaW5lciB9LFxuICAgICAgICAgICAgeyBwcm92aWRlOiBOWF9NT0RBTF9EQVRBLCB1c2VWYWx1ZTogY29uZmlnLmRhdGEgfSxcbiAgICAgICAgICAgIHsgcHJvdmlkZTogTnhNb2RhbFJlZiwgdXNlVmFsdWU6IG1vZGFsUmVmIH0sXG4gICAgICAgIF07XG5cbiAgICAgICAgcmV0dXJuIEluamVjdG9yLmNyZWF0ZSh7IHBhcmVudDogdXNlckluamVjdG9yIHx8IHRoaXMuX2luamVjdG9yLCBwcm92aWRlcnMgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIG1vZGFsIGZyb20gdGhlIGFycmF5IG9mIG9wZW4gbW9kYWxzLlxuICAgICAqIEBwYXJhbSBtb2RhbFJlZiBNb2RhbCB0byBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHByaXZhdGUgX3JlbW92ZU9wZW5Nb2RhbChtb2RhbFJlZjogTnhNb2RhbFJlZjxhbnk+KSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5vcGVuTW9kYWxzLmluZGV4T2YobW9kYWxSZWYpO1xuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5Nb2RhbHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAgICAgLy8gSWYgYWxsIHRoZSBtb2RhbHMgd2VyZSBjbG9zZWQsIHJlbW92ZS9yZXN0b3JlIHRoZSBgYXJpYS1oaWRkZW5gXG4gICAgICAgICAgICAvLyB0byBhIHRoZSBzaWJsaW5ncyBhbmQgZW1pdCB0byB0aGUgYGFmdGVyQWxsQ2xvc2VkYCBzdHJlYW0uXG4gICAgICAgICAgICBpZiAoIXRoaXMub3Blbk1vZGFscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hcmlhSGlkZGVuRWxlbWVudHMuZm9yRWFjaCgocHJldmlvdXNWYWx1ZSwgZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgcHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fYXJpYUhpZGRlbkVsZW1lbnRzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYWZ0ZXJBbGxDbG9zZWQubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZXMgYWxsIG9mIHRoZSBjb250ZW50IHRoYXQgaXNuJ3QgYW4gb3ZlcmxheSBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5LlxuICAgICAqL1xuICAgIHByaXZhdGUgX2hpZGVOb25Nb2RhbENvbnRlbnRGcm9tQXNzaXN0aXZlVGVjaG5vbG9neSgpIHtcbiAgICAgICAgY29uc3Qgb3ZlcmxheUNvbnRhaW5lciA9IHRoaXMuX292ZXJsYXlDb250YWluZXIuZ2V0Q29udGFpbmVyRWxlbWVudCgpO1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBvdmVybGF5IGNvbnRhaW5lciBpcyBhdHRhY2hlZCB0byB0aGUgRE9NLlxuICAgICAgICBpZiAob3ZlcmxheUNvbnRhaW5lci5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzaWJsaW5ncyA9IG92ZXJsYXlDb250YWluZXIucGFyZW50RWxlbWVudC5jaGlsZHJlbjtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHNpYmxpbmdzLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2libGluZyA9IHNpYmxpbmdzW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcgIT09IG92ZXJsYXlDb250YWluZXIgJiYgc2libGluZy5ub2RlTmFtZSAhPT0gJ1NDUklQVCcgJiYgc2libGluZy5ub2RlTmFtZSAhPT0gJ1NUWUxFJyAmJiAhc2libGluZy5oYXNBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FyaWFIaWRkZW5FbGVtZW50cy5zZXQoc2libGluZywgc2libGluZy5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5nLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBDbG9zZXMgYWxsIG9mIHRoZSBtb2RhbHMgaW4gYW4gYXJyYXkuICovXG4gICAgcHJpdmF0ZSBfY2xvc2VNb2RhbHMobW9kYWxzOiBOeE1vZGFsUmVmPGFueT5bXSkge1xuICAgICAgICBsZXQgaSA9IG1vZGFscy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgLy8gVGhlIGBfb3Blbk1vZGFsc2AgcHJvcGVydHkgaXNuJ3QgdXBkYXRlZCBhZnRlciBjbG9zZSB1bnRpbCB0aGUgcnhqcyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHJ1bnMgb24gdGhlIG5leHQgbWljcm90YXNrLCBpbiBhZGRpdGlvbiB0byBtb2RpZnlpbmcgdGhlIGFycmF5IGFzIHdlJ3JlIGdvaW5nXG4gICAgICAgICAgICAvLyB0aHJvdWdoIGl0LiBXZSBsb29wIHRocm91Z2ggYWxsIG9mIHRoZW0gYW5kIGNhbGwgY2xvc2Ugd2l0aG91dCBhc3N1bWluZyB0aGF0XG4gICAgICAgICAgICAvLyB0aGV5J2xsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbGlzdCBpbnN0YW50YW5lb3VzbHkuXG4gICAgICAgICAgICBtb2RhbHNbaV0uY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBcHBsaWVzIGRlZmF1bHQgb3B0aW9ucyB0byB0aGUgbW9kYWwgY29uZmlnLlxuICogQHBhcmFtIGNvbmZpZyBDb25maWcgdG8gYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0gZGVmYXVsdE9wdGlvbnMgRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkLlxuICogQHJldHVybnMgVGhlIG5ldyBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gX2FwcGx5Q29uZmlnRGVmYXVsdHMoY29uZmlnPzogTnhNb2RhbENvbmZpZywgZGVmYXVsdE9wdGlvbnM/OiBOeE1vZGFsQ29uZmlnKTogTnhNb2RhbENvbmZpZyB7XG4gICAgcmV0dXJuIHsgLi4uZGVmYXVsdE9wdGlvbnMsIC4uLmNvbmZpZyB9O1xufVxuIl19