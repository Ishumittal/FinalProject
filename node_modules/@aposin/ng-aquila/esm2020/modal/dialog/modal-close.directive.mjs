import { Directive, Input, Optional } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "./modal-ref";
import * as i2 from "./dialog.service";
/**
 * Button that will close the current modal.
 */
export class NxModalCloseDirective {
    constructor(modalRef, _elementRef, _dialogService) {
        this.modalRef = modalRef;
        this._elementRef = _elementRef;
        this._dialogService = _dialogService;
        /** Default to "button" to prevents accidental form submits. */
        this.type = 'button';
    }
    ngOnInit() {
        if (!this.modalRef) {
            // When this directive is included in a modal via TemplateRef (rather than being
            // in a Component), the DialogRef isn't available via injection because embedded
            // views cannot be given a custom injector. Instead, we look up the DialogRef by
            // ID. This must occur in `onInit`, as the ID binding for the modal container won't
            // be resolved at constructor time.
            this.modalRef = getClosestDialog(this._elementRef, this._dialogService.openModals);
        }
    }
    ngOnChanges(changes) {
        const proxiedChange = changes['modalResult'];
        if (proxiedChange) {
            this.modalResult = proxiedChange.currentValue;
        }
    }
}
NxModalCloseDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalCloseDirective, deps: [{ token: i1.NxModalRef, optional: true }, { token: i0.ElementRef }, { token: i2.NxDialogService }], target: i0.ɵɵFactoryTarget.Directive });
NxModalCloseDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxModalCloseDirective, selector: "[nxModalClose]", inputs: { ariaLabel: ["aria-label", "ariaLabel"], type: "type", modalResult: ["nxModalClose", "modalResult"] }, host: { listeners: { "click": "modalRef.close(modalResult)" }, properties: { "attr.aria-label": "ariaLabel || null", "attr.type": "type" } }, usesOnChanges: true, ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxModalCloseDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[nxModalClose]',
                    host: {
                        '(click)': 'modalRef.close(modalResult)',
                        '[attr.aria-label]': 'ariaLabel || null',
                        '[attr.type]': 'type',
                    },
                }]
        }], ctorParameters: function () { return [{ type: i1.NxModalRef, decorators: [{
                    type: Optional
                }] }, { type: i0.ElementRef }, { type: i2.NxDialogService }]; }, propDecorators: { ariaLabel: [{
                type: Input,
                args: ['aria-label']
            }], type: [{
                type: Input
            }], modalResult: [{
                type: Input,
                args: ['nxModalClose']
            }] } });
/**
 * Finds the closest NxModalRef to an element by looking at the DOM.
 * @param element Element relative to which to look for a modal.
 * @param openDialogs References to the currently-open modals.
 */
function getClosestDialog(element, openDialogs) {
    let parent = element.nativeElement.parentElement;
    while (parent && !parent.classList.contains('nx-modal__container')) {
        parent = parent.parentElement;
    }
    return parent ? openDialogs.find(modal => modal.id === parent.id) : null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kYWwtY2xvc2UuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmctYXF1aWxhL3NyYy9tb2RhbC9kaWFsb2cvbW9kYWwtY2xvc2UuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQWMsS0FBSyxFQUFxQixRQUFRLEVBQWlCLE1BQU0sZUFBZSxDQUFDOzs7O0FBS3pHOztHQUVHO0FBU0gsTUFBTSxPQUFPLHFCQUFxQjtJQVU5QixZQUErQixRQUFnQyxFQUFVLFdBQW9DLEVBQVUsY0FBK0I7UUFBdkgsYUFBUSxHQUFSLFFBQVEsQ0FBd0I7UUFBVSxnQkFBVyxHQUFYLFdBQVcsQ0FBeUI7UUFBVSxtQkFBYyxHQUFkLGNBQWMsQ0FBaUI7UUFOdEosK0RBQStEO1FBQ3RELFNBQUksR0FBa0MsUUFBUSxDQUFDO0lBS2lHLENBQUM7SUFFMUosUUFBUTtRQUNKLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFO1lBQ2hCLGdGQUFnRjtZQUNoRixnRkFBZ0Y7WUFDaEYsZ0ZBQWdGO1lBQ2hGLG1GQUFtRjtZQUNuRixtQ0FBbUM7WUFDbkMsSUFBSSxDQUFDLFFBQVEsR0FBRyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFFLENBQUM7U0FDdkY7SUFDTCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQzlCLE1BQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUU3QyxJQUFJLGFBQWEsRUFBRTtZQUNmLElBQUksQ0FBQyxXQUFXLEdBQUcsYUFBYSxDQUFDLFlBQVksQ0FBQztTQUNqRDtJQUNMLENBQUM7O2tIQTdCUSxxQkFBcUI7c0dBQXJCLHFCQUFxQjsyRkFBckIscUJBQXFCO2tCQVJqQyxTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxnQkFBZ0I7b0JBQzFCLElBQUksRUFBRTt3QkFDRixTQUFTLEVBQUUsNkJBQTZCO3dCQUN4QyxtQkFBbUIsRUFBRSxtQkFBbUI7d0JBQ3hDLGFBQWEsRUFBRSxNQUFNO3FCQUN4QjtpQkFDSjs7MEJBV2dCLFFBQVE7bUdBUkEsU0FBUztzQkFBN0IsS0FBSzt1QkFBQyxZQUFZO2dCQUdWLElBQUk7c0JBQVosS0FBSztnQkFHaUIsV0FBVztzQkFBakMsS0FBSzt1QkFBQyxjQUFjOztBQXdCekI7Ozs7R0FJRztBQUNILFNBQVMsZ0JBQWdCLENBQUMsT0FBZ0MsRUFBRSxXQUE4QjtJQUN0RixJQUFJLE1BQU0sR0FBdUIsT0FBTyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUM7SUFFckUsT0FBTyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxFQUFFO1FBQ2hFLE1BQU0sR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDO0tBQ2pDO0lBRUQsT0FBTyxNQUFNLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLE1BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0FBQzlFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPbkNoYW5nZXMsIE9uSW5pdCwgT3B0aW9uYWwsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgTnhEaWFsb2dTZXJ2aWNlIH0gZnJvbSAnLi9kaWFsb2cuc2VydmljZSc7XG5pbXBvcnQgeyBOeE1vZGFsUmVmIH0gZnJvbSAnLi9tb2RhbC1yZWYnO1xuXG4vKipcbiAqIEJ1dHRvbiB0aGF0IHdpbGwgY2xvc2UgdGhlIGN1cnJlbnQgbW9kYWwuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW254TW9kYWxDbG9zZV0nLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJyhjbGljayknOiAnbW9kYWxSZWYuY2xvc2UobW9kYWxSZXN1bHQpJyxcbiAgICAgICAgJ1thdHRyLmFyaWEtbGFiZWxdJzogJ2FyaWFMYWJlbCB8fCBudWxsJyxcbiAgICAgICAgJ1thdHRyLnR5cGVdJzogJ3R5cGUnLFxuICAgIH0sXG59KVxuZXhwb3J0IGNsYXNzIE54TW9kYWxDbG9zZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgICAvKiogU2NyZWVucmVhZGVyIGxhYmVsIGZvciB0aGUgYnV0dG9uLiAqL1xuICAgIEBJbnB1dCgnYXJpYS1sYWJlbCcpIGFyaWFMYWJlbCE6IHN0cmluZztcblxuICAgIC8qKiBEZWZhdWx0IHRvIFwiYnV0dG9uXCIgdG8gcHJldmVudHMgYWNjaWRlbnRhbCBmb3JtIHN1Ym1pdHMuICovXG4gICAgQElucHV0KCkgdHlwZTogJ3N1Ym1pdCcgfCAnYnV0dG9uJyB8ICdyZXNldCcgPSAnYnV0dG9uJztcblxuICAgIC8qKiBEaWFsb2cgY2xvc2UgaW5wdXQuICovXG4gICAgQElucHV0KCdueE1vZGFsQ2xvc2UnKSBtb2RhbFJlc3VsdDogYW55O1xuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgcHVibGljIG1vZGFsUmVmOiBOeE1vZGFsUmVmPGFueT4gfCBudWxsLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgcHJpdmF0ZSBfZGlhbG9nU2VydmljZTogTnhEaWFsb2dTZXJ2aWNlKSB7fVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5tb2RhbFJlZikge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGlzIGRpcmVjdGl2ZSBpcyBpbmNsdWRlZCBpbiBhIG1vZGFsIHZpYSBUZW1wbGF0ZVJlZiAocmF0aGVyIHRoYW4gYmVpbmdcbiAgICAgICAgICAgIC8vIGluIGEgQ29tcG9uZW50KSwgdGhlIERpYWxvZ1JlZiBpc24ndCBhdmFpbGFibGUgdmlhIGluamVjdGlvbiBiZWNhdXNlIGVtYmVkZGVkXG4gICAgICAgICAgICAvLyB2aWV3cyBjYW5ub3QgYmUgZ2l2ZW4gYSBjdXN0b20gaW5qZWN0b3IuIEluc3RlYWQsIHdlIGxvb2sgdXAgdGhlIERpYWxvZ1JlZiBieVxuICAgICAgICAgICAgLy8gSUQuIFRoaXMgbXVzdCBvY2N1ciBpbiBgb25Jbml0YCwgYXMgdGhlIElEIGJpbmRpbmcgZm9yIHRoZSBtb2RhbCBjb250YWluZXIgd29uJ3RcbiAgICAgICAgICAgIC8vIGJlIHJlc29sdmVkIGF0IGNvbnN0cnVjdG9yIHRpbWUuXG4gICAgICAgICAgICB0aGlzLm1vZGFsUmVmID0gZ2V0Q2xvc2VzdERpYWxvZyh0aGlzLl9lbGVtZW50UmVmLCB0aGlzLl9kaWFsb2dTZXJ2aWNlLm9wZW5Nb2RhbHMpITtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgcHJveGllZENoYW5nZSA9IGNoYW5nZXNbJ21vZGFsUmVzdWx0J107XG5cbiAgICAgICAgaWYgKHByb3hpZWRDaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMubW9kYWxSZXN1bHQgPSBwcm94aWVkQ2hhbmdlLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBOeE1vZGFsUmVmIHRvIGFuIGVsZW1lbnQgYnkgbG9va2luZyBhdCB0aGUgRE9NLlxuICogQHBhcmFtIGVsZW1lbnQgRWxlbWVudCByZWxhdGl2ZSB0byB3aGljaCB0byBsb29rIGZvciBhIG1vZGFsLlxuICogQHBhcmFtIG9wZW5EaWFsb2dzIFJlZmVyZW5jZXMgdG8gdGhlIGN1cnJlbnRseS1vcGVuIG1vZGFscy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdERpYWxvZyhlbGVtZW50OiBFbGVtZW50UmVmPEhUTUxFbGVtZW50Piwgb3BlbkRpYWxvZ3M6IE54TW9kYWxSZWY8YW55PltdKSB7XG4gICAgbGV0IHBhcmVudDogSFRNTEVsZW1lbnQgfCBudWxsID0gZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cbiAgICB3aGlsZSAocGFyZW50ICYmICFwYXJlbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdueC1tb2RhbF9fY29udGFpbmVyJykpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudCA/IG9wZW5EaWFsb2dzLmZpbmQobW9kYWwgPT4gbW9kYWwuaWQgPT09IHBhcmVudCEuaWQpIDogbnVsbDtcbn1cbiJdfQ==