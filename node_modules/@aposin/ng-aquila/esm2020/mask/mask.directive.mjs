import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { BACKSPACE, DELETE } from '@angular/cdk/keycodes';
import { Directive, forwardRef, Input } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR } from '@angular/forms';
import { NX_INPUT_VALUE_ACCESSOR } from '@aposin/ng-aquila/input';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
export const NX_MASK_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => NxMaskDirective),
    multi: true,
};
export const NX_MASK_VALIDATORS = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(() => NxMaskDirective),
    multi: true,
};
export class NxMaskDirective {
    constructor(_elementRef) {
        this._elementRef = _elementRef;
        this._separators = ['/', '(', ')', '.', ':', '-', ' ', '+', ','];
        this._dropSpecialCharacters = false;
        this._validateMask = true;
        this._deactivateMask = false;
        this._mask = '';
        /**
         * Emits the unmasked value before the value changes.
         */
        this.cvaModelChange = new Subject();
        this._onChangeCallback = (_) => { };
        this._onTouchedCallback = () => { };
        this._validatorOnChange = () => { };
        this._afterInputHook = (event) => { };
        this._beforePasteHook = (event) => { };
    }
    _callOnChangeCallback() {
        if (this.dropSpecialCharacters) {
            this._onChangeCallback(this.getUnmaskedValue());
        }
        else {
            this._onChangeCallback(this._elementRef.nativeElement.value);
        }
    }
    /**
     * Registers a function to be executed after the onInput handler.
     * The registered hook receives a `KeyboardEvent` from the onInput event handler as a parameter.
     *
     * **Note:** If you register a `afterInputHook`, you may also register a `beforePasteHook`
     * to perform similar changes for pasting.
     */
    registerAfterInputHook(afterInput) {
        this._afterInputHook = afterInput;
    }
    /**
     * Registers a function to be executed before the onPaste handler.
     * The registered hook receives a `ClipboardEvent` from the onPaste event handler as a parameter.
     */
    registerBeforePasteHook(beforePaste) {
        this._beforePasteHook = beforePaste;
    }
    /** Whether the mask validation should be deactivated. */
    set deactivateMask(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._deactivateMask) {
            this._deactivateMask = newValue;
            if (this._deactivateMask) {
                this.updateValue(this.getUnmaskedValue());
            }
            else {
                this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            }
            this._callOnChangeCallback();
        }
    }
    get deactivateMask() {
        return this._deactivateMask;
    }
    /** Sets the mask. */
    set mask(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._callOnChangeCallback();
            this._validatorOnChange();
        }
    }
    get mask() {
        return this._mask;
    }
    /** Sets the case sensitivity of the mask. */
    set convertTo(value) {
        this._convertTo = value; // TODO properly coerce input value
        this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        this._callOnChangeCallback();
    }
    get convertTo() {
        return this._convertTo;
    }
    /**
     * Sets the keys that are recognized as separators.
     * Default separators: / ( ) . : - + , and space.
     */
    set separators(values) {
        this._separators = values;
        this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
        this._validatorOnChange();
        this._callOnChangeCallback();
    }
    get separators() {
        return this._separators;
    }
    /** Whether the separators should be dropped in the control value accessor. */
    set dropSpecialCharacters(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._dropSpecialCharacters) {
            this._dropSpecialCharacters = newValue;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._callOnChangeCallback();
        }
    }
    get dropSpecialCharacters() {
        return this._dropSpecialCharacters;
    }
    /** Whether the mask validation should be applied on the input. Default: true. */
    set validateMask(value) {
        const newValue = coerceBooleanProperty(value);
        if (newValue !== this._validateMask) {
            this._validateMask = newValue;
            this._validatorOnChange();
        }
    }
    get validateMask() {
        return this._validateMask;
    }
    /** @docs-private */
    get elementRefValue() {
        return this._elementRef.nativeElement.value;
    }
    /** Returns the unmasked value. */
    getUnmaskedValue() {
        const unmaskedValue = this.separators.reduce((unmasked, separator) => unmasked.split(separator).join(''), this._elementRef.nativeElement.value);
        return unmaskedValue;
    }
    /**
     * Sets the mask (for programmatical use).
     *
     * No `_onChangeCallback()` will be called!
     */
    setMask(value) {
        if (!value) {
            value = '';
        }
        if (value !== this._mask) {
            this._mask = value;
            this.updateValue(this.getMaskedString(this._elementRef.nativeElement.value));
            this._validatorOnChange();
        }
    }
    /**
     * this._cursor can be set to a new value in this function;
     * in _onInputChange() it is then used to set the cursor position.
     */
    _onKeydown(event) {
        const keyCode = event.keyCode;
        const input = event.target;
        const currentValue = this._elementRef.nativeElement.value;
        if (keyCode === BACKSPACE || keyCode === DELETE) {
            // if backspace pressed, cursor has to move one character to start
            const backspaceShift = keyCode === BACKSPACE ? 1 : 0;
            const lastCharacter = currentValue.substring(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift + 1);
            const selectionAtLastCharacter = input.selectionStart === currentValue.length - 1 + backspaceShift;
            if (input.selectionStart !== input.selectionEnd) {
                let newPosition = input.selectionStart;
                // jump behind separators, but do not shift after the next character (=> don't use _calculateCursorShift())
                while (this.isSeparator(this.mask[newPosition])) {
                    newPosition++;
                }
                this._cursor = { position: newPosition };
            }
            else if (selectionAtLastCharacter) {
                // if last character is deleted: only delete last character, do not trigger input event again
                // (here the separator would be added again)
                this.updateValue(currentValue.substring(0, currentValue.length - 1));
                this._callOnChangeCallback();
                event.preventDefault();
            }
            else if (this.isSeparator(lastCharacter)) {
                // do not delete a separator, only set cursor position
                input.setSelectionRange(input.selectionStart - backspaceShift, input.selectionEnd - backspaceShift);
                event.preventDefault();
            }
            else {
                // for any other character: decrease cursor position by one (backspaceShift).
                // the input is modified and will be validated in _onInputChange().
                this._cursor = { position: input.selectionStart - backspaceShift };
            }
        }
        else {
            this._cursor = { selectionStart: input.selectionStart, selectionEnd: input.selectionEnd };
        }
    }
    /**
     * Returns the cursor position after a letter is entered at `selectionStart` position in the mask.
     * There are two cases to consider ('|' => cursor position where the character is entered, mask: 00:00:00):
     * - before the separators there is space for entering the letter: '12:3|4:5' => '12:30:|45'
     * - the letter has to be shifted and is entered after the separators: '12:34|:5' => '12:34:0|5'
     */
    _calculateCursorShift(position) {
        let shift = 0;
        // tracks if the entered letter was already placed in the current mask
        // and therefor was considered in the cursor calculation.
        let characterWasEntered = false;
        if (!this.isSeparator(this.mask[position + shift])) {
            shift++;
            characterWasEntered = true;
        }
        while (this.isSeparator(this.mask[position + shift])) {
            shift++;
        }
        if (!characterWasEntered) {
            shift++;
        }
        return shift;
    }
    _isStringAllowed(value, maskedValue) {
        if ((maskedValue === '0' && /^\d$/.test(value)) ||
            (maskedValue === 'A' && /^[\dA-Za-z]$/.test(value)) ||
            (maskedValue === 'S' && /^[A-Za-z]$/.test(value))) {
            return true;
        }
        return false;
    }
    /**
     * Handles the onInput event.
     * `_beforeInputHook()` is called before the actual execution.
     *
     */
    _onInputChange(event) {
        // _inputValue is updated in updateValue(), so I need to pick it up here to compare it to a new value
        const oldVal = this._inputValue;
        const input = event.target;
        let newVal = this.getMaskedString(input.value);
        if (this._deactivateMask) {
            newVal = input.value;
            this.updateValue(newVal);
            this._callOnChangeCallback();
            return;
        }
        // if _pastedData was set in _onPaste(), use this value
        if (this._pastedData) {
            this.updateValue(this._pastedData);
            input.setSelectionRange(this._cursor.position, this._cursor.position);
            this._pastedData = null;
            this._cursor = null;
            this._callOnChangeCallback();
            return;
        }
        // do nothing if mask is already filled up
        if (oldVal.length === this._mask.length &&
            newVal.length === this._mask.length &&
            oldVal !== newVal &&
            this._cursor &&
            this._cursor.selectionStart !== undefined &&
            this._cursor.selectionStart === this._cursor.selectionEnd) {
            this._elementRef.nativeElement.value = this.getMaskedString(oldVal);
            input.setSelectionRange(this._cursor.selectionStart, this._cursor.selectionEnd);
            this._cursor = null;
            return;
        }
        this.updateValue(newVal);
        // set new cursor position
        if (this._cursor?.position !== undefined) {
            input.setSelectionRange(this._cursor.position, this._cursor.position);
            this._cursor = null;
        }
        else if (this._cursor?.selectionStart !== undefined) {
            // only one character can be entered (except pasting, this is calculated in _onPaste())
            if (oldVal === input.value) {
                // we always have to set the cursor position here even if nothing changed
                // because otherwise the cursor would jump to the end of the input.
                // if the cursor is placed in front of a separator and the user types a non-allowed character,
                // the cursor is supposed to jump over the separator.
                let currentPosition = this._cursor.selectionStart;
                while (this.isSeparator(this.mask[currentPosition])) {
                    currentPosition++;
                }
                input.setSelectionRange(currentPosition, currentPosition);
                this._cursor = null;
            }
            else {
                const newPosition = this._cursor.selectionStart + this._calculateCursorShift(this._cursor.selectionStart);
                input.setSelectionRange(newPosition, newPosition);
                this._cursor = null;
            }
        }
        this._afterInputHook(event);
        this._callOnChangeCallback();
    }
    /**
     * this._cursor and this._pastedData can be set to a new value in this function;
     * _cursor is used to set the cursor position after checking the masked input in _onInputChange().
     * _pastedData carries the valid part of the pasted value to _inInputChange();
     *
     *`_beforePasteHook()` is called before the actual execution.
     */
    _onPaste(event) {
        const input = event.target;
        const pastedData = (event.clipboardData || window.clipboardData).getData('text');
        // saving these three values as if something is changed in the _beforePasteHook()
        // which causes the input value to be updated, this values will get lost.
        const selectionStart = input.selectionStart;
        const selectionEnd = input.selectionEnd;
        const oldValue = input.value;
        this._beforePasteHook(event);
        const maskedString = this.getMaskedString(pastedData, selectionStart);
        // if mask is already filled up (and no characters are selected with the cursor), do nothing
        if (input.value.length === this._mask.length && maskedString.length > 0 && selectionStart === selectionEnd) {
            input.setSelectionRange(selectionStart, selectionEnd);
            this._cursor = null; // was set in _onKeydown(), but will not be used in this case; so reset it
            event.preventDefault();
            return;
        }
        // if length of newValue is >= mask: allow only to enter characters from a pasted value until mask is filled up
        // example: 12:|34: ("|" cursor position, mask: 00:00:00) => when pasting '567', only '56' fits in until input is filled up => 12:56:|34
        // get the pasted unmasked value from the pasted string (to cut all the invalid characters and separators)
        const pastedUnmaskedValue = this.separators.reduce((unmasked, separator) => unmasked.split(separator).join(''), maskedString);
        let newValue = this.getMaskedString(oldValue.substring(0, selectionStart) + pastedUnmaskedValue + oldValue.substring(selectionEnd, oldValue.length));
        if (newValue.length >= this._mask.length) {
            let newPosition = selectionStart;
            let i = 1;
            do {
                newValue = this.getMaskedString(oldValue.substring(0, selectionStart) + pastedUnmaskedValue.substring(0, i) + oldValue.substring(selectionEnd, oldValue.length));
                newPosition += this._calculateCursorShift(newPosition);
                i++;
            } while (newValue.length < this._mask.length);
            // save value for using it in _onInputChange()
            this._pastedData = newValue;
            this._cursor = {
                position: newPosition,
            };
            return;
        }
        // if pasting is fine: save the cursor position for using them in _onInputChange()
        this._cursor = {
            position: selectionStart + maskedString.length,
        };
    }
    updateValue(value) {
        if (!this._deactivateMask) {
            // Write UpperCase
            if (this._convertTo === 'upper') {
                value = value.toUpperCase();
            }
            else if (this._convertTo === 'lower') {
                value = value.toLowerCase();
            }
        }
        this._elementRef.nativeElement.value = value;
        // _inputValue is needed for calculating the cursor shift in onInput()
        this._inputValue = value;
    }
    /** @docs-private */
    getMaskedString(inputValue, maskStartIndex = 0) {
        let formattedValue = '';
        let maskIndex = maskStartIndex;
        let inputIndex = 0;
        // insert if next in mask is separator
        while (this.isSeparator(this.mask[maskIndex])) {
            formattedValue += this.mask[maskIndex];
            maskIndex++;
        }
        while (inputIndex < inputValue.length) {
            // test if letters are valid
            if (this._isStringAllowed(inputValue[inputIndex], this.mask[maskIndex])) {
                formattedValue += inputValue[inputIndex];
                inputIndex++;
                maskIndex++;
            }
            else {
                inputIndex++;
            }
            // insert if next in mask is separator
            while (this.isSeparator(this.mask[maskIndex])) {
                formattedValue += this.mask[maskIndex];
                maskIndex++;
            }
        }
        return formattedValue;
    }
    isSeparator(value) {
        return this._separators.includes(value);
    }
    // control value accessor
    writeValue(value) {
        if (!value) {
            value = '';
        }
        this.cvaModelChange.next(value);
        if (this.deactivateMask) {
            this.updateValue(value || this.getUnmaskedValue());
        }
        else {
            this.updateValue(this.getMaskedString(value));
        }
    }
    registerOnChange(onChange) {
        this._onChangeCallback = onChange;
    }
    registerOnTouched(onTouched) {
        this._onTouchedCallback = onTouched;
    }
    /** @docs-private */
    registerOnValidatorChange(fn) {
        this._validatorOnChange = fn;
    }
    _validateFn() {
        const inputLength = this._elementRef.nativeElement.value.length;
        const maskLength = this._mask.length;
        if (inputLength !== maskLength && !this.deactivateMask) {
            return { nxMaskLengthError: { length: maskLength, actual: inputLength } };
        }
        return null;
    }
    /** @docs-private */
    validate() {
        return this.validateMask ? this._validateFn() : null;
    }
    _touch() {
        this._onTouchedCallback();
    }
}
NxMaskDirective.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMaskDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive });
NxMaskDirective.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "12.0.0", version: "13.3.1", type: NxMaskDirective, selector: "input[nxMask]", inputs: { deactivateMask: "deactivateMask", mask: ["nxMask", "mask"], convertTo: ["nxConvertTo", "convertTo"], separators: "separators", dropSpecialCharacters: "dropSpecialCharacters", validateMask: "validateMask" }, host: { listeners: { "input": "_onInputChange($event)", "keydown": "_onKeydown($event)", "paste": "_onPaste($event)", "blur": "_touch()" } }, providers: [NX_MASK_VALUE_ACCESSOR, { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective }, NX_MASK_VALIDATORS], exportAs: ["nxMaskDirective"], ngImport: i0 });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxMaskDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[nxMask]',
                    host: {
                        '(input)': '_onInputChange($event)',
                        '(keydown)': '_onKeydown($event)',
                        '(paste)': '_onPaste($event)',
                        '(blur)': '_touch()',
                    },
                    exportAs: 'nxMaskDirective',
                    providers: [NX_MASK_VALUE_ACCESSOR, { provide: NX_INPUT_VALUE_ACCESSOR, useExisting: NxMaskDirective }, NX_MASK_VALIDATORS],
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { deactivateMask: [{
                type: Input
            }], mask: [{
                type: Input,
                args: ['nxMask']
            }], convertTo: [{
                type: Input,
                args: ['nxConvertTo']
            }], separators: [{
                type: Input
            }], dropSpecialCharacters: [{
                type: Input
            }], validateMask: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFzay5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL21hc2svbWFzay5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFnQixxQkFBcUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQzVFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDMUQsT0FBTyxFQUFFLFNBQVMsRUFBYyxVQUFVLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pFLE9BQU8sRUFBd0IsYUFBYSxFQUFFLGlCQUFpQixFQUFhLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkcsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDbEUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQzs7QUFJL0IsTUFBTSxDQUFDLE1BQU0sc0JBQXNCLEdBQVE7SUFDdkMsT0FBTyxFQUFFLGlCQUFpQjtJQUMxQixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLGVBQWUsQ0FBQztJQUM5QyxLQUFLLEVBQUUsSUFBSTtDQUNkLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxrQkFBa0IsR0FBUTtJQUNuQyxPQUFPLEVBQUUsYUFBYTtJQUN0QixXQUFXLEVBQUUsVUFBVSxDQUFDLEdBQUcsRUFBRSxDQUFDLGVBQWUsQ0FBQztJQUM5QyxLQUFLLEVBQUUsSUFBSTtDQUNkLENBQUM7QUF1QkYsTUFBTSxPQUFPLGVBQWU7SUF1SnhCLFlBQW9CLFdBQXVCO1FBQXZCLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBdEpuQyxnQkFBVyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxHQUFH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O0lBQ2hCLENBQUM7SUFFRCxvQkFBb0I7SUFDcEIsUUFBUTtRQUNKLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDekQsQ0FBQztJQUVELE1BQU07UUFDRixJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUM5QixDQUFDOzs0R0E3ZVEsZUFBZTtnR0FBZixlQUFlLCtZQUZiLENBQUMsc0JBQXNCLEVBQUUsRUFBRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsV0FBVyxFQUFFLGVBQWUsRUFBRSxFQUFFLGtCQUFrQixDQUFDOzJGQUVsSCxlQUFlO2tCQVgzQixTQUFTO21CQUFDO29CQUNQLFFBQVEsRUFBRSxlQUFlO29CQUN6QixJQUFJLEVBQUU7d0JBQ0YsU0FBUyxFQUFFLHdCQUF3Qjt3QkFDbkMsV0FBVyxFQUFFLG9CQUFvQjt3QkFDakMsU0FBUyxFQUFFLGtCQUFrQjt3QkFDN0IsUUFBUSxFQUFFLFVBQVU7cUJBQ3ZCO29CQUNELFFBQVEsRUFBRSxpQkFBaUI7b0JBQzNCLFNBQVMsRUFBRSxDQUFDLHNCQUFzQixFQUFFLEVBQUUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFdBQVcsaUJBQWlCLEVBQUUsRUFBRSxrQkFBa0IsQ0FBQztpQkFDOUg7aUdBa0VPLGNBQWM7c0JBRGpCLEtBQUs7Z0JBbUJGLElBQUk7c0JBRFAsS0FBSzt1QkFBQyxRQUFRO2dCQWtCWCxTQUFTO3NCQURaLEtBQUs7dUJBQUMsYUFBYTtnQkFlaEIsVUFBVTtzQkFEYixLQUFLO2dCQWFGLHFCQUFxQjtzQkFEeEIsS0FBSztnQkFlRixZQUFZO3NCQURmLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb29sZWFuSW5wdXQsIGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9jb2VyY2lvbic7XG5pbXBvcnQgeyBCQUNLU1BBQ0UsIERFTEVURSB9IGZyb20gJ0Bhbmd1bGFyL2Nkay9rZXljb2Rlcyc7XG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIGZvcndhcmRSZWYsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMSURBVE9SUywgTkdfVkFMVUVfQUNDRVNTT1IsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE5YX0lOUFVUX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFwb3Npbi9uZy1hcXVpbGEvaW5wdXQnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG50eXBlIE1BU0tfVFlQRSA9ICcwJyB8ICdBJyB8ICdTJztcblxuZXhwb3J0IGNvbnN0IE5YX01BU0tfVkFMVUVfQUNDRVNTT1I6IGFueSA9IHtcbiAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOeE1hc2tEaXJlY3RpdmUpLFxuICAgIG11bHRpOiB0cnVlLFxufTtcblxuZXhwb3J0IGNvbnN0IE5YX01BU0tfVkFMSURBVE9SUzogYW55ID0ge1xuICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsXG4gICAgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gTnhNYXNrRGlyZWN0aXZlKSxcbiAgICBtdWx0aTogdHJ1ZSxcbn07XG5cbi8qKiBPcHRpb25zIGZvciBpbnB1dCBjYXNlIHNlbnNpdGl2aXR5LiAqL1xuZXhwb3J0IHR5cGUgTWFza0NvbnZlcnNpb25UeXBlcyA9ICdsb3dlcicgfCAndXBwZXInO1xuXG4vKiogSW50ZXJmYWNlIGZvciBzYXZpbmcgdGhlIGN1cnNvciBpbmZvcm1hdGlvbi4gKi9cbmludGVyZmFjZSBDdXJzb3JJbmZvIHtcbiAgICBzZWxlY3Rpb25TdGFydD86IG51bWJlcjtcbiAgICBzZWxlY3Rpb25FbmQ/OiBudW1iZXI7XG4gICAgcG9zaXRpb24/OiBudW1iZXI7XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnaW5wdXRbbnhNYXNrXScsXG4gICAgaG9zdDoge1xuICAgICAgICAnKGlucHV0KSc6ICdfb25JbnB1dENoYW5nZSgkZXZlbnQpJyxcbiAgICAgICAgJyhrZXlkb3duKSc6ICdfb25LZXlkb3duKCRldmVudCknLFxuICAgICAgICAnKHBhc3RlKSc6ICdfb25QYXN0ZSgkZXZlbnQpJyxcbiAgICAgICAgJyhibHVyKSc6ICdfdG91Y2goKScsXG4gICAgfSxcbiAgICBleHBvcnRBczogJ254TWFza0RpcmVjdGl2ZScsXG4gICAgcHJvdmlkZXJzOiBbTlhfTUFTS19WQUxVRV9BQ0NFU1NPUiwgeyBwcm92aWRlOiBOWF9JTlBVVF9WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IE54TWFza0RpcmVjdGl2ZSB9LCBOWF9NQVNLX1ZBTElEQVRPUlNdLFxufSlcbmV4cG9ydCBjbGFzcyBOeE1hc2tEaXJlY3RpdmUgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIHtcbiAgICBwcml2YXRlIF9zZXBhcmF0b3JzID0gWycvJywgJygnLCAnKScsICcuJywgJzonLCAnLScsICcgJywgJysnLCAnLCddO1xuICAgIHByaXZhdGUgX2Ryb3BTcGVjaWFsQ2hhcmFjdGVycyA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3ZhbGlkYXRlTWFzayA9IHRydWU7XG4gICAgcHJpdmF0ZSBfY29udmVydFRvPzogTWFza0NvbnZlcnNpb25UeXBlcztcbiAgICBwcml2YXRlIF9kZWFjdGl2YXRlTWFzaz86IGJvb2xlYW4gPSBmYWxzZTtcbiAgICBwcml2YXRlIF9tYXNrID0gJyc7XG4gICAgLyoqXG4gICAgICogX2N1cnNvciBpcyBhIGhlbHBlciBmb3Igc2F2aW5nIGEgcG9zaXRpb24gb3IgYSBzZWxlY3Rpb25SYW5nZSAoc2VsZWN0aW9uU3RhcnQgKyBzZWxlY3Rpb25FbmQpXG4gICAgICogYW5kIHRoZW4gYXBwbHkgaXQgbGF0ZXIgb24gKGluIF9vbklucHV0Q2hhbmdlKCkpLlxuICAgICAqXG4gICAgICogX2N1cnNvci5wb3NpdGlvbiBpcyB1c2VkIGZvciBzYXZpbmcgYSBwb3NpdGlvbiB0aGF0IGlzIHRoZW4gYXBwbGllZCB3aXRob3V0IGFueSBjaGFuZ2VzLlxuICAgICAqIGlmIHRoZSBwb3NpdGlvbiBpcyBzYXZlZCwgc2VsZWN0aW9uU3RhcnQgYW5kIHNlbGVjdGlvbkVuZCB3aWxsIGJlIGlnbm9yZWQgaW4gX29uSW5wdXRDaGFuZ2UoKS5cbiAgICAgKiBfY3Vyc29yLnNlbGVjdGlvblN0YXJ0IGFuZCBzZWxlY3Rpb25FbmQgaXMgdXNlZCBmb3Igc2F2aW5nIHRoZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvbixcbiAgICAgKiBhbmQgYSBuZXcgY3Vyc29yIHBvc2l0aW9uIGlzIHRoZW4gY2FsY3VsYXRlZCB3aXRoIHRoaXMgZGF0YS5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9jdXJzb3IhOiBDdXJzb3JJbmZvIHwgbnVsbDtcblxuICAgIC8qKiBoZWxwZXIgdmFyaWFibGUgZm9yIHNhdmluZyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWxlbWVudCB0byBjb21wYXJlIGl0IHRoZW4gd2l0aCBhIG5ldyB2YWx1ZS4gKi9cbiAgICBwcml2YXRlIF9pbnB1dFZhbHVlITogc3RyaW5nO1xuXG4gICAgLyoqIGhlbHBlciB2YXJpYWJsZSBmb3Igc2F2aW5nIHRoZSBtYXNrZWQgc3RyaW5nIG9mIGEgcGFzdGVkIHZhbHVlIGFuZCB0aGVuIGFwcGx5aW5nIGl0IGluIF9vbklucHV0Q2hhbmdlKCkuICovXG4gICAgcHJpdmF0ZSBfcGFzdGVkRGF0YSE6IHN0cmluZyB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyB0aGUgdW5tYXNrZWQgdmFsdWUgYmVmb3JlIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHJlYWRvbmx5IGN2YU1vZGVsQ2hhbmdlID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG4gICAgcHJpdmF0ZSBfb25DaGFuZ2VDYWxsYmFjayA9IChfOiBhbnkpID0+IHt9O1xuICAgIHByaXZhdGUgX29uVG91Y2hlZENhbGxiYWNrID0gKCkgPT4ge307XG4gICAgcHJpdmF0ZSBfdmFsaWRhdG9yT25DaGFuZ2UgPSAoKSA9PiB7fTtcblxuICAgIHByaXZhdGUgX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCkge1xuICAgICAgICBpZiAodGhpcy5kcm9wU3BlY2lhbENoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sodGhpcy5nZXRVbm1hc2tlZFZhbHVlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYWZ0ZXJJbnB1dEhvb2sgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpID0+IHt9O1xuICAgIHByaXZhdGUgX2JlZm9yZVBhc3RlSG9vayA9IChldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IHt9O1xuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlIG9uSW5wdXQgaGFuZGxlci5cbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBob29rIHJlY2VpdmVzIGEgYEtleWJvYXJkRXZlbnRgIGZyb20gdGhlIG9uSW5wdXQgZXZlbnQgaGFuZGxlciBhcyBhIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBJZiB5b3UgcmVnaXN0ZXIgYSBgYWZ0ZXJJbnB1dEhvb2tgLCB5b3UgbWF5IGFsc28gcmVnaXN0ZXIgYSBgYmVmb3JlUGFzdGVIb29rYFxuICAgICAqIHRvIHBlcmZvcm0gc2ltaWxhciBjaGFuZ2VzIGZvciBwYXN0aW5nLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWZ0ZXJJbnB1dEhvb2soYWZ0ZXJJbnB1dDogKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICAgIHRoaXMuX2FmdGVySW5wdXRIb29rID0gYWZ0ZXJJbnB1dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBiZWZvcmUgdGhlIG9uUGFzdGUgaGFuZGxlci5cbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBob29rIHJlY2VpdmVzIGEgYENsaXBib2FyZEV2ZW50YCBmcm9tIHRoZSBvblBhc3RlIGV2ZW50IGhhbmRsZXIgYXMgYSBwYXJhbWV0ZXIuXG4gICAgICovXG4gICAgcmVnaXN0ZXJCZWZvcmVQYXN0ZUhvb2soYmVmb3JlUGFzdGU6IChldmVudDogQ2xpcGJvYXJkRXZlbnQpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fYmVmb3JlUGFzdGVIb29rID0gYmVmb3JlUGFzdGU7XG4gICAgfVxuXG4gICAgLyoqIFdoZXRoZXIgdGhlIG1hc2sgdmFsaWRhdGlvbiBzaG91bGQgYmUgZGVhY3RpdmF0ZWQuICovXG4gICAgQElucHV0KClcbiAgICBzZXQgZGVhY3RpdmF0ZU1hc2sodmFsdWU6IEJvb2xlYW5JbnB1dCkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5fZGVhY3RpdmF0ZU1hc2spIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYWN0aXZhdGVNYXNrID0gbmV3VmFsdWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZGVhY3RpdmF0ZU1hc2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuZ2V0VW5tYXNrZWRWYWx1ZSgpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRlYWN0aXZhdGVNYXNrKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVhY3RpdmF0ZU1hc2sgYXMgYm9vbGVhbjtcbiAgICB9XG5cbiAgICAvKiogU2V0cyB0aGUgbWFzay4gKi9cbiAgICBASW5wdXQoJ254TWFzaycpXG4gICAgc2V0IG1hc2sodmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fbWFzaykge1xuICAgICAgICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtYXNrKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXNrO1xuICAgIH1cblxuICAgIC8qKiBTZXRzIHRoZSBjYXNlIHNlbnNpdGl2aXR5IG9mIHRoZSBtYXNrLiAqL1xuICAgIEBJbnB1dCgnbnhDb252ZXJ0VG8nKVxuICAgIHNldCBjb252ZXJ0VG8odmFsdWU6IE1hc2tDb252ZXJzaW9uVHlwZXMgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX2NvbnZlcnRUbyA9IHZhbHVlITsgLy8gVE9ETyBwcm9wZXJseSBjb2VyY2UgaW5wdXQgdmFsdWVcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgdGhpcy5fY2FsbE9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICB9XG4gICAgZ2V0IGNvbnZlcnRUbygpOiBNYXNrQ29udmVyc2lvblR5cGVzIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnZlcnRUbyBhcyBNYXNrQ29udmVyc2lvblR5cGVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGtleXMgdGhhdCBhcmUgcmVjb2duaXplZCBhcyBzZXBhcmF0b3JzLlxuICAgICAqIERlZmF1bHQgc2VwYXJhdG9yczogLyAoICkgLiA6IC0gKyAsIGFuZCBzcGFjZS5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBzZXBhcmF0b3JzKHZhbHVlczogc3RyaW5nW10pIHtcbiAgICAgICAgdGhpcy5fc2VwYXJhdG9ycyA9IHZhbHVlcztcbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fY2FsbE9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICB9XG4gICAgZ2V0IHNlcGFyYXRvcnMoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VwYXJhdG9ycztcbiAgICB9XG5cbiAgICAvKiogV2hldGhlciB0aGUgc2VwYXJhdG9ycyBzaG91bGQgYmUgZHJvcHBlZCBpbiB0aGUgY29udHJvbCB2YWx1ZSBhY2Nlc3Nvci4gKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBkcm9wU3BlY2lhbENoYXJhY3RlcnModmFsdWU6IEJvb2xlYW5JbnB1dCkge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGNvZXJjZUJvb2xlYW5Qcm9wZXJ0eSh2YWx1ZSk7XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5fZHJvcFNwZWNpYWxDaGFyYWN0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU3BlY2lhbENoYXJhY3RlcnMgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5nZXRNYXNrZWRTdHJpbmcodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsT25DaGFuZ2VDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkcm9wU3BlY2lhbENoYXJhY3RlcnMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcm9wU3BlY2lhbENoYXJhY3RlcnM7XG4gICAgfVxuXG4gICAgLyoqIFdoZXRoZXIgdGhlIG1hc2sgdmFsaWRhdGlvbiBzaG91bGQgYmUgYXBwbGllZCBvbiB0aGUgaW5wdXQuIERlZmF1bHQ6IHRydWUuICovXG4gICAgQElucHV0KClcbiAgICBzZXQgdmFsaWRhdGVNYXNrKHZhbHVlOiBCb29sZWFuSW5wdXQpIHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuX3ZhbGlkYXRlTWFzaykge1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGVNYXNrID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB2YWxpZGF0ZU1hc2soKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWxpZGF0ZU1hc2s7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZikge31cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgZ2V0IGVsZW1lbnRSZWZWYWx1ZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuICAgIH1cblxuICAgIC8qKiBSZXR1cm5zIHRoZSB1bm1hc2tlZCB2YWx1ZS4gKi9cbiAgICBnZXRVbm1hc2tlZFZhbHVlKCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IHVubWFza2VkVmFsdWUgPSB0aGlzLnNlcGFyYXRvcnMucmVkdWNlKCh1bm1hc2tlZCwgc2VwYXJhdG9yKSA9PiB1bm1hc2tlZC5zcGxpdChzZXBhcmF0b3IpLmpvaW4oJycpLCB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB1bm1hc2tlZFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1hc2sgKGZvciBwcm9ncmFtbWF0aWNhbCB1c2UpLlxuICAgICAqXG4gICAgICogTm8gYF9vbkNoYW5nZUNhbGxiYWNrKClgIHdpbGwgYmUgY2FsbGVkIVxuICAgICAqL1xuICAgIHNldE1hc2sodmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fbWFzaykge1xuICAgICAgICAgICAgdGhpcy5fbWFzayA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB0aGlzLl9jdXJzb3IgY2FuIGJlIHNldCB0byBhIG5ldyB2YWx1ZSBpbiB0aGlzIGZ1bmN0aW9uO1xuICAgICAqIGluIF9vbklucHV0Q2hhbmdlKCkgaXQgaXMgdGhlbiB1c2VkIHRvIHNldCB0aGUgY3Vyc29yIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIF9vbktleWRvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG5cbiAgICAgICAgY29uc3QgaW5wdXQ6IEhUTUxJbnB1dEVsZW1lbnQgPSBldmVudC50YXJnZXQgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlO1xuXG4gICAgICAgIGlmIChrZXlDb2RlID09PSBCQUNLU1BBQ0UgfHwga2V5Q29kZSA9PT0gREVMRVRFKSB7XG4gICAgICAgICAgICAvLyBpZiBiYWNrc3BhY2UgcHJlc3NlZCwgY3Vyc29yIGhhcyB0byBtb3ZlIG9uZSBjaGFyYWN0ZXIgdG8gc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IGJhY2tzcGFjZVNoaWZ0ID0ga2V5Q29kZSA9PT0gQkFDS1NQQUNFID8gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCBsYXN0Q2hhcmFjdGVyID0gY3VycmVudFZhbHVlLnN1YnN0cmluZyhpbnB1dC5zZWxlY3Rpb25TdGFydCEgLSBiYWNrc3BhY2VTaGlmdCwgaW5wdXQuc2VsZWN0aW9uRW5kISAtIGJhY2tzcGFjZVNoaWZ0ICsgMSk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25BdExhc3RDaGFyYWN0ZXIgPSBpbnB1dC5zZWxlY3Rpb25TdGFydCA9PT0gY3VycmVudFZhbHVlLmxlbmd0aCAtIDEgKyBiYWNrc3BhY2VTaGlmdDtcblxuICAgICAgICAgICAgaWYgKGlucHV0LnNlbGVjdGlvblN0YXJ0ICE9PSBpbnB1dC5zZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV3UG9zaXRpb246IG51bWJlciA9IGlucHV0LnNlbGVjdGlvblN0YXJ0IGFzIG51bWJlcjtcbiAgICAgICAgICAgICAgICAvLyBqdW1wIGJlaGluZCBzZXBhcmF0b3JzLCBidXQgZG8gbm90IHNoaWZ0IGFmdGVyIHRoZSBuZXh0IGNoYXJhY3RlciAoPT4gZG9uJ3QgdXNlIF9jYWxjdWxhdGVDdXJzb3JTaGlmdCgpKVxuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzU2VwYXJhdG9yKHRoaXMubWFza1tuZXdQb3NpdGlvbl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Bvc2l0aW9uKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHsgcG9zaXRpb246IG5ld1Bvc2l0aW9uIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbkF0TGFzdENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIC8vIGlmIGxhc3QgY2hhcmFjdGVyIGlzIGRlbGV0ZWQ6IG9ubHkgZGVsZXRlIGxhc3QgY2hhcmFjdGVyLCBkbyBub3QgdHJpZ2dlciBpbnB1dCBldmVudCBhZ2FpblxuICAgICAgICAgICAgICAgIC8vIChoZXJlIHRoZSBzZXBhcmF0b3Igd291bGQgYmUgYWRkZWQgYWdhaW4pXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShjdXJyZW50VmFsdWUuc3Vic3RyaW5nKDAsIGN1cnJlbnRWYWx1ZS5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FsbE9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzU2VwYXJhdG9yKGxhc3RDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGRlbGV0ZSBhIHNlcGFyYXRvciwgb25seSBzZXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoaW5wdXQuc2VsZWN0aW9uU3RhcnQhIC0gYmFja3NwYWNlU2hpZnQsIGlucHV0LnNlbGVjdGlvbkVuZCEgLSBiYWNrc3BhY2VTaGlmdCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGFueSBvdGhlciBjaGFyYWN0ZXI6IGRlY3JlYXNlIGN1cnNvciBwb3NpdGlvbiBieSBvbmUgKGJhY2tzcGFjZVNoaWZ0KS5cbiAgICAgICAgICAgICAgICAvLyB0aGUgaW5wdXQgaXMgbW9kaWZpZWQgYW5kIHdpbGwgYmUgdmFsaWRhdGVkIGluIF9vbklucHV0Q2hhbmdlKCkuXG4gICAgICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0geyBwb3NpdGlvbjogaW5wdXQuc2VsZWN0aW9uU3RhcnQhIC0gYmFja3NwYWNlU2hpZnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IHsgc2VsZWN0aW9uU3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0IGFzIG51bWJlciwgc2VsZWN0aW9uRW5kOiBpbnB1dC5zZWxlY3Rpb25FbmQgYXMgbnVtYmVyIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgYSBsZXR0ZXIgaXMgZW50ZXJlZCBhdCBgc2VsZWN0aW9uU3RhcnRgIHBvc2l0aW9uIGluIHRoZSBtYXNrLlxuICAgICAqIFRoZXJlIGFyZSB0d28gY2FzZXMgdG8gY29uc2lkZXIgKCd8JyA9PiBjdXJzb3IgcG9zaXRpb24gd2hlcmUgdGhlIGNoYXJhY3RlciBpcyBlbnRlcmVkLCBtYXNrOiAwMDowMDowMCk6XG4gICAgICogLSBiZWZvcmUgdGhlIHNlcGFyYXRvcnMgdGhlcmUgaXMgc3BhY2UgZm9yIGVudGVyaW5nIHRoZSBsZXR0ZXI6ICcxMjozfDQ6NScgPT4gJzEyOjMwOnw0NSdcbiAgICAgKiAtIHRoZSBsZXR0ZXIgaGFzIHRvIGJlIHNoaWZ0ZWQgYW5kIGlzIGVudGVyZWQgYWZ0ZXIgdGhlIHNlcGFyYXRvcnM6ICcxMjozNHw6NScgPT4gJzEyOjM0OjB8NSdcbiAgICAgKi9cbiAgICBwcml2YXRlIF9jYWxjdWxhdGVDdXJzb3JTaGlmdChwb3NpdGlvbjogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHNoaWZ0ID0gMDtcbiAgICAgICAgLy8gdHJhY2tzIGlmIHRoZSBlbnRlcmVkIGxldHRlciB3YXMgYWxyZWFkeSBwbGFjZWQgaW4gdGhlIGN1cnJlbnQgbWFza1xuICAgICAgICAvLyBhbmQgdGhlcmVmb3Igd2FzIGNvbnNpZGVyZWQgaW4gdGhlIGN1cnNvciBjYWxjdWxhdGlvbi5cbiAgICAgICAgbGV0IGNoYXJhY3Rlcldhc0VudGVyZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW3Bvc2l0aW9uICsgc2hpZnRdKSkge1xuICAgICAgICAgICAgc2hpZnQrKztcbiAgICAgICAgICAgIGNoYXJhY3Rlcldhc0VudGVyZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW3Bvc2l0aW9uICsgc2hpZnRdKSkge1xuICAgICAgICAgICAgc2hpZnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2hhcmFjdGVyV2FzRW50ZXJlZCkge1xuICAgICAgICAgICAgc2hpZnQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzaGlmdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pc1N0cmluZ0FsbG93ZWQodmFsdWU6IHN0cmluZywgbWFza2VkVmFsdWU6IE1BU0tfVFlQRSkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICAobWFza2VkVmFsdWUgPT09ICcwJyAmJiAvXlxcZCQvLnRlc3QodmFsdWUpKSB8fFxuICAgICAgICAgICAgKG1hc2tlZFZhbHVlID09PSAnQScgJiYgL15bXFxkQS1aYS16XSQvLnRlc3QodmFsdWUpKSB8fFxuICAgICAgICAgICAgKG1hc2tlZFZhbHVlID09PSAnUycgJiYgL15bQS1aYS16XSQvLnRlc3QodmFsdWUpKVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBvbklucHV0IGV2ZW50LlxuICAgICAqIGBfYmVmb3JlSW5wdXRIb29rKClgIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGFjdHVhbCBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBfb25JbnB1dENoYW5nZShldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAvLyBfaW5wdXRWYWx1ZSBpcyB1cGRhdGVkIGluIHVwZGF0ZVZhbHVlKCksIHNvIEkgbmVlZCB0byBwaWNrIGl0IHVwIGhlcmUgdG8gY29tcGFyZSBpdCB0byBhIG5ldyB2YWx1ZVxuICAgICAgICBjb25zdCBvbGRWYWwgPSB0aGlzLl9pbnB1dFZhbHVlO1xuICAgICAgICBjb25zdCBpbnB1dDogSFRNTElucHV0RWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICBsZXQgbmV3VmFsID0gdGhpcy5nZXRNYXNrZWRTdHJpbmcoaW5wdXQudmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fZGVhY3RpdmF0ZU1hc2spIHtcbiAgICAgICAgICAgIG5ld1ZhbCA9IGlucHV0LnZhbHVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShuZXdWYWwpO1xuICAgICAgICAgICAgdGhpcy5fY2FsbE9uQ2hhbmdlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBfcGFzdGVkRGF0YSB3YXMgc2V0IGluIF9vblBhc3RlKCksIHVzZSB0aGlzIHZhbHVlXG4gICAgICAgIGlmICh0aGlzLl9wYXN0ZWREYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKHRoaXMuX3Bhc3RlZERhdGEpO1xuICAgICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UodGhpcy5fY3Vyc29yIS5wb3NpdGlvbiBhcyBudW1iZXIsIHRoaXMuX2N1cnNvciEucG9zaXRpb24gYXMgbnVtYmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3Bhc3RlZERhdGEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY3Vyc29yID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBkbyBub3RoaW5nIGlmIG1hc2sgaXMgYWxyZWFkeSBmaWxsZWQgdXBcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgb2xkVmFsLmxlbmd0aCA9PT0gdGhpcy5fbWFzay5sZW5ndGggJiZcbiAgICAgICAgICAgIG5ld1ZhbC5sZW5ndGggPT09IHRoaXMuX21hc2subGVuZ3RoICYmXG4gICAgICAgICAgICBvbGRWYWwgIT09IG5ld1ZhbCAmJlxuICAgICAgICAgICAgdGhpcy5fY3Vyc29yICYmXG4gICAgICAgICAgICB0aGlzLl9jdXJzb3Iuc2VsZWN0aW9uU3RhcnQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0ID09PSB0aGlzLl9jdXJzb3Iuc2VsZWN0aW9uRW5kXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdGhpcy5nZXRNYXNrZWRTdHJpbmcob2xkVmFsKTtcbiAgICAgICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKHRoaXMuX2N1cnNvci5zZWxlY3Rpb25TdGFydCwgdGhpcy5fY3Vyc29yLnNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVWYWx1ZShuZXdWYWwpO1xuXG4gICAgICAgIC8vIHNldCBuZXcgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgIGlmICh0aGlzLl9jdXJzb3I/LnBvc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnNldFNlbGVjdGlvblJhbmdlKHRoaXMuX2N1cnNvci5wb3NpdGlvbiwgdGhpcy5fY3Vyc29yLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3Vyc29yPy5zZWxlY3Rpb25TdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBvbmx5IG9uZSBjaGFyYWN0ZXIgY2FuIGJlIGVudGVyZWQgKGV4Y2VwdCBwYXN0aW5nLCB0aGlzIGlzIGNhbGN1bGF0ZWQgaW4gX29uUGFzdGUoKSlcbiAgICAgICAgICAgIGlmIChvbGRWYWwgPT09IGlucHV0LnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWx3YXlzIGhhdmUgdG8gc2V0IHRoZSBjdXJzb3IgcG9zaXRpb24gaGVyZSBldmVuIGlmIG5vdGhpbmcgY2hhbmdlZFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd291bGQganVtcCB0byB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3Vyc29yIGlzIHBsYWNlZCBpbiBmcm9udCBvZiBhIHNlcGFyYXRvciBhbmQgdGhlIHVzZXIgdHlwZXMgYSBub24tYWxsb3dlZCBjaGFyYWN0ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnNvciBpcyBzdXBwb3NlZCB0byBqdW1wIG92ZXIgdGhlIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFBvc2l0aW9uID0gdGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzU2VwYXJhdG9yKHRoaXMubWFza1tjdXJyZW50UG9zaXRpb25dKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UG9zaXRpb24rKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoY3VycmVudFBvc2l0aW9uLCBjdXJyZW50UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1Bvc2l0aW9uID0gdGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0ICsgdGhpcy5fY2FsY3VsYXRlQ3Vyc29yU2hpZnQodGhpcy5fY3Vyc29yLnNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpbnB1dC5zZXRTZWxlY3Rpb25SYW5nZShuZXdQb3NpdGlvbiwgbmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hZnRlcklucHV0SG9vayhldmVudCk7XG4gICAgICAgIHRoaXMuX2NhbGxPbkNoYW5nZUNhbGxiYWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdGhpcy5fY3Vyc29yIGFuZCB0aGlzLl9wYXN0ZWREYXRhIGNhbiBiZSBzZXQgdG8gYSBuZXcgdmFsdWUgaW4gdGhpcyBmdW5jdGlvbjtcbiAgICAgKiBfY3Vyc29yIGlzIHVzZWQgdG8gc2V0IHRoZSBjdXJzb3IgcG9zaXRpb24gYWZ0ZXIgY2hlY2tpbmcgdGhlIG1hc2tlZCBpbnB1dCBpbiBfb25JbnB1dENoYW5nZSgpLlxuICAgICAqIF9wYXN0ZWREYXRhIGNhcnJpZXMgdGhlIHZhbGlkIHBhcnQgb2YgdGhlIHBhc3RlZCB2YWx1ZSB0byBfaW5JbnB1dENoYW5nZSgpO1xuICAgICAqXG4gICAgICpgX2JlZm9yZVBhc3RlSG9vaygpYCBpcyBjYWxsZWQgYmVmb3JlIHRoZSBhY3R1YWwgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIF9vblBhc3RlKGV2ZW50OiBDbGlwYm9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBpbnB1dDogSFRNTElucHV0RWxlbWVudCA9IGV2ZW50LnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50O1xuICAgICAgICBjb25zdCBwYXN0ZWREYXRhID0gKGV2ZW50LmNsaXBib2FyZERhdGEgfHwgKHdpbmRvdyBhcyBhbnkpLmNsaXBib2FyZERhdGEpLmdldERhdGEoJ3RleHQnKTtcblxuICAgICAgICAvLyBzYXZpbmcgdGhlc2UgdGhyZWUgdmFsdWVzIGFzIGlmIHNvbWV0aGluZyBpcyBjaGFuZ2VkIGluIHRoZSBfYmVmb3JlUGFzdGVIb29rKClcbiAgICAgICAgLy8gd2hpY2ggY2F1c2VzIHRoZSBpbnB1dCB2YWx1ZSB0byBiZSB1cGRhdGVkLCB0aGlzIHZhbHVlcyB3aWxsIGdldCBsb3N0LlxuICAgICAgICBjb25zdCBzZWxlY3Rpb25TdGFydDogbnVtYmVyID0gaW5wdXQuc2VsZWN0aW9uU3RhcnQgYXMgbnVtYmVyO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSBpbnB1dC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gaW5wdXQudmFsdWU7XG5cbiAgICAgICAgdGhpcy5fYmVmb3JlUGFzdGVIb29rKGV2ZW50KTtcblxuICAgICAgICBjb25zdCBtYXNrZWRTdHJpbmcgPSB0aGlzLmdldE1hc2tlZFN0cmluZyhwYXN0ZWREYXRhLCBzZWxlY3Rpb25TdGFydCk7XG5cbiAgICAgICAgLy8gaWYgbWFzayBpcyBhbHJlYWR5IGZpbGxlZCB1cCAoYW5kIG5vIGNoYXJhY3RlcnMgYXJlIHNlbGVjdGVkIHdpdGggdGhlIGN1cnNvciksIGRvIG5vdGhpbmdcbiAgICAgICAgaWYgKGlucHV0LnZhbHVlLmxlbmd0aCA9PT0gdGhpcy5fbWFzay5sZW5ndGggJiYgbWFza2VkU3RyaW5nLmxlbmd0aCA+IDAgJiYgc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2Uoc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCk7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBudWxsOyAvLyB3YXMgc2V0IGluIF9vbktleWRvd24oKSwgYnV0IHdpbGwgbm90IGJlIHVzZWQgaW4gdGhpcyBjYXNlOyBzbyByZXNldCBpdFxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGxlbmd0aCBvZiBuZXdWYWx1ZSBpcyA+PSBtYXNrOiBhbGxvdyBvbmx5IHRvIGVudGVyIGNoYXJhY3RlcnMgZnJvbSBhIHBhc3RlZCB2YWx1ZSB1bnRpbCBtYXNrIGlzIGZpbGxlZCB1cFxuICAgICAgICAvLyBleGFtcGxlOiAxMjp8MzQ6IChcInxcIiBjdXJzb3IgcG9zaXRpb24sIG1hc2s6IDAwOjAwOjAwKSA9PiB3aGVuIHBhc3RpbmcgJzU2NycsIG9ubHkgJzU2JyBmaXRzIGluIHVudGlsIGlucHV0IGlzIGZpbGxlZCB1cCA9PiAxMjo1Njp8MzRcbiAgICAgICAgLy8gZ2V0IHRoZSBwYXN0ZWQgdW5tYXNrZWQgdmFsdWUgZnJvbSB0aGUgcGFzdGVkIHN0cmluZyAodG8gY3V0IGFsbCB0aGUgaW52YWxpZCBjaGFyYWN0ZXJzIGFuZCBzZXBhcmF0b3JzKVxuICAgICAgICBjb25zdCBwYXN0ZWRVbm1hc2tlZFZhbHVlID0gdGhpcy5zZXBhcmF0b3JzLnJlZHVjZSgodW5tYXNrZWQsIHNlcGFyYXRvcikgPT4gdW5tYXNrZWQuc3BsaXQoc2VwYXJhdG9yKS5qb2luKCcnKSwgbWFza2VkU3RyaW5nKTtcblxuICAgICAgICBsZXQgbmV3VmFsdWU6IHN0cmluZyA9IHRoaXMuZ2V0TWFza2VkU3RyaW5nKFxuICAgICAgICAgICAgb2xkVmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KSArIHBhc3RlZFVubWFza2VkVmFsdWUgKyBvbGRWYWx1ZS5zdWJzdHJpbmcoc2VsZWN0aW9uRW5kIGFzIG51bWJlciwgb2xkVmFsdWUubGVuZ3RoKSxcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobmV3VmFsdWUubGVuZ3RoID49IHRoaXMuX21hc2subGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV3UG9zaXRpb24gPSBzZWxlY3Rpb25TdGFydDtcblxuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdGhpcy5nZXRNYXNrZWRTdHJpbmcoXG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbHVlLnN1YnN0cmluZygwLCBzZWxlY3Rpb25TdGFydCkgKyBwYXN0ZWRVbm1hc2tlZFZhbHVlLnN1YnN0cmluZygwLCBpKSArIG9sZFZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25FbmQgYXMgbnVtYmVyLCBvbGRWYWx1ZS5sZW5ndGgpLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgbmV3UG9zaXRpb24gKz0gdGhpcy5fY2FsY3VsYXRlQ3Vyc29yU2hpZnQobmV3UG9zaXRpb24pO1xuXG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfSB3aGlsZSAobmV3VmFsdWUubGVuZ3RoIDwgdGhpcy5fbWFzay5sZW5ndGgpO1xuXG4gICAgICAgICAgICAvLyBzYXZlIHZhbHVlIGZvciB1c2luZyBpdCBpbiBfb25JbnB1dENoYW5nZSgpXG4gICAgICAgICAgICB0aGlzLl9wYXN0ZWREYXRhID0gbmV3VmFsdWU7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG5ld1Bvc2l0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHBhc3RpbmcgaXMgZmluZTogc2F2ZSB0aGUgY3Vyc29yIHBvc2l0aW9uIGZvciB1c2luZyB0aGVtIGluIF9vbklucHV0Q2hhbmdlKClcbiAgICAgICAgdGhpcy5fY3Vyc29yID0ge1xuICAgICAgICAgICAgcG9zaXRpb246IHNlbGVjdGlvblN0YXJ0ICsgbWFza2VkU3RyaW5nLmxlbmd0aCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWFjdGl2YXRlTWFzaykge1xuICAgICAgICAgICAgLy8gV3JpdGUgVXBwZXJDYXNlXG4gICAgICAgICAgICBpZiAodGhpcy5fY29udmVydFRvID09PSAndXBwZXInKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jb252ZXJ0VG8gPT09ICdsb3dlcicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgLy8gX2lucHV0VmFsdWUgaXMgbmVlZGVkIGZvciBjYWxjdWxhdGluZyB0aGUgY3Vyc29yIHNoaWZ0IGluIG9uSW5wdXQoKVxuICAgICAgICB0aGlzLl9pbnB1dFZhbHVlID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBnZXRNYXNrZWRTdHJpbmcoaW5wdXRWYWx1ZTogc3RyaW5nLCBtYXNrU3RhcnRJbmRleCA9IDApOiBzdHJpbmcge1xuICAgICAgICBsZXQgZm9ybWF0dGVkVmFsdWUgPSAnJztcbiAgICAgICAgbGV0IG1hc2tJbmRleCA9IG1hc2tTdGFydEluZGV4O1xuICAgICAgICBsZXQgaW5wdXRJbmRleCA9IDA7XG5cbiAgICAgICAgLy8gaW5zZXJ0IGlmIG5leHQgaW4gbWFzayBpcyBzZXBhcmF0b3JcbiAgICAgICAgd2hpbGUgKHRoaXMuaXNTZXBhcmF0b3IodGhpcy5tYXNrW21hc2tJbmRleF0pKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZSArPSB0aGlzLm1hc2tbbWFza0luZGV4XTtcbiAgICAgICAgICAgIG1hc2tJbmRleCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGlucHV0SW5kZXggPCBpbnB1dFZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdGVzdCBpZiBsZXR0ZXJzIGFyZSB2YWxpZFxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzU3RyaW5nQWxsb3dlZChpbnB1dFZhbHVlW2lucHV0SW5kZXhdLCB0aGlzLm1hc2tbbWFza0luZGV4XSBhcyBNQVNLX1RZUEUpKSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUgKz0gaW5wdXRWYWx1ZVtpbnB1dEluZGV4XTtcbiAgICAgICAgICAgICAgICBpbnB1dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgbWFza0luZGV4Kys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0SW5kZXgrKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaW5zZXJ0IGlmIG5leHQgaW4gbWFzayBpcyBzZXBhcmF0b3JcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLmlzU2VwYXJhdG9yKHRoaXMubWFza1ttYXNrSW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlICs9IHRoaXMubWFza1ttYXNrSW5kZXhdO1xuICAgICAgICAgICAgICAgIG1hc2tJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZFZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgaXNTZXBhcmF0b3IodmFsdWU6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VwYXJhdG9ycy5pbmNsdWRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gY29udHJvbCB2YWx1ZSBhY2Nlc3NvclxuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdmFNb2RlbENoYW5nZS5uZXh0KHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMuZGVhY3RpdmF0ZU1hc2spIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVmFsdWUodmFsdWUgfHwgdGhpcy5nZXRVbm1hc2tlZFZhbHVlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWYWx1ZSh0aGlzLmdldE1hc2tlZFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sgPSBvbkNoYW5nZTtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChvblRvdWNoZWQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vblRvdWNoZWRDYWxsYmFjayA9IG9uVG91Y2hlZDtcbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UgPSBmbjtcbiAgICB9XG5cbiAgICBfdmFsaWRhdGVGbigpIHtcbiAgICAgICAgY29uc3QgaW5wdXRMZW5ndGggPSB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWUubGVuZ3RoO1xuICAgICAgICBjb25zdCBtYXNrTGVuZ3RoID0gdGhpcy5fbWFzay5sZW5ndGg7XG4gICAgICAgIGlmIChpbnB1dExlbmd0aCAhPT0gbWFza0xlbmd0aCAmJiAhdGhpcy5kZWFjdGl2YXRlTWFzaykge1xuICAgICAgICAgICAgcmV0dXJuIHsgbnhNYXNrTGVuZ3RoRXJyb3I6IHsgbGVuZ3RoOiBtYXNrTGVuZ3RoLCBhY3R1YWw6IGlucHV0TGVuZ3RoIH0gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKiogQGRvY3MtcHJpdmF0ZSAqL1xuICAgIHZhbGlkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZU1hc2sgPyB0aGlzLl92YWxpZGF0ZUZuKCkgOiBudWxsO1xuICAgIH1cblxuICAgIF90b3VjaCgpIHtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG59XG4iXX0=