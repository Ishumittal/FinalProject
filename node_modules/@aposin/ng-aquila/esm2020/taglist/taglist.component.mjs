import { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, forwardRef, Input, Output, ViewChildren, } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { NxTagComponent } from './tag.component';
import * as i0 from "@angular/core";
import * as i1 from "./tag.component";
import * as i2 from "@angular/common";
export class NxTaglistComponent {
    constructor(_cdr) {
        this._cdr = _cdr;
        /** An event is dispatched each time when the list of tags changed. */
        this.tagsChange = new EventEmitter();
        /** An event is dispatched each time when a tag is clicked. */
        this.tagClickEvent = new EventEmitter();
        this._tags = [];
        this._tabindex = -1;
        this._allowTagDeletion = true;
        this._isKeywordList = false;
        this._labelProperty = 'nxTaglistLabel';
        this._valueFormatterFn = value => value;
        this._onChange = () => { };
        this._onTouched = () => { };
    }
    /** Sets the list of tags. */
    set tags(value) {
        this._tags = value;
        this._cdr.markForCheck();
    }
    get tags() {
        return this._tags;
    }
    /** Sets the tabindex of the contained tags. Default value: -1. */
    set tabindex(value) {
        this._tabindex = coerceNumberProperty(value);
        this._cdr.markForCheck();
    }
    get tabindex() {
        return this.allowTagDeletion ? 0 : this._tabindex;
    }
    /** Whether the tags can be removed from the list. Default: true. */
    set allowTagDeletion(value) {
        this._allowTagDeletion = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get allowTagDeletion() {
        return this._allowTagDeletion;
    }
    /** Whether the tags can be styled as keywords. */
    set isKeywordList(value) {
        this._isKeywordList = coerceBooleanProperty(value);
        this._cdr.markForCheck();
    }
    get isKeywordList() {
        return this._isKeywordList;
    }
    /** Sets the label property, in case tags represent objects. */
    set labelProp(value) {
        if (this._labelProperty !== value) {
            this._labelProperty = value;
            this._cdr.markForCheck();
        }
    }
    get labelProp() {
        return this._labelProperty;
    }
    /** Sets the label property to improve accessibility. */
    set labelledby(value) {
        if (this._ariaLabelledBy !== value) {
            this._ariaLabelledBy = value;
            this._cdr.markForCheck();
        }
    }
    get labelledby() {
        return this._ariaLabelledBy;
    }
    /** Sets the customization function for tag value.  */
    set valueFormatter(fn) {
        this._valueFormatterFn = fn;
        this._cdr.markForCheck();
    }
    get valueFormatter() {
        return this._valueFormatterFn;
    }
    /** Allows to delete a tag given index. Takes index of the tag to be deleted as a parameter */
    delete(index, value) {
        if (this.allowTagDeletion) {
            this.tags = [...this.tags.slice(0, index), ...this.tags.slice(index + 1)];
            // focus next element after deletion
            if (this.tagChildren.toArray()[index + 1]) {
                this.tagChildren.toArray()[index + 1].nativeElement.focus();
            }
            this._onChange(this.tags);
            this.tagsChange.emit(this.tags);
        }
    }
    /** Allows to add a tag. Takes tag object as an input */
    addTag(tag) {
        if (!tag) {
            return;
        }
        // make sure tag is either string or has the configured label prop and is not yet in the list
        if ((typeof tag === 'string' && !this.tags.includes(tag)) ||
            (tag[this.labelProp] && this.tags.filter(t => t[this.labelProp] === tag[this.labelProp]).length < 1)) {
            this.tags = [...this.tags, tag];
            this._onChange(this.tags);
            this.tagsChange.emit(this.tags);
        }
    }
    /** Allows to clear the tag list. */
    clearTags() {
        this.tags = [];
        this._onChange(this.tags);
        this.tagsChange.emit(this.tags);
    }
    /** @docs-private */
    writeValue(tags) {
        this.tags = tags;
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    /** @docs-private */
    renderTag(tag) {
        const tagStr = typeof tag === 'string' ? tag : tag[this.labelProp];
        return this.valueFormatter(tagStr);
    }
    /** @docs-private */
    tagClick(index, value) {
        this.tagClickEvent.emit(this.tags[index]);
    }
}
NxTaglistComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTaglistComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
NxTaglistComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.1", type: NxTaglistComponent, selector: "nx-taglist", inputs: { tags: ["nxTags", "tags"], tabindex: "tabindex", allowTagDeletion: ["nxAllowTagDeletion", "allowTagDeletion"], isKeywordList: ["nxIsKeywordList", "isKeywordList"], labelProp: ["nxLabelProperty", "labelProp"], labelledby: ["aria-labelledby", "labelledby"], valueFormatter: ["nxValueFormatter", "valueFormatter"] }, outputs: { tagsChange: "nxTagsChange", tagClickEvent: "nxTagClick" }, host: { properties: { "class.nx-taglist--keyword": "isKeywordList", "attr.aria-labelledby": "labelledby || null", "attr.tabindex": "-1" } }, providers: [
        {
            provide: NG_VALUE_ACCESSOR,
            useExisting: forwardRef(() => NxTaglistComponent),
            multi: true,
        },
    ], viewQueries: [{ propertyName: "tagChildren", predicate: NxTagComponent, descendants: true, read: ElementRef }], ngImport: i0, template: "<ul class=\"nx-taglist\" *ngIf=\"tags.length > 0\">\n    <li class=\"nx-taglist__list-item\" tabindex=\"-1\" *ngFor=\"let tag of tags; let i = index\">\n        <nx-tag\n            [value]=\"renderTag(tag)\"\n            [removable]=\"allowTagDeletion\"\n            [tabindex]=\"tabindex\"\n            (clicked)=\"tagClick(i, $event)\"\n            (removed)=\"delete(i, $event)\"\n        ></nx-tag>\n    </li>\n</ul>\n<ng-content *ngIf=\"tags.length < 1\"></ng-content>\n", styles: [":host{position:relative;min-height:32px;display:flex;justify-content:space-between}:host:focus{outline:none}.nx-taglist{display:flex;flex-wrap:wrap}.nx-taglist__list-item{list-style:none;margin-right:12px;margin-bottom:12px;flex-wrap:wrap;display:flex}:host-context([dir=rtl]) .nx-taglist__list-item{margin-right:0;margin-right:initial;margin-left:12px}@media (max-width: 703px){.nx-taglist--keyword{justify-content:center}}\n"], components: [{ type: i1.NxTagComponent, selector: "nx-tag", inputs: ["removable", "tabindex", "value"], outputs: ["clicked", "removed"] }], directives: [{ type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.1", ngImport: i0, type: NxTaglistComponent, decorators: [{
            type: Component,
            args: [{ selector: 'nx-taglist', changeDetection: ChangeDetectionStrategy.OnPush, providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: forwardRef(() => NxTaglistComponent),
                            multi: true,
                        },
                    ], host: {
                        '[class.nx-taglist--keyword]': 'isKeywordList',
                        '[attr.aria-labelledby]': 'labelledby || null',
                        '[attr.tabindex]': '-1',
                    }, template: "<ul class=\"nx-taglist\" *ngIf=\"tags.length > 0\">\n    <li class=\"nx-taglist__list-item\" tabindex=\"-1\" *ngFor=\"let tag of tags; let i = index\">\n        <nx-tag\n            [value]=\"renderTag(tag)\"\n            [removable]=\"allowTagDeletion\"\n            [tabindex]=\"tabindex\"\n            (clicked)=\"tagClick(i, $event)\"\n            (removed)=\"delete(i, $event)\"\n        ></nx-tag>\n    </li>\n</ul>\n<ng-content *ngIf=\"tags.length < 1\"></ng-content>\n", styles: [":host{position:relative;min-height:32px;display:flex;justify-content:space-between}:host:focus{outline:none}.nx-taglist{display:flex;flex-wrap:wrap}.nx-taglist__list-item{list-style:none;margin-right:12px;margin-bottom:12px;flex-wrap:wrap;display:flex}:host-context([dir=rtl]) .nx-taglist__list-item{margin-right:0;margin-right:initial;margin-left:12px}@media (max-width: 703px){.nx-taglist--keyword{justify-content:center}}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { tagsChange: [{
                type: Output,
                args: ['nxTagsChange']
            }], tagClickEvent: [{
                type: Output,
                args: ['nxTagClick']
            }], tagChildren: [{
                type: ViewChildren,
                args: [NxTagComponent, { read: ElementRef }]
            }], tags: [{
                type: Input,
                args: ['nxTags']
            }], tabindex: [{
                type: Input
            }], allowTagDeletion: [{
                type: Input,
                args: ['nxAllowTagDeletion']
            }], isKeywordList: [{
                type: Input,
                args: ['nxIsKeywordList']
            }], labelProp: [{
                type: Input,
                args: ['nxLabelProperty']
            }], labelledby: [{
                type: Input,
                args: ['aria-labelledby']
            }], valueFormatter: [{
                type: Input,
                args: ['nxValueFormatter']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFnbGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL3RhZ2xpc3QvdGFnbGlzdC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1hcXVpbGEvc3JjL3RhZ2xpc3QvdGFnbGlzdC5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWdCLHFCQUFxQixFQUFFLG9CQUFvQixFQUFlLE1BQU0sdUJBQXVCLENBQUM7QUFDL0csT0FBTyxFQUNILHVCQUF1QixFQUV2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixVQUFVLEVBQ1YsS0FBSyxFQUNMLE1BQU0sRUFFTixZQUFZLEdBQ2YsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXpFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7OztBQW9CakQsTUFBTSxPQUFPLGtCQUFrQjtJQThGM0IsWUFBb0IsSUFBdUI7UUFBdkIsU0FBSSxHQUFKLElBQUksQ0FBbUI7UUE3RjNDLHNFQUFzRTtRQUM5QyxlQUFVLEdBQXdCLElBQUksWUFBWSxFQUFTLENBQUM7UUFFcEYsOERBQThEO1FBQ3hDLGtCQUFhLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFLekUsVUFBSyxHQUFVLEVBQUUsQ0FBQztRQVdsQixjQUFTLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFXZixzQkFBaUIsR0FBRyxJQUFJLENBQUM7UUFXekIsbUJBQWMsR0FBRyxLQUFLLENBQUM7UUFXdkIsbUJBQWMsR0FBRyxnQkFBZ0IsQ0FBQztRQTBCbEMsc0JBQWlCLEdBQTJCLEtBQUssQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDO1FBVzNELGNBQVMsR0FBeUIsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDO1FBQzND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TCx1QkFBdUIsQ0FBQyxNQUFNLGFBRXBDO3dCQUNQOzRCQUNJLE9BQU8sRUFBRSxpQkFBaUI7NEJBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLG1CQUFtQixDQUFDOzRCQUNqRCxLQUFLLEVBQUUsSUFBSTt5QkFDZDtxQkFDSixRQUNLO3dCQUNGLDZCQUE2QixFQUFFLGVBQWU7d0JBQzlDLHdCQUF3QixFQUFFLG9CQUFvQjt3QkFDOUMsaUJBQWlCLEVBQUUsSUFBSTtxQkFDMUI7d0dBSXVCLFVBQVU7c0JBQWpDLE1BQU07dUJBQUMsY0FBYztnQkFHQSxhQUFhO3NCQUFsQyxNQUFNO3VCQUFDLFlBQVk7Z0JBR2dDLFdBQVc7c0JBQTlELFlBQVk7dUJBQUMsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRTtnQkFLOUMsSUFBSTtzQkFEUCxLQUFLO3VCQUFDLFFBQVE7Z0JBWVgsUUFBUTtzQkFEWCxLQUFLO2dCQVlGLGdCQUFnQjtzQkFEbkIsS0FBSzt1QkFBQyxvQkFBb0I7Z0JBWXZCLGFBQWE7c0JBRGhCLEtBQUs7dUJBQUMsaUJBQWlCO2dCQVlwQixTQUFTO3NCQURaLEtBQUs7dUJBQUMsaUJBQWlCO2dCQWNwQixVQUFVO3NCQURiLEtBQUs7dUJBQUMsaUJBQWlCO2dCQWNwQixjQUFjO3NCQURqQixLQUFLO3VCQUFDLGtCQUFrQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJvb2xlYW5JbnB1dCwgY29lcmNlQm9vbGVhblByb3BlcnR5LCBjb2VyY2VOdW1iZXJQcm9wZXJ0eSwgTnVtYmVySW5wdXQgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgUXVlcnlMaXN0LFxuICAgIFZpZXdDaGlsZHJlbixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IE54VGFnQ29tcG9uZW50IH0gZnJvbSAnLi90YWcuY29tcG9uZW50JztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdueC10YWdsaXN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RhZ2xpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHN0eWxlVXJsczogWycuL3RhZ2xpc3QuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgICAgICB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBOeFRhZ2xpc3RDb21wb25lbnQpLFxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbY2xhc3MubngtdGFnbGlzdC0ta2V5d29yZF0nOiAnaXNLZXl3b3JkTGlzdCcsXG4gICAgICAgICdbYXR0ci5hcmlhLWxhYmVsbGVkYnldJzogJ2xhYmVsbGVkYnkgfHwgbnVsbCcsXG4gICAgICAgICdbYXR0ci50YWJpbmRleF0nOiAnLTEnLFxuICAgIH0sXG59KVxuZXhwb3J0IGNsYXNzIE54VGFnbGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yIHtcbiAgICAvKiogQW4gZXZlbnQgaXMgZGlzcGF0Y2hlZCBlYWNoIHRpbWUgd2hlbiB0aGUgbGlzdCBvZiB0YWdzIGNoYW5nZWQuICovXG4gICAgQE91dHB1dCgnbnhUYWdzQ2hhbmdlJykgdGFnc0NoYW5nZTogRXZlbnRFbWl0dGVyPGFueVtdPiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55W10+KCk7XG5cbiAgICAvKiogQW4gZXZlbnQgaXMgZGlzcGF0Y2hlZCBlYWNoIHRpbWUgd2hlbiBhIHRhZyBpcyBjbGlja2VkLiAqL1xuICAgIEBPdXRwdXQoJ254VGFnQ2xpY2snKSB0YWdDbGlja0V2ZW50OiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqIEBkb2NzLXByaXZhdGUgKi9cbiAgICBAVmlld0NoaWxkcmVuKE54VGFnQ29tcG9uZW50LCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSkgdGFnQ2hpbGRyZW4hOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG5cbiAgICBwcml2YXRlIF90YWdzOiBhbnlbXSA9IFtdO1xuICAgIC8qKiBTZXRzIHRoZSBsaXN0IG9mIHRhZ3MuICovXG4gICAgQElucHV0KCdueFRhZ3MnKVxuICAgIHNldCB0YWdzKHZhbHVlOiBhbnlbXSkge1xuICAgICAgICB0aGlzLl90YWdzID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG4gICAgZ2V0IHRhZ3MoKTogYW55W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFncztcbiAgICB9XG5cbiAgICBwcml2YXRlIF90YWJpbmRleCA9IC0xO1xuICAgIC8qKiBTZXRzIHRoZSB0YWJpbmRleCBvZiB0aGUgY29udGFpbmVkIHRhZ3MuIERlZmF1bHQgdmFsdWU6IC0xLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IHRhYmluZGV4KHZhbHVlOiBOdW1iZXJJbnB1dCkge1xuICAgICAgICB0aGlzLl90YWJpbmRleCA9IGNvZXJjZU51bWJlclByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBnZXQgdGFiaW5kZXgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsb3dUYWdEZWxldGlvbiA/IDAgOiB0aGlzLl90YWJpbmRleDtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9hbGxvd1RhZ0RlbGV0aW9uID0gdHJ1ZTtcbiAgICAvKiogV2hldGhlciB0aGUgdGFncyBjYW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBsaXN0LiBEZWZhdWx0OiB0cnVlLiAqL1xuICAgIEBJbnB1dCgnbnhBbGxvd1RhZ0RlbGV0aW9uJylcbiAgICBzZXQgYWxsb3dUYWdEZWxldGlvbih2YWx1ZTogQm9vbGVhbklucHV0KSB7XG4gICAgICAgIHRoaXMuX2FsbG93VGFnRGVsZXRpb24gPSBjb2VyY2VCb29sZWFuUHJvcGVydHkodmFsdWUpO1xuICAgICAgICB0aGlzLl9jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuICAgIGdldCBhbGxvd1RhZ0RlbGV0aW9uKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsb3dUYWdEZWxldGlvbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9pc0tleXdvcmRMaXN0ID0gZmFsc2U7XG4gICAgLyoqIFdoZXRoZXIgdGhlIHRhZ3MgY2FuIGJlIHN0eWxlZCBhcyBrZXl3b3Jkcy4gKi9cbiAgICBASW5wdXQoJ254SXNLZXl3b3JkTGlzdCcpXG4gICAgc2V0IGlzS2V5d29yZExpc3QodmFsdWU6IEJvb2xlYW5JbnB1dCkge1xuICAgICAgICB0aGlzLl9pc0tleXdvcmRMaXN0ID0gY29lcmNlQm9vbGVhblByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBnZXQgaXNLZXl3b3JkTGlzdCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzS2V5d29yZExpc3Q7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbGFiZWxQcm9wZXJ0eSA9ICdueFRhZ2xpc3RMYWJlbCc7XG4gICAgLyoqIFNldHMgdGhlIGxhYmVsIHByb3BlcnR5LCBpbiBjYXNlIHRhZ3MgcmVwcmVzZW50IG9iamVjdHMuICovXG4gICAgQElucHV0KCdueExhYmVsUHJvcGVydHknKVxuICAgIHNldCBsYWJlbFByb3AodmFsdWU6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5fbGFiZWxQcm9wZXJ0eSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xhYmVsUHJvcGVydHkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGFiZWxQcm9wKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYWJlbFByb3BlcnR5O1xuICAgIH1cblxuICAgIHByaXZhdGUgX2FyaWFMYWJlbGxlZEJ5ITogc3RyaW5nO1xuICAgIC8qKiBTZXRzIHRoZSBsYWJlbCBwcm9wZXJ0eSB0byBpbXByb3ZlIGFjY2Vzc2liaWxpdHkuICovXG4gICAgQElucHV0KCdhcmlhLWxhYmVsbGVkYnknKVxuICAgIHNldCBsYWJlbGxlZGJ5KHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FyaWFMYWJlbGxlZEJ5ICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXJpYUxhYmVsbGVkQnkgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX2Nkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgbGFiZWxsZWRieSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXJpYUxhYmVsbGVkQnk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfdmFsdWVGb3JtYXR0ZXJGbjogKHZhbHVlOiBhbnkpID0+IHN0cmluZyA9IHZhbHVlID0+IHZhbHVlO1xuICAgIC8qKiBTZXRzIHRoZSBjdXN0b21pemF0aW9uIGZ1bmN0aW9uIGZvciB0YWcgdmFsdWUuICAqL1xuICAgIEBJbnB1dCgnbnhWYWx1ZUZvcm1hdHRlcicpXG4gICAgc2V0IHZhbHVlRm9ybWF0dGVyKGZuOiAodmFsdWU6IGFueSkgPT4gc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlRm9ybWF0dGVyRm4gPSBmbjtcbiAgICAgICAgdGhpcy5fY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cbiAgICBnZXQgdmFsdWVGb3JtYXR0ZXIoKTogKHZhbHVlOiBhbnkpID0+IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLl92YWx1ZUZvcm1hdHRlckZuO1xuICAgIH1cblxuICAgIHByaXZhdGUgX29uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICAgIHByaXZhdGUgX29uVG91Y2hlZDogKCkgPT4gYW55ID0gKCkgPT4ge307XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jZHI6IENoYW5nZURldGVjdG9yUmVmKSB7fVxuXG4gICAgLyoqIEFsbG93cyB0byBkZWxldGUgYSB0YWcgZ2l2ZW4gaW5kZXguIFRha2VzIGluZGV4IG9mIHRoZSB0YWcgdG8gYmUgZGVsZXRlZCBhcyBhIHBhcmFtZXRlciAqL1xuICAgIGRlbGV0ZShpbmRleDogbnVtYmVyLCB2YWx1ZTogYW55KSB7XG4gICAgICAgIGlmICh0aGlzLmFsbG93VGFnRGVsZXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMudGFncyA9IFsuLi50aGlzLnRhZ3Muc2xpY2UoMCwgaW5kZXgpLCAuLi50aGlzLnRhZ3Muc2xpY2UoaW5kZXggKyAxKV07XG5cbiAgICAgICAgICAgIC8vIGZvY3VzIG5leHQgZWxlbWVudCBhZnRlciBkZWxldGlvblxuICAgICAgICAgICAgaWYgKHRoaXMudGFnQ2hpbGRyZW4udG9BcnJheSgpW2luZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ0NoaWxkcmVuLnRvQXJyYXkoKVtpbmRleCArIDFdLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy50YWdzKTtcblxuICAgICAgICAgICAgdGhpcy50YWdzQ2hhbmdlLmVtaXQodGhpcy50YWdzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBBbGxvd3MgdG8gYWRkIGEgdGFnLiBUYWtlcyB0YWcgb2JqZWN0IGFzIGFuIGlucHV0ICovXG4gICAgYWRkVGFnKHRhZzogYW55KSB7XG4gICAgICAgIGlmICghdGFnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgdGFnIGlzIGVpdGhlciBzdHJpbmcgb3IgaGFzIHRoZSBjb25maWd1cmVkIGxhYmVsIHByb3AgYW5kIGlzIG5vdCB5ZXQgaW4gdGhlIGxpc3RcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnICYmICF0aGlzLnRhZ3MuaW5jbHVkZXModGFnKSkgfHxcbiAgICAgICAgICAgICh0YWdbdGhpcy5sYWJlbFByb3BdICYmIHRoaXMudGFncy5maWx0ZXIodCA9PiB0W3RoaXMubGFiZWxQcm9wXSA9PT0gdGFnW3RoaXMubGFiZWxQcm9wXSkubGVuZ3RoIDwgMSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLnRhZ3MgPSBbLi4udGhpcy50YWdzLCB0YWddO1xuICAgICAgICAgICAgdGhpcy5fb25DaGFuZ2UodGhpcy50YWdzKTtcbiAgICAgICAgICAgIHRoaXMudGFnc0NoYW5nZS5lbWl0KHRoaXMudGFncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQWxsb3dzIHRvIGNsZWFyIHRoZSB0YWcgbGlzdC4gKi9cbiAgICBjbGVhclRhZ3MoKSB7XG4gICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSh0aGlzLnRhZ3MpO1xuICAgICAgICB0aGlzLnRhZ3NDaGFuZ2UuZW1pdCh0aGlzLnRhZ3MpO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgd3JpdGVWYWx1ZSh0YWdzOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2UgPSBmbjtcbiAgICB9XG5cbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZCA9IGZuO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgcmVuZGVyVGFnKHRhZzogYW55KSB7XG4gICAgICAgIGNvbnN0IHRhZ1N0cjogc3RyaW5nID0gdHlwZW9mIHRhZyA9PT0gJ3N0cmluZycgPyB0YWcgOiB0YWdbdGhpcy5sYWJlbFByb3BdO1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUZvcm1hdHRlcih0YWdTdHIpO1xuICAgIH1cblxuICAgIC8qKiBAZG9jcy1wcml2YXRlICovXG4gICAgdGFnQ2xpY2soaW5kZXg6IG51bWJlciwgdmFsdWU6IGFueSkge1xuICAgICAgICB0aGlzLnRhZ0NsaWNrRXZlbnQuZW1pdCh0aGlzLnRhZ3NbaW5kZXhdKTtcbiAgICB9XG59XG4iLCI8dWwgY2xhc3M9XCJueC10YWdsaXN0XCIgKm5nSWY9XCJ0YWdzLmxlbmd0aCA+IDBcIj5cbiAgICA8bGkgY2xhc3M9XCJueC10YWdsaXN0X19saXN0LWl0ZW1cIiB0YWJpbmRleD1cIi0xXCIgKm5nRm9yPVwibGV0IHRhZyBvZiB0YWdzOyBsZXQgaSA9IGluZGV4XCI+XG4gICAgICAgIDxueC10YWdcbiAgICAgICAgICAgIFt2YWx1ZV09XCJyZW5kZXJUYWcodGFnKVwiXG4gICAgICAgICAgICBbcmVtb3ZhYmxlXT1cImFsbG93VGFnRGVsZXRpb25cIlxuICAgICAgICAgICAgW3RhYmluZGV4XT1cInRhYmluZGV4XCJcbiAgICAgICAgICAgIChjbGlja2VkKT1cInRhZ0NsaWNrKGksICRldmVudClcIlxuICAgICAgICAgICAgKHJlbW92ZWQpPVwiZGVsZXRlKGksICRldmVudClcIlxuICAgICAgICA+PC9ueC10YWc+XG4gICAgPC9saT5cbjwvdWw+XG48bmctY29udGVudCAqbmdJZj1cInRhZ3MubGVuZ3RoIDwgMVwiPjwvbmctY29udGVudD5cbiJdfQ==